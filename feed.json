{
    "version": "https://jsonfeed.org/version/1",
    "title": "ChilliCream GraphQL Platform",
    "home_page_url": "https://chillicream.com",
    "feed_url": "https://chillicream.com/feed.json",
    "description": "We're building the ultimate GraphQL platform",
    "icon": "https://chillicream.com/favicon-32x32.png",
    "author": {
        "name": "Chilli_Cream",
        "url": "https://twitter.com/Chilli_Cream"
    },
    "items": [
        {
            "id": "/blog/2021/01/10/hot-chocolate-logging",
            "content_html": "<p>Whether you are a building your first Hot Chocolate GraphQL server, or you&#x27;re on the core team who built it, having an easy way to see both\nthe query you&#x27;ve sent to the server immediately is very helpful and valuable. Small mistakes in syntax can be easily discovered, problems with\nvariable definitions can be tricky to uncover, and just in general, having those queries at your finger tips is a big benefit while developing or running your\nHot Chocolate GraphQL server.</p><h1>Just Show Me the Code</h1><p>You can find all the code from this article in this Github repository.</p><p><a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/blog/2021/2021-01-20-logging\">https://github.com/ChilliCream/hotchocolate-examples/tree/master/blog/2021/2021-01-20-logging</a></p><p>To start logging your GraphQL server requests this is all you need to do. First, you need to create a new class in your project that implements the listener <code>DiagnosticEventListener</code>.</p><pre><code class=\"language-csharp\">using System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing HotChocolate.Execution;\nusing HotChocolate.Execution.Instrumentation;\nusing Microsoft.Extensions.Logging;\n\nnamespace Logging\n{\n    public class ConsoleQueryLogger : DiagnosticEventListener\n    {\n        private static Stopwatch _queryTimer;\n        private readonly ILogger&lt;ConsoleQueryLogger&gt; _logger;\n        public ConsoleQueryLogger(ILogger&lt;ConsoleQueryLogger&gt; logger)\n        {\n            _logger = logger;\n        }\n\n        public override IActivityScope ExecuteRequest(IRequestContext context)\n        {\n            return new RequestScope(_logger, context);\n        }\n\n        private class RequestScope : IActivityScope\n        {\n            private readonly IRequestContext _context;\n            private readonly ILogger&lt;ConsoleQueryLogger&gt; _logger;\n            public RequestScope\n                (ILogger&lt;ConsoleQueryLogger&gt; logger,\n                     IRequestContext context)\n            {\n                _logger = logger;\n                _context = context;\n                _queryTimer = new Stopwatch();\n                _queryTimer.Start();\n            }\n\n            public void Dispose()\n            {\n                if (_context.Document is not null)\n                {\n                    StringBuilder stringBuilder =\n                        new(_context.Document.ToString(true));\n                    stringBuilder.AppendLine();\n                    if (_context.Variables != null)\n                    {\n                        var variablesConcrete =\n                            _context.Variables!.ToList();\n                        if (variablesConcrete.Count &gt; 0)\n                        {\n                            stringBuilder.\n                                AppendFormat($&quot;Variables {Environment.NewLine}&quot;);\n                            try\n                            {\n                                foreach (var variableValue in _context.Variables!)\n                                {\n                                    string PadRightHelper\n                                        (string existingString, int lengthToPadTo)\n                                    {\n                                        if (string.IsNullOrEmpty(existingString))\n                                            return &quot;&quot;.PadRight(lengthToPadTo);\n                                        if (existingString.Length &gt; lengthToPadTo)\n                                            return existingString.Substring(0, lengthToPadTo);\n                                        return existingString + &quot; &quot;.PadRight(lengthToPadTo - existingString.Length);\n                                    }\n                                    stringBuilder.AppendFormat(\n                                        $&quot;  {PadRightHelper(variableValue.Name, 20)} :  {PadRightHelper(variableValue.Value.ToString(), 20)}: {variableValue.Type}&quot;);\n                                    stringBuilder.AppendFormat($&quot;{Environment.NewLine}&quot;);\n                                }\n                            }\n                            catch\n                            {\n                                // all input type records will land here.\n                                stringBuilder.Append(&quot;  Formatting Variables Error. Continuing...&quot;);\n                                stringBuilder.AppendFormat($&quot;{Environment.NewLine}&quot;);\n                            }\n                        }\n                    }\n                    _queryTimer.Stop();\n                    stringBuilder.AppendFormat(\n                        $&quot;Ellapsed time for query is {_queryTimer.Elapsed.TotalMilliseconds:0.#} milliseconds.&quot;);\n                    _logger.LogInformation(stringBuilder.ToString());\n                }\n            }\n        }\n    }\n}\n</code></pre><p>Then, in your <code>startup.cs</code>, you need to subscribe to the the Hot Chocolate <code>DiagnosticEventListener</code>, which is what the above <code>ConsoleQueryLogger</code> class implements.</p><p>That&#x27;s done in the <code>ConfigureServices</code> method in <code>startup.cs</code>.</p><pre><code class=\"language-csharp\">public class Startup\n{\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services\n            .AddRouting()\n            .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n            .AddDiagnosticEventListener(sp =&gt;\n              new ConsoleQueryLogger(\n                sp.GetApplicationService&lt;ILogger&lt;ConsoleQueryLogger&gt;&gt;()\n              ));\n    }\n\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n    {\n        if (env.IsDevelopment()) app.UseDeveloperExceptionPage();\n\n        app.UseRouting();\n\n        app.UseEndpoints(endpoints =&gt; { endpoints.MapGraphQL(); });\n    }\n}\n</code></pre><p>For this logger to have something to do, we need to have a <code>Query</code> in our project so let&#x27;s make a very simple class and put it in a file <code>Query.cs</code>.</p><p>Let&#x27;s assume you have in your <code>Query.cs</code> a resolver that takes a single parameter and returns a string based on a passed in parameter (like this for example).</p><pre><code class=\"language-csharp\">namespace logging\n{\n    public class Query\n    {\n        public Person GetPerson(bool upperCase = false)\n        {\n            return upperCase ?\n                new Person(&quot;Luke Skywalker&quot;.ToUpper(), 101) :\n                new Person(&quot;Luke Skywalker&quot;, 102);\n        }\n    }\n\n    public class Person\n    {\n        public Person(string name,int id)\n        {\n            Name = name; Id = id;\n        }\n        public string Name { get; }\n        public int Id { get; }\n    }\n}\n</code></pre><p>When you execute the GraphQL query</p><pre><code class=\"language-graphql\">query person($upperCase: Boolean) {\n  person(upperCase: $upperCase) {\n    name\n    id\n  }\n}\n</code></pre><p>with the associated <code>Boolean</code> variable in your POST <code>upperCase</code></p><pre><code class=\"language-json\">{\n  &quot;upperCase&quot;: true\n}\n</code></pre><p>You console output will show this</p><pre><code class=\"language-bash\">Executing endpoint &#x27;Hot Chocolate GraphQL Pipeline&#x27;\ninfo: logging.ConsoleQueryLogger[0]\n\nquery person($upperCase: Boolean) {\n  person(upperCase: $upperCase) {\n    name\n    id\n  }\n}\nVariables\nupperCase    :true  :HotChocolate.Types.BooleanType\nEllapsed time for query is 162 milliseconds.\n</code></pre><p>Notice the execution time shows as 162 milliseconds. If you execute the query again, you&#x27;ll see that drop to just 1 or 2 milliseconds as now, the query, along with it&#x27;s resolvers are cached by Hot Chocolate.</p><p>Now, for a little more details on what&#x27;s actually happening here, as well as how to log your queries using the very useful</p><a href=\"https://miniprofiler.com/dotnet/AspDotNetCore\" target=\"_blank\">MiniProfiler for ASP.NET Core</a>.<h1>What is Really Going on Here</h1><p>Adding console logging is really quite simple in what is going on. It&#x27;s straight forward usage of both the ASP.NET Core <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection\" target=\"_blank\">Dependency Injection</a> and <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware\" target=\"_blank\">Middleware</a> implementations.</p><p>That middleware is added to our <code>startup.cs</code>.</p><pre><code class=\"language-csharp\">.AddDiagnosticEventListener(sp =&gt;\n  new ConsoleQueryLogger(\n    sp.GetApplicationService&lt;ILogger&lt;ConsoleQueryLogger&gt;&gt;()\n  ));\n</code></pre><p><code>AddDiagnosticEventListener</code> is adding to the Hot Chocolate GraphQL server a listener designed to listen for events that happen while the server is processing requests. Typically, these are diagnostic events that give us the ability to do things like capture GraphQL queries and variables while at the same time, doing something useful with them (like log them to the console).</p><p>Our <code>ConsoleQueryLogger</code> receives as an injected service, the logger itself, that uses the <a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging\" target=\"_blank\">ASP.NET Core Logging API</a>, and the built in Console logging provider, <code>AddConsole</code>.</p><p>You will need to make sure that in your <code>program.cs</code> you&#x27;ve added <code>ConfigureLogging</code> to your <code>CreateHostBuilder</code> method. It should look similar to this.</p><pre><code class=\"language-csharp\">public static IHostBuilder\n  CreateHostBuilder(string[] args) =&gt;\n    Host.CreateDefaultBuilder(args)\n        .ConfigureLogging(c =&gt; c.AddConsole())\n        .ConfigureWebHostDefaults(webBuilder =&gt;\n        {\n            webBuilder.UseStartup&lt;Startup&gt;();\n        });\n</code></pre><p>Back to our <code>ConsoleQueryLogger</code> class. The entire purpose of this class is to hook into the Hot Chocolate GraphQL processing pipeline such that we can start a timer before the query starts processing. Then, at that processing completion, the query details, the variables associated with the query and the execution time are logged.</p><p>Because this method implements the Hot Chocolate <code>DiagnosticEventListener</code>, we can override the <code>ExecuteRequest</code> method which gives us a way to hook into the processing pipeline. That &quot;hook in&quot; is by way of Dependency Injection. By making the first parameter of that method an <code>IRequestContext</code>, we can get passed into this method, our GraphQL context for this request. That context contains all the details about the request including the query itself and its associated request variables.</p><p>From here, we create a new <code>RequestScope</code>, that will track our entire request from start to finish in the Hot Chocolate GraphQL server. We pass into that <code>RequestScope</code>, our console logger and our newly acquired GraphQL context.</p><p>Essentially, this new <code>RequestScope</code> tracks our GraphQL query from start to finish. We make use of <code>System.Diagnostics.Stopwatch</code> to time our request. We start the timer in the <code>RequestScope</code>&#x27;s constructor, and we stop it in its <code>Dispose</code> method. Because we have access to our request details, as well as the logger class, we can output our complete query to our logger on the completion of the request processing.</p><pre><code class=\"language-csharp\">public void Dispose()\n{\n    if (_context.Document is not null)\n        _logger.LogInformation(_context.Document.ToString(true));\n}\n</code></pre><p>You don&#x27;t really need to understand all these details to use the logger, and likely, in the future you would probably get this from another <code>nuget</code> package. For now, it&#x27;s interesting to see how straight forward it is to hook directly into the processing of your GraphQL request.</p><h1>Logging Requests to MiniProfiler</h1><p>Console logs are nice, but can get pretty cluttered and become unmanageable quickly. Luckily for us, there is very useful open source project that we can include for free in our apps called <a href=\"https://miniprofiler.com/dotnet/AspDotNetCore\" target=\"_blank\">MiniProfiler</a> and there is an implementation specifically written for <a href=\"https://docs.microsoft.com/en-us/aspnet/core\" target=\"_blank\">ASP.NET Core</a>.</p><p>The idea is that you get a URL route you can secure on your website that lists the queries you&#x27;ve run and how long each one took. Typically it&#x27;s something like <u>http://localhost:5000/profiler/results-index</u>. Here is an example of us running the query we wrote earlier, multiple times.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:640px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/eb9ddbd28bb308a1a950d5298092eb4b/1bed9/MiniProfiler-Index-640.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:37%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3ElEQVQY05VQ0W7EIAzr/3/hHm9ae7pCD5ImBCjtbRb0B2ZFkQnYCZnaeZacVcTMiFmTqZmkVOvB+76LIFAXTf02RSJRtZSEeQpaH14em3op67oSkXNuWRYmih0wVYW5oK6dlZJ/O6Yl2tdLEXPQdX1BvzyfEIPknKFsDcOdIMPo7LjFbylztJ9g255jDHjhvXfOhxBKx9EBI3wCeRxvMab9fieEY9u2DRpktAXJHbUDPZkZGRyz3OKQ2kx1phJSZYpY0tCjz2hyXdfnc2F/+O84Arf4OG6b/+Js7Q+JN5Iq5HUMqAAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MiniProfiler Index Web Page\" title=\"MiniProfiler Index Web Page\" src=\"https://chillicream.com/static/eb9ddbd28bb308a1a950d5298092eb4b/1bed9/MiniProfiler-Index-640.png\" srcSet=\"https://chillicream.com/static/eb9ddbd28bb308a1a950d5298092eb4b/f8f3a/MiniProfiler-Index-640.png 200w,https://chillicream.com/static/eb9ddbd28bb308a1a950d5298092eb4b/6a8a8/MiniProfiler-Index-640.png 400w,https://chillicream.com/static/eb9ddbd28bb308a1a950d5298092eb4b/1bed9/MiniProfiler-Index-640.png 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>You can drill down on each one if these queries, and see the actual query as well as the passed in variables along with their associated input data.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:640px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/6639ac942d3d8de8a02115d01be3d1a7/1bed9/MiniProfiler-Detail-640.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:43.50000000000001%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9ElEQVQoz5VQWW7FIAzM/Q/XCzypf1USwCwOPDZDaoIUpR+t1JEFXhjbzII+WOu0ts4haLvuchOwCsXOLgGM+2kowWiL27ZzbTHGKKmElLsQABBTKqXmknPhu7beb6PWKhHnnXNKCqp1kK21BzprLOLRWjsf6A9wKV8Y8wB6Pxd+Ed5xA+RlcoqNG/6J2SWlxMSLnMpLxk/IG1YV6vk7mMn8OxxkjnWo79LYMvX/kVkDVoJLw66tnv98gohYx7vREkpftf94fa3KCYOsJOvH4ksWVMjjOMID3vubPCYLTxgp5hJyjYXmhFueucVMTmcO5cMZ8w0VKAuZCI3IPwAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MiniProfiler Detail Web Page\" title=\"MiniProfiler Detail Web Page\" src=\"https://chillicream.com/static/6639ac942d3d8de8a02115d01be3d1a7/1bed9/MiniProfiler-Detail-640.png\" srcSet=\"https://chillicream.com/static/6639ac942d3d8de8a02115d01be3d1a7/f8f3a/MiniProfiler-Detail-640.png 200w,https://chillicream.com/static/6639ac942d3d8de8a02115d01be3d1a7/6a8a8/MiniProfiler-Detail-640.png 400w,https://chillicream.com/static/6639ac942d3d8de8a02115d01be3d1a7/1bed9/MiniProfiler-Detail-640.png 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>Just like for the <code>ConsoleQueryLogger</code> class, we need to create a similar class for our MiniProfiler to work. I&#x27;ve done that in our example repository and named the class <code>MiniProfilerQueryLogger</code>.</p><p><a href=\"https://github.com/pkellner/hot-chocolate-query-logging/blob/main/MiniProfilerQueryLogger.cs\">https://github.com/pkellner/hot-chocolate-query-logging/blob/main/MiniProfilerQueryLogger.cs</a></p><p>It also implements <code>DiagosticEventListener</code> just like <code>ConsoleQueryLogger</code> did. It gets passed in the request context, but instead of logging to the console with the <code>ILogger</code> interface and the <code>ConsoleLoggerExtension</code>, it simply calls the MiniProfiler API directly.</p><p>I could have implemented it with the ILogger interface and that would have given a lot more flexibility to our logging, but that also would have added a lot more complexity, so for now, if you want to log to MiniProfiler, add this middleware to your GraphQL.</p><p>We do need to install the MiniProfiler package for ASP.NET Core so let&#x27;s do that at the command line with <code>nuget</code>. That command is:</p><pre><code class=\"language-bash\">dotnet add package MiniProfiler.AspNetCore.Mvc\n</code></pre><p>Then, to our <code>startup.cs</code>, we need to add several things. They are:</p><p>In <code>ConfigureServices</code></p><ol><li>Add MVC to our app by adding the service <code>AddControllersWithViews</code></li><li>Add the <code>MiniProfilerQueryLogger</code> service</li><li>Add the <code>MiniProfiler</code> itself to the our services.</li></ol><p>In <code>Configure</code></p><ol><li>Add to our app builder <code>useMiniProfiler</code></li></ol><p>Here is our final <code>startup.cs</code>.</p><pre><code class=\"language-csharp\">using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nnamespace logging\n{\n    public class Startup\n    {\n        public void ConfigureServices\n           (IServiceCollection services)\n        {\n            services.AddControllersWithViews();\n            services\n                .AddRouting()\n                .AddGraphQLServer()\n                .AddQueryType&lt;Query&gt;()\n                .AddDiagnosticEventListener(sp =&gt;\n                    new ConsoleQueryLogger\n                        (sp.GetApplicationService\n                           &lt;ILogger&lt;ConsoleQueryLogger&gt;&gt;()))\n                .AddDiagnosticEventListener(sp =&gt;\n                    new MiniProfilerQueryLogger());\n            services.AddMiniProfiler(options =&gt;\n                { options.RouteBasePath = &quot;/profiler&quot;; });\n        }\n\n        public void Configure(IApplicationBuilder app,\n            IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment())\n            {\n                app.UseDeveloperExceptionPage();\n            }\n\n            app.UseRouting();\n            app.UseMiniProfiler();\n            app.UseEndpoints(endpoints =&gt;\n              { endpoints.MapGraphQL(); });\n        }\n    }\n}\n</code></pre><p>That&#x27;s it! Now, when you run your app and do some GraphQL queries, you can browse to the URL <u>http://localhost:5000/profiler/index-results</u> and that will give you a list of all your GraphQL requests. You can drill down on any request and see both the query itself, as well as any variables passed in with the associated value and type.</p><p>Just a side note. You can run both the console logger and the MiniProfiler at the same time and both logs will work as adding listeners is additive.</p><h1>Possibilities For Logging SQL and Entity Framework</h1><p>It&#x27;s worth mentioning that <a href=\"https://miniprofiler.com\" target=\"_blank\">MiniProfiler</a> has been around for a long time and there are many configuring profiles available including ones for <a href=\"https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ado-net-overview\" target=\"_blank\">ADO.NET</a> as well as <a href=\"https://docs.microsoft.com/en-us/ef/\" target=\"_blank\">Entity Framework Core</a>.</p><p>If you&#x27;ve gotten everything working, it&#x27;s trivial to add Entity Framework support so that inside your GraphQL requests, you can see the actual SQL sent to the server and the associated timing. Literally, all you have to do is install one <code>nuget</code> package</p><pre><code class=\"language-bash\">dotnet add package MiniProfiler.EntityFrameworkCore\n</code></pre><p>And, in your <code>startup.cs</code>, change the line that adds MiniProfile as follows:</p><pre><code class=\"language-csharp\">services.AddMiniProfiler\n   (options =&gt;\n      { options.RouteBasePath = &quot;/profiler&quot;; })\n         .AddEntityFramework();\n</code></pre><p>Then, when you execute a GraphQL query that uses Entity Framework Core, you&#x27;ll get results like the following. Notice that not only do you get the GraphQL query with it&#x27;s variables, but also, you get all the SQL generated by Entity Framework that&#x27;s run on that Query&#x27;s behalf. Also notice the timing, you can see the time for the GraphQL query as well as the time for just the SQL.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:640px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/d17bdf4c28b039457c0c40dc581805cf/1bed9/MiniProfiler-Detail-EF-640.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:154%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAfCAIAAABoLHqZAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC5ElEQVQ4y51V23KcOBDli/ev8gv5jq3a+CHrsWcGDEL3CxJICJg9GiZZO7Ertk91dQno0926HappmoyxHelJD1AuhBuGwXs4DMI4zXNOxWbYnHNMCRQlGSNPFYIopdZarbVSynt/uWLbtnVdy2Bdc87LsuBVjHEcwzgmxmOYtgpBKaUxBFiM0/YDiEaiZV33gBACEuU8hzGtWSr6dTB/V3t67adGhTDFfO0N9hxI9GOIr5c1PbjTXxP/8pMcG5OGuNhpcWn18zrNq09LXrfLSyA5etnHN/KS5yebZMhlkvucn/nfyduWL9tyI6Ofk07M5+338HdUzmC6ablcPkUO8zrO+9PHyWASN0/z9hlyWrZ++BP1VTJ2EL61swzLh8l4BX9UCebT+hmyjYsIOebtw20v67b+ccavV875HcTLXuZXsh2CtAM8TLvgw5vAFf6Z6EYe46xD6pUjwnAbIALz20BhF5cxr1W55fuNnxPkg9HeWRP88J4pVOMYBx+NDT1ThErSC8YVZYIJxblW2uHTbtoU74Zx8BN8jLna20hphpK1bSeEBAOec+F9mKYIPxZMEfKVyumHulwFZqsgS9A2Y0xd16fTCXompBSCM8aQzhVA3sxVFLGOY0olB1hYdrQ94i0EkHMO+ZRS1UQej5R0ghDR1Kx9Yl3LmzMjRFKqOFNaIaFDigo6uu/BdAVynYn6fqBdJxnVTcco01IitRHClAErHo2g3//JO6CsVJi7R1qfedvKB7TQq7aT7ZPQqjBh1pYpvKh8I4cglfv2yI5nhuLgd53qmejKUlilSgvwqPwKGXB2+LeR92dxfOjv7/vDI3bN9lQLjv5NIWv3RuUxnHp1dy6EssnaSWERev1RALew18n+yr+rxT+P9HDoz7XAgWXC9p0ineRCG4Oy4c05c2m+HeixoeeaNA1mK3HyOoINk0zoXgrzfMHGlyDCcoEr5o3xbsB591iF8scs3RZzzsNwNP8DsBwAHl3uVrIAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"MiniProfiler Detail EF 640\" title=\"MiniProfiler Detail EF 640\" src=\"https://chillicream.com/static/d17bdf4c28b039457c0c40dc581805cf/1bed9/MiniProfiler-Detail-EF-640.png\" srcSet=\"https://chillicream.com/static/d17bdf4c28b039457c0c40dc581805cf/f8f3a/MiniProfiler-Detail-EF-640.png 200w,https://chillicream.com/static/d17bdf4c28b039457c0c40dc581805cf/6a8a8/MiniProfiler-Detail-EF-640.png 400w,https://chillicream.com/static/d17bdf4c28b039457c0c40dc581805cf/1bed9/MiniProfiler-Detail-EF-640.png 640w\" sizes=\"(max-width: 640px) 100vw, 640px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><h1>Wrap</h1><p>Once you have logging enabled in your Hot Chocolate GraphQL server, you&#x27;ll wonder how you ever worked without it. It&#x27;s easy to setup and does not get in the way at all while you&#x27;re building your apps.</p><p>Stay Safe.</p>",
            "url": "https://chillicream.com/blog/2021/01/10/hot-chocolate-logging",
            "title": "Log Your Queries While Building a GraphQL Server",
            "summary": "Whether you are a building your first Hot Chocolate GraphQL server, or you're on the core team who built it, having an easy way to see both…",
            "image": "https://chillicream.com/static/6d6b21148b91cc63745ff66f5c4f9680/0514f/hot-chocolate-11-logging-banner.png",
            "date_modified": "2021-01-10T00:00:00.000Z",
            "date_published": "2021-01-10T00:00:00.000Z",
            "author": {
                "name": "Peter Kellner",
                "url": "https://peterkellner.net"
            }
        },
        {
            "id": "/blog/2020/11/23/hot-chocolate-11",
            "content_html": "<p>Today we are releasing Hot Chocolate server 11. We started work on this version about 1 1/2 years ago. We occasionally took a break from this project to create another 10.x version and deliver new features to the stable branch. From a user perspective, we have provided a new feature version every two months. For the core team, it was quite an intense time creating this new server and, at the same time, looking at the old version to keep it current.</p><p>With Hot Chocolate 11, we are now fully embracing .NET 5 while still supporting older .NET platforms. If you opt into .NET 5, you will get a much more refined experience to express a GraphQL schema in entirely different ways.</p><p>Records are now fully supported and let you create full GraphQL types with a single line of code. I personally like to use records for input types when using the pure code-first (annotation based) approach.</p><pre><code class=\"language-csharp\">public record AddSessionInput(string Title, string SpeakerId);\n</code></pre><p>We reworked Hot Chocolate also to accept attributes on the parameters when using the short-hand syntax.</p><pre><code class=\"language-csharp\">public record AddSessionInput(string Title, [ID(nameof(Speaker))] string SpeakerId);\n</code></pre><p>This allows you to write very slim input types and get rid of a lot of boilerplate code.</p><p>We have also started exploring how we can use source generators to make Hot Chocolate faster and reduce boilerplate even further. You will see this trickling in with the next dot releases.</p><h1>New Configuration API</h1><p>While .NET 5 support is nice, the most significant change from an API perspective is the new configuration API, which now brings together all the different builders to set up a GraphQL server. This makes the server configuration now very accessible and straightforward to use.</p><pre><code class=\"language-csharp\">services\n    .AddGraphQLServer()\n    .AddQueryType&lt;Query&gt;();\n</code></pre><p>The builder API lets you chain in new extension methods that can add new capabilities without the need to change the actual builder API. The builder interface is nothing more than a named access to the service collection, which lets you add named configurations to the DI that are consecutively used to create a GraphQL server.</p><pre><code class=\"language-csharp\">public interface IRequestExecutorBuilder\n{\n    /// &lt;summary&gt;\n    /// Gets the name of the schema.\n    /// &lt;/summary&gt;\n    NameString Name { get; }\n\n    /// &lt;summary&gt;\n    /// Gets the application services.\n    /// &lt;/summary&gt;\n    IServiceCollection Services { get; }\n}\n</code></pre><p>Significant here is our switch to allow multiple named schemas that can be hot-reloaded during runtime. This allows us to improve a lot of workloads like schema stitching. But we will have more on that later.</p><p>With the new configuration API, you now can chain in various configurations without the need to remember where these things were hidden.</p><pre><code class=\"language-csharp\">services\n    .AddGraphQLServer()\n    .AddQueryType(d =&gt; d.Name(&quot;Query&quot;))\n        .AddType&lt;AttendeeQueries&gt;()\n        .AddType&lt;SessionQueries&gt;()\n        .AddType&lt;SpeakerQueries&gt;()\n        .AddType&lt;TrackQueries&gt;()\n    .AddMutationType(d =&gt; d.Name(&quot;Mutation&quot;))\n        .AddType&lt;AttendeeMutations&gt;()\n        .AddType&lt;SessionMutations&gt;()\n        .AddType&lt;SpeakerMutations&gt;()\n        .AddType&lt;TrackMutations&gt;()\n    .AddSubscriptionType(d =&gt; d.Name(&quot;Subscription&quot;))\n        .AddType&lt;AttendeeSubscriptions&gt;()\n        .AddType&lt;SessionSubscriptions&gt;()\n    .AddType&lt;AttendeeType&gt;()\n    .AddType&lt;SessionType&gt;()\n    .AddType&lt;SpeakerType&gt;()\n    .AddType&lt;TrackType&gt;()\n    .AddFiltering()\n    .AddSorting()\n    .AddProjections()\n    .EnableRelaySupport()\n    .AddDataLoader&lt;AttendeeByIdDataLoader&gt;()\n    .AddDataLoader&lt;SessionByIdDataLoader&gt;()\n    .AddDataLoader&lt;SpeakerByIdDataLoader&gt;()\n    .AddDataLoader&lt;TrackByIdDataLoader&gt;()\n    .EnsureDatabaseIsCreated()\n    .AddInMemorySubscriptions()\n    .AddFileSystemQueryStorage(&quot;./persisted_queries&quot;)\n    .UsePersistedQueryPipeline();\n</code></pre><p>With the new configuration API, we also reworked the ASP.NET Core integration to use the endpoints API. It now is effortless to apply the Hot Chocolate server to a routing configuration.</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseWebSockets();\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =&gt;\n    {\n        endpoints.MapGraphQL();\n    });\n}\n</code></pre><p>With the new middleware, we dropped support for Playground and GraphiQL and have added our own GraphQL IDE Banana Cake Pop, which will be automatically added to a GraphQL route.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/1aa3e/banana-cake-pop.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:59.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACtElEQVQoz3WQS0wTURSGZ2HiAhKNJETk2QKCIjGKUqtgEWLca6kLxYULjdGk0nasoxsXujK6cGeCIiotAYuW8qisTIxgYqIrV0irAp22wPQ1ncftzD3eO0KMIpN8Of/ck/vf8x+moaq0paWp9vYpW4enq9PGHjvSypbtLGVLSkrYyopytqqygq2uqvwvpppq1lxrYs2mGrbObOIqyneZmYOHLXes7TZos3UCrZa2DrBY28BqtULj3n1Q37AH6nc3Qt0/0LPGpmZoOtAC+wmHWq30/BxTbLnovXK3H/pG3soPB8bQg4Fx9PnrNxSPx9FwMIye+UeR71XIYHBkjBBEL4eDyBcIIX9gHA2NTqLBwITifx2Ge/cfdTNF7dc439RH0KS0lkkLWMykoFAogCzlYdMP63/9EYyDyYlxB7P9hJN7PjELUjalLcZ4HIvxIEkSIGKqIgSqUX8jKyrkZRlyogiyrIAoqyApCBc0Xc/mRPD5hxwM03yBexx4B0jKanw8jklUUBRl0+F0XQcd4w0TqqoKoVDIwWxpvcw9efMe1HzGMEwQQzGfN2JrFE0zNKLTkkvrZtSY9giYaL1A+jMzMw5m69Gr3NOxD38MEwkQ0hnI5HJGdEqePJBKpSCTyYAgCMAvLsLCwgJks1nI5XKYoNPe9PS0gyk6fp3rD82CIqYLPG9Exqqi4LUoG/hB9vwl8hMLKytYFEVMHqRoxBTC4bCD2dbl5V5MfYKCnNMSyWWcTCYxibip4dJyAn9PJrBe0DDZtQFZhUaTGBPuOOnl+sgOhWQMz0eiEI1Gged5IxqNSevq6ioIFKKjkQjMz83BUiwG5HGgK6KV3gkGgw6muKGz7vT5S2dv3bxxxuVy2z0ej93pdNp7e3vtXq/X7nK5DL0O7bvcbrtrTbuJphDd3dPTU/YLQVvLXtsRFx4AAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Banana Cake Pop\" title=\"Banana Cake Pop\" src=\"https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/7842b/banana-cake-pop.png\" srcSet=\"https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/f8f3a/banana-cake-pop.png 200w,https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/6a8a8/banana-cake-pop.png 400w,https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/7842b/banana-cake-pop.png 800w,https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/5ece7/banana-cake-pop.png 1200w,https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/0d4f8/banana-cake-pop.png 1600w,https://chillicream.com/static/0e21d329f5fb3dce877d0309f28dfad8/1aa3e/banana-cake-pop.png 3094w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>To configure Banana Cake Pop or other middleware settings, you can chain in the server options with the GraphQLEndpointConventionBuilder.</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseWebSockets();\n    app.UseRouting();\n\n    app.UseEndpoints(\n        e =&gt; e.MapGraphQL().WithOptions(\n            new GraphQLServerOptions\n            {\n                Tool = { Enable = false }\n            }));\n}\n</code></pre><h1>Execution Engine</h1><p>While the new Configuration API is the first change, you will notice we changed a whole lot more underneath. One of the most significant investments we made was into our new execution engine. The new execution engine uses a new operation optimizer component to create execution plans and optimize executing requests. The first request now is a little slower since we need to essentially compile a query and then execute it. All consecutive requests can now simply execute and no longer need to interpret things like skip, include, defer, and other things.</p><p>With the new execution engine, we also introduced a new batching mechanism that is now much more efficient and abstracts the batching mechanism from DataLoader, meaning you can write your own batching functionality and integrate it. The stitching layer, for instance, does this to batch requests to the downstream services.</p><p>Apart from this, the new DataLoader API now follows the DataLoader spec version 2 and lets you inject the batch scheduler into the DataLoader. This makes it now easy to use Green Donut in your business logic. The beauty of this is that you do not need to expose any GraphQL libraries into your business layer and are able to layer your application nicely.</p><p>We also rewrote the validation layer for Hot Chocolate to make it much more correct and much faster on execution. To make the query validation more correct and ensure quality, we have ported all the <code>graphql-js</code> tests regarding validation to Hot Chocolate. While porting and integrating these tests, we found countless little issues with our implementation of field merging, for instance.</p><p>So, what do we mean with much faster execution? We put a lot of effort into reducing our memory footprint to execute more in parallel.</p><p>Let&#x27;s have a look at how Hot Chocolate 11 compares to GraphQL .NET Server 4.3.1.</p><table><thead><tr><th>Server</th><th>Benchmark</th><th align=\"right\">Time</th><th align=\"right\">Allocated</th></tr></thead><tbody><tr><td>Hot Chocolate 11</td><td>Three Fields</td><td align=\"right\">11.94</td><td align=\"right\">7.49 KB</td></tr><tr><td>GraphQL .NET</td><td>Three Fields</td><td align=\"right\">46.36</td><td align=\"right\">30.59 KB</td></tr><tr><td>Hot Chocolate 11</td><td>Small Query with Fragments</td><td align=\"right\">43.32</td><td align=\"right\">13.64 KB</td></tr><tr><td>GraphQL .NET</td><td>Small Query with Fragments</td><td align=\"right\">138.56</td><td align=\"right\">135.41 KB</td></tr><tr><td>Hot Chocolate 11</td><td>Introspection</td><td align=\"right\">750.96</td><td align=\"right\">392.31 KB</td></tr><tr><td>GraphQL .NET</td><td>Introspection</td><td align=\"right\">2277.24</td><td align=\"right\">2267.26 KB</td></tr></tbody></table><p>Hot Chocolate 11 uses a lot less memory and, on top of that, uses a lot less time to execute queries. But we also looked at other GraphQL servers and added Hot Chocolate to a variety of benchmarks.</p><p>For instance, we ran tests against the Apollo GraphQL server and other nodejs GraphQL servers.</p><table><thead><tr><th>Server</th><th align=\"right\">Requests / second</th></tr></thead><tbody><tr><td>Hot Chocolate 11</td><td align=\"right\">19983.2</td></tr><tr><td>graphyne</td><td align=\"right\">17918.4</td></tr><tr><td>express-gql</td><td align=\"right\">5931.4</td></tr><tr><td>apollo-fastify-graphql-jit</td><td align=\"right\">4046.2</td></tr><tr><td>apollo</td><td align=\"right\">2697.1</td></tr></tbody></table><p>In our throughput tests, we can see that Hot Chocolate outperforms any node-based GraphQL server. Hot Chocolate is optimized for parallel requests meaning the more CPU cores your system has, the better Hot Chocolate server performs. This also means that if you have, for instance, only one CPU core graphyne will actually perform better. But even with less parallelization, Hot Chocolate turns up in the top three ahead of Express GraphQL and Apollo GraphQL.</p><p>This said, we are not done on performance and pulled the two biggest performance features on the execution side since we could not get them done in time for the 11 release. We already have seen huge potential in improving the overall performance of the server by using source generators. Source generators let us move a lot of the logic into the build process instead of executing resolver compilation at runtime. Also, we pulled a lot of our execution plan optimizers that would rewrite the execution tree to optimize data fetching. These performance improvements will trickle in with the next dot releases and should push Hot Chocolate further.</p><h1>Relay</h1><p>We have invested a lot of time to make it even easier to create relay schemas. One of the things I often found cumbersome was to create entities that implemented the node interface. With Hot Chocolate 10.5, you could not do that with pure code-first (annotation based) and always needed to use code-first with the fluent API or schema-first. This now has changed, and it is much easier to write relay compliant schemas with any schema definition approach.</p><p>To write an entity that implements the node interface, you can now just put everything into one class.</p><pre><code class=\"language-csharp\">[Node]\npublic class Person\n{\n    public int Id { get; set; }\n\n    public string Name { get; set; }\n\n    public static async Task&lt;Person&gt; GetPersonAsync(MyDbContext context, int id)\n    {\n        // ...\n    }\n}\n</code></pre><p>We often want to have the node resolver logic in a separate class that only deals with fetching the entity by ID. Or even have multiple node resolvers co-located in the same class. This can be done by specifying the node resolver type on the node attribute.</p><pre><code class=\"language-csharp\">[Node(NodeResolverType = typeof(IPersonResolver))]\npublic class Person\n{\n    public int Id { get; set; }\n\n    public string Name { get; set; }\n}\n</code></pre><p>There are more variations and options possible to define a node type; the essence here is that it has become more natural.</p><h1>Draft Specification</h1><p>As always, we try to implement draft specifications early, and we added a couple more draft spec features with Hot Chocolate 11.</p><h2>Allow interfaces to implement other interfaces</h2><p><a href=\"https://github.com/graphql/graphql-spec/pull/373\">GraphQL Spec PR 373</a></p><p>One thing that users often requested is that interfaces could implement interfaces. With GraphQL until now, this was not possible. With the new GraphQL draft spec, we now have this capability, and we have optimized Hot Chocolate to make it very simple to apply.</p><p>The GraphQL spec states that you have to reimplement an interface on every level. This decision was made to optimize the GraphQL SDL for readability, and further show the impact of changes to an interface.</p><p>We will help you that this does not feel cumbersome and automatically add the missing re-implementations with code-first.</p><pre><code class=\"language-csharp\">public interface INode\n{\n    string Id { get; }\n}\n\npublic interface IPerson : INode\n{\n    string Name { get; }\n}\n\npublic class Person : IPerson\n{\n    public string Id { get; }\n\n    public string Name { get; }\n}\n\npublic class Query\n{\n    public IPerson GetPerson() =&gt; new Person();\n}\n\nservices\n    .AddGraphQLServer()\n    .AddQueryType&lt;Query&gt;()\n    .AddInterfaceType&lt;INode&gt;()\n</code></pre><p>This schema will translate to the following GraphQL SDL.</p><pre><code class=\"language-sdl\">schema {\n  query: Query\n}\n\ninterface INode {\n  id: String\n}\n\ninterface IPerson implements INode {\n  id: String\n  name: String\n}\n\ntype Person implements IPerson &amp; INode {\n  id: String\n  name: String\n}\n\ntype Query {\n  person: IPerson\n}\n</code></pre><h2>Custom Scalar Specification URLs</h2><p><a href=\"https://github.com/graphql/graphql-spec/pull/649\">GraphQL Spec PR 649</a></p><p>Another feature that we think will make tooling better over time is the ability to state the scalar specification. Andi Marek from graphql-java has created a new scalar specification website that, at the moment, only hosts one scalar specification for <code>DateTime</code>. Hopefully, this will grow over time. Scalars that have a specification can point to an URL of a human-readable spec. This will allow tooling to use the spec URLs as identifiers and apply then IntelliSense or other means of validation to a GraphQL IDE.</p><p>When you implement a scalar type, you can now pass on this <code>specifiedBy</code> URL.</p><pre><code class=\"language-csharp\">public class MyScalar : ScalarType\n{\n    public MyScalar()\n        : base(&quot;MyScalar&quot;)\n    {\n        SpecifiedBy = new Uri(&quot;URL&quot;);\n    }\n\n    // ...\n}\n</code></pre><h2>Defer and Stream</h2><p><a href=\"https://github.com/graphql/graphql-spec/pull/742\">GraphQL Spec PR 742</a></p><p>We also invested a lot of time in a very early feature called defer and stream. Defer, and stream allow you to de-prioritize parts of your request. This means that you essentially can tell the server to give you all the data in one go, but you mark the data that can arrive a little later.</p><pre><code class=\"language-graphql\">{\n  sessions {\n    nodes {\n      title\n      abstract\n      startTime\n      endTime\n      ... @defer {\n        speakers {\n          name\n        }\n      }\n    }\n  }\n}\n</code></pre><p>Hot Chocolate Server 11 supports defer. This feature is experimental since the spec still changes, and we will keep it up to date. We have not yet included stream, which will follow with 11.1, probably at the end of January. You do not need to specify anything in your server to use defer; it will just work. You can try out defer with Banana Cake Pop, which will show you exactly how the patches come in.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/1aa3e/banana-cake-pop-defer.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:59.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC5UlEQVQoz21STUwTQRTeg4kHSDSSEJHf8iMgEiNVahUsQox3LfUA8eBBYzQRabd1wUQP3IwevJmgiAJN5EctIMLJCNgajDfwgm2V2t0tUtrSdrczu/OcXdBE5CVf3sybt99875tlKotyjcaasu5zliZHS7OFPXWins3bn8vm5OSwhQX5bFFhAVtcVLgjDCXFbGmZgS01lLBlpQauIP9AKVN33HTP3GiBBkszaNnU0AQmcwOYzWaoOnQYKiqroeJgFZRvg1arrqmFmjojHDlqhGP1Zq3exmSbLruu9fRB7/C09LDfgx70T6Avi8tIFAQ07JlBz9yv0NDIuI7BYQ8aePlGxyDdu0cnkHvsLRoYmZTdY1PQc/9RK5PVeIMbmvKBko4p8ViUJOPrgDGCjCwBEBl2DKL+s6PQC58XFmzM3jM3ueeTXkgn1pVQmCfhMA+pdBrkDAKZkiKMASEMiqpCPJ6AaCxGL8sAopBoTwZhotJACMHc3JyNYWovcY9H3wNKJxSeF4ggCCDJ25QRoiftAln+T7WukAb4fD4bs6v+Kvfk9SxkUnGFF7YIJUnv1JoIJfsDRVH+1lQNqg4tVIwVmP/40cbsPnmde+qZ3ySkCkVRhCgdTYxEQBBEXZFGoI2knaXSEiRjcUgnU6DQOlYUgqkfmkUfZmdtTNbpDq5v3AtyMobDm4RkbT1OQgE/CQUDBGOsjUSoOsLzPEmmJSIlU/TxkkRCKkFY0c4ppQJer9fG7GlxcS+mFgBLG4oYWSW/ViNkjX648uM7iUZEkomtE9qtE1M7SErOEFWSCEpsEBnT9yawRQjUw082Zt9ZF9dLPYxGwuSbPwDBQABWKJaXFsH/dYmu/aD5qsHv9wP9E0BYCYEQDAIvrMJPPgJhmkNhEd5Nz9iY7Mrm8vPtVy523XZe6Oy0Wzvtdmv3nW7r3a4uq+NWh9XF0exw6OA4zuqg53an0+qga9ZhtzpZ+1Z2tLa3t+X9Bo0OzGkYWqAPAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Banana Cake Pop\" title=\"Banana Cake Pop\" src=\"https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/7842b/banana-cake-pop-defer.png\" srcSet=\"https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/f8f3a/banana-cake-pop-defer.png 200w,https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/6a8a8/banana-cake-pop-defer.png 400w,https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/7842b/banana-cake-pop-defer.png 800w,https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/5ece7/banana-cake-pop-defer.png 1200w,https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/0d4f8/banana-cake-pop-defer.png 1600w,https://chillicream.com/static/0791abb3f6ac1b38c47c05de22898de3/1aa3e/banana-cake-pop-defer.png 3094w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><h1>Data Integration</h1><p>I know a lot of you love the data integration API, aka filtering. We completely reinvented this API and created a new package called <code>HotChocolate.Data</code>. This new package contains the base for automatic database mapping, filtering, sorting, and projections.</p><p>We actually started out in 11 to make the filtering introduced in version 10 better. But people soon chimed in and wanted to do more and wanted to <strong>NOT</strong> be dependant on <code>IQueryable</code>. So we create a new API that lets you fully control how filters, sorting, and projections are handled. You can integrate new providers like NeoJ4, MongoDB, or even spatial filter\nsupport.</p><pre><code class=\"language-csharp\">public static class FilterConventionDescriptorMongoDbExtensions\n{\n    public static IFilterConventionDescriptor UseMongoDbProvider(\n        this IFilterConventionDescriptor descriptor) =&gt;\n        descriptor.Provider(new MongoDbFilterProvider(x =&gt; x.AddDefaultMongoHandler()));\n\n    public static IFilterProviderDescriptor&lt;MongoDbFilterVisitorContext&gt; AddDefaultMongoHandler(\n        this IFilterProviderDescriptor&lt;MongoDbFilterVisitorContext&gt; descriptor)\n    {\n        descriptor.AddFieldHandler&lt;MongoDbEqualsOperationHandler&gt;();\n        descriptor.AddFieldHandler&lt;MongoDbNotEqualsOperationHandler&gt;();\n\n        descriptor.AddFieldHandler&lt;MongoDbInOperationHandler&gt;();\n        descriptor.AddFieldHandler&lt;MongoDbNotInOperationHandler&gt;();\n\n        // shortened for brevity\n\n        return descriptor;\n    }\n}\n</code></pre><p>What does this actually mean?</p><p>We have ported the old filtering to 11, so you can use that and essentially have no breaking change. We are no longer developing this any further and are also no longer investing in this component&#x27;s bug fixing.</p><p>This means that you essentially will need to upgrade to the new <code>HotChocolate.Data</code> package. The issue with that is that your graph filter structure will change. Meaning a breaking change to your schema. You can, however, upgrade slowly and use both APIs side by side.</p><p>You can read more about the journey on our data integration API in Pascal&#x27;s blog post <a href=\"/blog/2020/11/18/new-filtering-api\">here</a>.</p><h2>Entity Framework</h2><p>We know that many of you love Entity Framework and that it was quite painful to use Entity Framework with Hot Chocolate. We refined usage of Entity Framework with 10.5 but had to use internal APIs of EF to make it efficient. Hot Chocolate 11 introduces a new package <code>HotChocolate.Data.EntityFramework</code>, which integrates seamlessly with the data integration API.</p><p>We have a great example with Entity Framework right here:</p><p><a href=\"https://github.com/ChilliCream/graphql-workshop\">GraphQL Workshop</a></p><h2>Spatial Filtering</h2><p>Apart from the refactoring of the data integration API, we introduced our new GeoJSON based spatial types. These spatial types are not just simple types but can also be used to add spatial filter capabilities to our data integration API.</p><pre><code class=\"language-graphql\">{\n  pubs(\n    where: {\n      location: { within: { geometry: { type: Point, coordinates: [1, 1] } } }\n    }\n  ) {\n    id\n    name\n    location\n  }\n}\n</code></pre><p>Which translates to:</p><pre><code class=\"language-sql\"> SELECT c.&quot;Id&quot;, c.&quot;Name&quot;, c.&quot;Area&quot;\n FROM &quot;Counties&quot; AS c\n WHERE ST_Within(c.&quot;Area&quot;, @__p_0)\n</code></pre><p>The spatial filters use-case has driven us to reinvent the data integration API in the first place. This now very easily allows you to expose complex spatial filters to your GraphQL consumers.</p><p>Let me thank Steve and Pascal for all their work on this feature.</p><p>However, we are still developing spatial further, and this feature essentially is still experimental. Meaning, it might change in the next dot releases.</p><h2>Support for more providers</h2><p>We are currently working on more providers for the data integration API like MongoDB native, Neo4J, and Elastic Search, which we will drop with the next dot releases.</p><p>The furthest along is our new MongoDB integration. Of course, MongoDB works already through <code>IQueryable</code>, but with <code>IQueryable</code> performance is sometimes an issue since the translation from <code>IQueryable</code> to the native Mongo query is not optimal in all cases. With the new Mongo provider, we use the BSON API to craft a native query that you can also intercept and further modify before it is sent to the database.</p><p>We expect to release the MongoDB provider with 11.1 in January.</p><h1>Schema Stitching</h1><p>Schema got a nice upgrade for version 11, although a lot of features were moved to 11.1. We originally wanted to redo the whole stitching execution on top of the new execution engine. In the end, we essentially moved the old stitching engine on top of the new execution engine and integrated the old stitching engine into the new configuration API. This alone already will give you a big upgrade in functionality and usability.</p><p>The first thing to note with schema stitching is that it completely integrates with a standard schema. No more is there a separate stitching builder that makes it challenging to add customizations.</p><pre><code class=\"language-graphql\">services\n    .AddGraphQLServer()\n    .AddQueryType(d =&gt; d.Name(&quot;Query&quot;))\n    .AddRemoteSchema(Accounts)\n    .AddRemoteSchema(Inventory)\n    .AddRemoteSchema(Products)\n    .AddRemoteSchema(Reviews);\n</code></pre><p>Essentially now you just merge in types into your schema from anywhere, and you are still able to create local types that are merged with remote types. This gives a lot of control and flexibility to you. With that, any schema could also be a gateway.</p><pre><code class=\"language-graphql\">services\n    .AddGraphQLServer()\n    // adds a local query type\n    .AddQueryType&lt;Query&gt;()\n    // and merges that with the incoming schemas\n    .AddRemoteSchema(Accounts)\n    .AddRemoteSchema(Inventory)\n    .AddRemoteSchema(Products)\n    .AddRemoteSchema(Reviews);\n</code></pre><h2>Federated Schemas</h2><p>I mentioned in the beginning that we can now hot-reload schemas, which we designed specifically for schema stitching so that you could distribute the schema configuration and use a federated approach to schema stitching.</p><p>While there are various ways now to do federated schemas, we internally use one backed by Redis. Essentially, a downstream service can push to the gateway its local configuration, and the gateway will start phasing out the old schema and phasing in the new schema without any disruption every time a configuration changes.</p><p>The gateway will further store schema configurations on Redis so that even if there are downstream services offline, we can always create a schema, and only on execution might there be errors for affected parts of the schema. This really makes a federated schema more resilient.</p><pre><code class=\"language-csharp\">services\n    .AddGraphQLServer()\n    .AddQueryType(d =&gt; d.Name(&quot;Query&quot;))\n    .AddRemoteSchemasFromRedis(&quot;Demo&quot;, sp =&gt; sp.GetRequiredService&lt;ConnectionMultiplexer&gt;());\n</code></pre><p>We have created some examples that show the various ways to set up schema stitching, which can be found <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/misc/Stitching\">here</a>.</p><p>But as I said in the beginning, there is a lot more coming with the next dot updates. Like GraphQL over gRPC to improve efficiency between the gateway and the downstream services. Moreover, we are bringing in subscription stitching and full integration with the new execution engine. Furthermore, we will introduce a new fetch directive that will bring much more flexibility to integrating GraphQL schemas and other data sources.</p><h1>Extensibility</h1><p>With Hot Chocolate 11, we have invested in adding extensibility points, where our customers and partners who want to extend Hot Chocolate can do so easily and safely. When customizations are created, the creator can be assured that the integrity of Hot Chocolate will be maintained in the future and those extensions will continue to work as designed through minor and major releases of Hot Chocolate. Our existing extensions, <code>HotChocolate.Data</code> and <code>HotChocolate.Stitching</code> already take advantage of this new extensibility feature.</p><p>We essentially created a new interception API that can hook into the type initialization to completely rewrite an inferred schema. It can create new types when it finds an attribute or branch of types and essentially creates versions of the same graph. It gives you a powerful API that visits each type during its various initialization stages and lets you change the APIs.</p><p>Also, it allows you to modify the underlying type definitions rather than being constrained by the fluent API. These extension APIs are not meant for the standard developer creating a schema but for people who want to write powerful, reusable components like <code>HotChocolate.Data</code>. We also rewrote a lot of our core components to use this new API, like the introspection.</p><pre><code class=\"language-csharp\">server\n    .AddGraphQLServer()\n    ...\n    .AddTypeInterceptor&lt;IntrospectionTypeInterceptor&gt;();\n\ninternal sealed class IntrospectionTypeInterceptor : TypeInterceptor\n{\n    public override void OnBeforeCompleteType(\n        ITypeCompletionContext completionContext,\n        DefinitionBase definition,\n        IDictionary&lt;string, object&gt; contextData)\n    {\n        if (definition is ObjectTypeDefinition objectTypeDefinition)\n        {\n            var position = 0;\n            IDescriptorContext context = completionContext.DescriptorContext;\n\n            if (completionContext.IsQueryType ?? false)\n            {\n                objectTypeDefinition.Fields.Insert(position++, CreateSchemaField(context));\n                objectTypeDefinition.Fields.Insert(position++, CreateTypeField(context));\n            }\n\n            objectTypeDefinition.Fields.Insert(position, CreateTypeNameField(context));\n        }\n    }\n}\n</code></pre><p>We will soon have a follow-up post on writing extensions for Hot Chocolate to drill into what you can do.</p><h1>Strawberry Shake</h1><p>The one thing missing from this launch is Strawberry Shake, our GraphQL client. We decided in August to pause development for Strawberry Shake in order to focus on the server. Many features in Strawberry Shake depended on Hot Chocolate to bring in new features like defer that really will make Strawberry Shake shine. With this decision, we were able to focus on the server and make it great. We essentially broke the 11 development into two parts. We will start next week to put resources again behind Strawberry Shake and hope to get it done by the end of January.</p><h1>General Outlook</h1><p>Where are we going from here? We now essentially are a team of four people, Rafael, Pascal, Fred, and myself. We plan to start focusing for the next three months on three components.</p><p>Strawberry Shake will become Freds and my immediate focus, so expect our GraphQL client to get real attention and expect it to get the same attention for detail that made Hot Chocolate your beloved GraphQL server. We think that the client space at the moment does not exist in .NET, and we want to change that. There are a lot of opportunities to bring something unique. We have done a lot of research into things like Relay and Apollo client and think that we can reinvent how you interact with data in Xamarin and Blazor applications.</p><p>Apart from Strawberry Shake, we will start moving in the missing schema stitching features. The new stitching engine can not only do subscription stitching but also is able to merge the Hot Chocolate stitching approach with the Apollo Federation approach. You will be able to have Apollo Federation protocol downstream services as well as Hot Chocolate Stitching protocol downstream servers. The gateway can mix and match them, not forcing you to choose. As you have seen with the general execution engine, stitching will become very fast, and we will publish benchmarks soon.</p><p>In general, expect a lot more performance improvements to trickle in over the next dot releases.</p><p>These changes are more iterative, where we complete components and get better. We will also start on a new component that will become a big leap for the whole platform. Rafael and Pascal will focus on this new chapter of ChilliCream and we will start talking about this soon.</p><h1>Community</h1><p>The great thing about Hot Chocolate is the people. Every day, I think the best thing we did was to create this slack channel where anybody could join. The slack channel has become the space where the community can congregate and help each other find a solution to a problem.</p><p>We internally talked about this great family and how to push this further and help this community grow. We will soon start with our ChilliCream user group, where users from the community can present solutions to their issues or present components that they have build around Hot Chocolate. But we think that we will even go beyond that and ask people from the greater GraphQL community to talk to us and give us fresh ideas and new takes on GraphQL.</p><p>Last but not least, let me invite you to our launch party on Wednesday and celebrate with us this amazing community and the next chapter of Hot Chocolate.</p><p><a href=\"https://www.meetup.com/ChilliCream-User-Group/events/274656703/\">Hot Chocolate 11 Launch Party</a></p>",
            "url": "https://chillicream.com/blog/2020/11/23/hot-chocolate-11",
            "title": "Welcome Hot Chocolate 11",
            "summary": "Today we are releasing Hot Chocolate server 11. We started work on this version about 1 1/2 years ago. We occasionally took a break from…",
            "image": "https://chillicream.com/static/b697613550a24611af06e8dad4b834e3/0514f/hot-chocolate-11-banner.png",
            "date_modified": "2020-11-23T00:00:00.000Z",
            "date_published": "2020-11-23T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2020/11/18/new-filtering-api",
            "content_html": "<p>With version 11, we release a complete rewrite of filtering, sorting, and selections. With our initial release a few versions back, we decided to use a similar syntax as Prisma did. Initially, this looked like a very intuitive way of declaring filters. We already shipped some extensions in preview releases of version 11, like object filters, list filters, etc.</p><p>We started investigating into opening up the API for users who want to provide their filters or write their database providers for Hot Chocolate. Quickly we realized that the API was not good enough for a public release and, even worse, the underlying GraphQL syntax was not ideal to use.</p><p>This was a huge setback for us, but we still went back to the drawing board and made a complete redesign of it. We looked at many different implementations of similar features, and combined with the experience we made; we settled on a similar approach to Hasura or Postgraphile.</p><p>The main issue with the filters released with version 10 is the strict binding of field and operation. The discussion and a detailed description of the problem we faced can be followed in this <a href=\"https://github.com/ChilliCream/hotchocolate/issues/2044\">Issue on GitHub</a></p><p>Here is a quick summary:</p><p>This approach works great with scalar filters.</p><pre><code class=\"language-graphql\">where: {\n    foo_contains: “bar”\n}\n</code></pre><p>We bundled the field and the operation together into an easy to understand and straight forward GraphQL field.</p><p>Object filters would add another level of nesting:</p><pre><code class=\"language-graphql\">where: {\n    foo: {\n        bar_contains:”bar”\n    }\n}\n</code></pre><p>For array filters, we came up with a mixture of nesting and bundling. With list filters, the problems already begin to start. It is already required to have helper (<code>el_XXX</code>) syntax to access the elements of a list:</p><pre><code class=\"language-graphql\">where: {\n    foo_some: {\n        el_gt:4\n    }\n}\n</code></pre><p>As soon as we dived deeper into possible extensions, the problems became more severe, and the API became more inconsistent. A good example of this issue is when we want to filter by the length of a string. We could filter by <code>foo_length_gt:4</code> or <code>foo_length: { is_gt: 4}</code> or even <code>foo: { length: { is_gt:4 } }</code>. All of these approaches would follow the style guide. The first would be like we define filters for the field, the second similar to the list filters, and the last one would be like the object filters.</p><h1>The New Filtering</h1><p>With the new filtering API, there is a fundamental change. Operations and fields are no longer bundled together into one GraphQL field.</p><p>Here is a quick overview of the examples listed above:</p><p>Scalar filters:</p><pre><code class=\"language-graphql\">where: {\n    foo: {\n        contains: “bar”\n    }\n}\n</code></pre><p>Object filters:</p><pre><code class=\"language-graphql\">where: {\n    foo: {\n        bar {\n            contains: “bar”\n        }\n    }\n}\n</code></pre><p>List filters:</p><pre><code class=\"language-graphql\">where: {\n    foo: {\n        some: {\n            gt: 4\n        }\n    }\n}\n</code></pre><p>As the API now is based on nesting, every combination of field and operation feels a lot more natural. When you like to filter by the length of a string, the resulting API looks seamless:</p><pre><code class=\"language-graphql\">where: {\n    foo: {\n        length: {\n            gt: 4\n        }\n    }\n}\n</code></pre><h1>THIS IS BREAKING MY API!</h1><p>We know. We had a long discussion about this. We feel confident that this new approach is the right way to go, and it is designed to stay. The 10.X.X filters are still available in version 11. They will be deprecated, though, and will be removed in version 12.</p><h1>The Data Package</h1><p>With version 11, we introduce a new package for Hot Chocolate. We created a new package called <code>HotChocolate.Data</code>. This package contains <code>HotChocolate.Data.Filtering</code>, <code>HotChocolate.Data.Sorting</code> and <code>HotChocolate.Data.Projections</code>.</p><h1>Migrating from 10 to 11</h1><p>We could not avoid conflicts in type names between the old and the new filtering. You can use static imports or fully qualified type names to have the old and the new filtering API in the same file.</p><p>If you have full control over the front end, the easiest way to migrate is to replace the old filtering with the new one and make the necessary changes.</p><p>If this is not an option for you, you will have to declare new fields and deprecate the old ones once they are no longer used. You may even use the filters on the same fields, but you will end up with conflicting argument names.</p><h1>Getting started</h1><p>You first need to add the new <code>HotChocolate.Data</code> package to the project.</p><p>It is also required to register filtering on the schema builder:</p><pre><code class=\"language-csharp\">public void ConfigureServcies(IServiceCollection services) {\n    services.AddGraphQLServer()\n        .AddQueryType&lt;Query&gt;()\n        .AddFiltering();\n}\n</code></pre><p>You are now all set and ready to use the filters. For a pure code first approach, you can use the attribute <code>[UseFiltering]</code>, and for code first, you can use the <code>UseFiltering()</code> extension method.</p><pre><code class=\"language-csharp\">// pure code first\npublic class Query {\n    [UseFiltering]\n    public IQueryable&lt;Foo&gt; Foos([Service]DbContext context) =&gt; context.Foos;\n}\n\n//code first\npublic class Query : ObjectType {\n    protected override void Configure(IObjectTypeDescriptor descriptor) {\n        descriptor\n            .Field&lt;Resolver&gt;(x =&gt; x.Foos(default!))\n            .UseFiltering();\n    }\n\n    public class Resolver {\n        public IQueryable&lt;Foo&gt; Foos([Service]DbContext context) =&gt; context.Foos;\n    }\n}\n</code></pre><h1>How does it work?</h1><p>The old filtering was bundling a field and operation together. With the new filtering, this is now separated. The concept of field and operation still exists, though a little different. A field is always used for navigation. You can think of it as a selector. In code first, a field represents a property of a class. An operation is always an action in the context of a field. Semantically you can look at it as a function. This is often a compare operation, like equals or greater than, but it can also be more arbitrary. In spatial data, many functions can be translated to database queries, like <code>ConvexHull()</code> or <code>Distance(Geometry g)</code>. Filtering on spatial data is something we plan to support soon. Operations are identified by an integer, which is called the operation ID.</p><p>In most cases, a filter type either only contains fields or only operations, but it is in no way restricted to that. A filter type can contain both. This can be useful to provide the necessary metadata. Let&#x27;s continue the example <code>Distance(Geometry g)</code> from above. This function has a parameter <code>g</code>. To calculate the distance between two points, the consumer needs to provide one point. The function then returns the distance between these two points. In GraphQL, this now can be combined into one input type:</p><pre><code class=\"language-graphql\">input HouseFilterInput {\n    position: PointFilterInput\n}\n\ninput PointFilterInput {\n    distanceTo: DistanceToFilterInput;\n}\n\ninput DistanceToFilterInput {\n    &quot;&quot;&quot;The other point where the distance is calculated to&quot;&quot;&quot;\n    other: GeometryFilterInput!\n    eq: Float\n    neq: Float\n    gt: Float\n    ....\n}\n</code></pre><p>The new version of filtering does not only have a new look and feel at the API level but also comes with lots of changes to the Hot Chocolate core. The data package is now completely separated from the core, and no internal APIs are used. Like most of the things in Hot Chocolate, filtering can roughly be broken down into two parts. Schema building and execution. Something we focused on is the new conventions. The goal was to make it easier for users to extend the capabilities of filtering. It is now a lot easier to create custom filters and providers to add new functionality. Both schema building and execution are configurable with conventions.</p><h1>Schema Building</h1><p>Filtering has dedicated input types. <code>FilterInputType</code> and <code>FilterInputType&lt;T&gt;</code> are extensions of the normal <code>InputObjectType</code>. Both filter input types have a similar interface to the normal input type. In addition to <code>Name</code>, <code>Description</code>, <code>Directive</code>, there are a couple of specific descriptors to describe filter capabilities. You can specify fields and operations. There is also <code>AllowOr</code> and <code>AllowAnd</code>. These two add the special fields needed for these operations. The <code>FilterInputType</code> uses the convention for naming and inference of properties. Like the scalar registration on the schema builder, operation types can be bound on the filter convention.</p><h1>Execution</h1><p>To map an incoming GraphQL filter query to the database, Hot Chocolate needs to know how to handle fields and operations. We initially started by having a lookup table. The filter middleware would access this lookup table and search for a matching handler. Since we did a lot of unnecessary work on runtime, we redesigned this to do more of this work at configuration time. During schema initialization, we annotate the matching handler directly from the convention onto the field. For this, we use a new concept call type interceptors. This comes with a few benefits. Firstly, we know during schema creation if all required handlers are registered. In case we do not find a matching handler, we can now fail early and tell the developer what is missing. Secondly, we do not have to do runtime lookups. All handlers are now directly stored on the fields and are available on visitation. We introduced a new concept called type scoping to use more than one filter convention, e.g., MongoDB and SqlServer.</p><h2>Type Interceptor</h2><p>Type interceptors are one of the new shiny features of version 11. To create an interceptor, you have to extend the class <code>TypeInterceptor</code> and register it on the schema builder. You can hook into the schema initialization process and make changes across all types or even introduce new once while rewriting the schema. Countless new possibilities come with these new type interceptors. As an example, use-case, we looked at feature flags. Feature flags can be useful in services that are tenant-based. You may want to hide parts of an API for a specific tenant.</p><p>The simplest example might be the following one:</p><blockquote><p>You have an API with two endpoints. One endpoint is for all users of the website (/graphql). The other endpoint is only accessible by administrators (/admin/graphql). The structure of the APIs is the same, the administrators just have access to more fields and mutations.</p></blockquote><p>In previous versions, you would have to create two separate type hierarchies with different types. One for normal users and one for administrators. This would bloat the codebase a lot. With type interceptors and <a href=\"https://chillicream.github.io/hotchocolate/blog/2020/07/16/version-11#configuration-api\">the new schema creation api</a> this is a lot cleaner.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n            .AddTypeInterceptor&lt;RemoveAdminFieldInterceptor&gt;()\n        .AddGraphQLServer(&quot;admin&quot;)\n            .AddQueryType&lt;Query&gt;();\n}\n</code></pre><pre><code class=\"language-csharp\">public class RemoveAdminFieldInterceptor : TypeInterceptor\n{\n    public override void OnAfterInitialize(\n        ITypeDiscoveryContext discoveryContext,\n        DefinitionBase definition,\n        IDictionary&lt;string, object&gt; contextData)\n    {\n\n        if (definition is ObjectTypeDefinition def)\n        {\n            var fields = (IList&lt;ObjectFieldDefinition&gt;)def.Fields;\n            for (var i = fields.Count; i &gt; 0; i--)\n            {\n                if (fields[i].ContextData.ContainsKey(&quot;admin&quot;))\n                {\n                    fields.RemoveAt(i);\n                }\n            }\n        }\n    }\n}\n\npublic static class ObjectFieldDescriptorExtensions\n{\n    public static IObjectFieldDescriptor IsAdmin(this IObjectFieldDescriptor descriptor)\n    {\n        descriptor.Directive(&quot;IsAdmin&quot;);\n        return descriptor;\n    }\n}\n\npublic class ExampleObjectType : ObjectType&lt;Foo&gt; {\n    protected override void Configure(IObjectTypeDescriptor&lt;Foo&gt; descriptor){\n        descriptor.Field(x =&gt; x.AvaiableForAll);\n        descriptor.Field(x =&gt; x.OnlyForAdmins).IsAdmin();\n    }\n}\n</code></pre><h2>Scoping</h2><p>With this release, we introduce a concept called schema scoping. As we write handlers from the convention directly on to the fields, we would limit filtering to just one convention. In case we need two conventions we need two fields and therefore two different types. Schema scoping makes it possible to branch of a type hierarchy and create multiple types from the same definition and then later even join the two branches back together. This feature works on the type reference level. Type references now have a scope that can change the type reference identity.\nScoping only really makes sense in combination with a type interceptor. This interceptor picks up a scoped type and then scopes all its dependencies. The type interceptor also has to rename scoped types to avoid name collisions.\nFiltering does the same. In case there is only one filter convention registered, you will not see a difference. As soon as you have multiple conventions registered the name of the convention is added to the type name.</p><h2>Conventions</h2><p>Conventions will be the configuration interface for extensions on top of the Hot Chocolate core. In version 11 the convention API has been extended. We introduce the named conventions in this release. This way multiple conventions of the same type can be registered on the Schema.\nYou may have a filter convention for MongoDB and a filter convention for SqlServer.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n            // this will be the default convention as no name is specified\n            .AddConvention&lt;IFilterConvention, MongoFilterConvention&gt;()\n            .AddConvention&lt;IFilterConvention, FilterConvention&gt;(&quot;SqlServer&quot;)\n            .AddFiltering();\n}\n</code></pre><p>You can configure the convention when you declare filtering.</p><pre><code class=\"language-csharp\">// pure code first\npublic class Query {\n    [UseFiltering(&quot;SqlServer&quot;)]\n    public IQueryable&lt;Foo&gt; Foos([Service]DbContext context) =&gt; context.Foos;\n}\n\n//code first\npublic class Query : ObjectType {\n    protected override void Configure(IObjectTypeDescriptor descriptor) {\n        descriptor\n            .Field&lt;Resolver&gt;(x =&gt; x.Foos(default!))\n            .UseFiltering(&quot;SqlServer&quot;);\n    }\n\n    public class Resolver {\n        public IQueryable&lt;Foo&gt; Foos([Service]DbContext context) =&gt; context.Foos;\n    }\n}\n</code></pre><h2>What&#x27;s next?</h2><p>The data package is designed for extensibility. There are a few extensions that we will work on. e.g. filtering for spatial data and a MongoDB provider.\nWe will as well invest time into documentation and have examples on how to create your own extensions.\nThere are too many databases to create providers for all of them out of the box. We encourage you, the community, to contribute the extensions you need.\nIf you are interested, reach out to us in slack in the #contributors channel. We will help you along!</p>",
            "url": "https://chillicream.com/blog/2020/11/18/new-filtering-api",
            "title": "The new Filtering API",
            "summary": "With version 11, we release a complete rewrite of filtering, sorting, and selections. With our initial release a few versions back, we…",
            "image": "https://chillicream.com/static/2007ecd8898c33dde82a3c096cb9e071/0514f/hotchocolate-new-filtering-api-banner.png",
            "date_modified": "2020-11-18T00:00:00.000Z",
            "date_published": "2020-11-18T00:00:00.000Z",
            "author": {
                "name": "Pascal Senn",
                "url": "https://github.com/pascal_senn"
            }
        },
        {
            "id": "/blog/2020/07/16/version-11",
            "content_html": "<p>When we at ChilliCream talked the other day, we reflected on the progress on version 11, where we are at this point, and how we got there. We are now working for almost one year on version 11 and will probably need a couple more months to polish it and get all the features in. When talked about this, we reflected that the actual version 11 was perhaps the 10.3 release when all the pure code-first goodness came.</p><p>With version 11, we are re-envisioning what we want Hot Chocolate to be. How we want the API to feel and how extensibility works. We have looked at the things that are difficult for users to understand and made these better accessible. We also looked at how we can take things to the next level with a new execution engine that will support execution plans.</p><h2>Developer Preview</h2><p>Today we are releasing a first developer preview of version 11 with our new configuration API. We call this a developer preview to make it clear that this should not be used in production. This preview is missing a lot of components included in version 10.x like filtering, schema stitching, and many others. As we go forward, we will slowly integrate these missing components and refine the new APIs further.</p><p>In order to get started with the developer preview first create a new ASP.NET Core project.</p><pre><code class=\"language-bash\">dotnet new web -n Demo\n</code></pre><p>Next, add the ASP.NET Core server package.</p><pre><code class=\"language-bash\">cd Demo\ndotnet add package HotChocolate.AspNetCore --version 11.0.0-dev.1\n</code></pre><p><a href=\"https://www.nuget.org/packages/HotChocolate.AspNetCore/11.0.0-dev.1\">Hot Chocolate - 11.0.0-dev.1</a></p><h2>Configuration API</h2><p>OK, after all these disclaimers, let us get into some code and talk features.</p><p>The first feature that I want to walk you through is the one that everybody will have to use to set up their GraphQL server, and it is also the first breaking change compared to version 11. When setting up a GraphQL server, we start with an ASP.NET Core web project. Our main configuration is located in the <code>Startup.cs</code>.</p><p>Before we look at how we do it, version 11, let us see how we usually would start in version 10.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services.AddGraphQL(sp =&gt;\n        SchemaBuilder.New()\n            .AddQueryType&lt;Query&gt;());\n}\n</code></pre><p>The code looks nice and simple. Also, the schema builder is a great API that lets us chain configuration. The main issue that we found with this or where we saw that people had problems was when schema stitching came into play or when you wanted to configure request services or change the execution pipeline and so on. Whenever it got a little more complicated, and we had to add more services and integrate other things that were not available on the <code>SchemaBuilder</code>, it got complicated. The pity here is also that the <code>SchemaBuilder</code> is difficult to extend. This means that components like schema stitching cannot easily add an extension method that brings new configuration functionality to the <code>SchemaBuilder</code>.</p><p>After long nights we came up with a new approach that brings everything together into one API that is very easy to extend.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;();\n}\n</code></pre><p>This little example does not look so much different, but the new API can do a lot more.</p><p>First, when in a server context like ASP.NET Core or Azure Functions, we now have this new <code>AddGraphQLServer()</code> method that sets up a new schema and executor with additional services the server needs. This API also does not allow just one schema but multiple.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n        .AddGraphQLServer(&quot;internal&quot;)\n            .AddQueryType&lt;Query&gt;()\n            .AddTypeExtension&lt;InternalQueryExtension&gt;();\n}\n</code></pre><p>The above code sets up two schemas. One is our default schema and adds a <code>Query</code> type. The other schema is called <code>internal</code> and adds the same <code>Query</code> type, and extends the <code>Query</code> type with some internal queries.</p><p>I can put each of these schemas on a different route and for that, we also now support Microsoft`s new routing API.</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =&gt;\n    {\n        endpoints.MapGraphQL();\n        endpoints.MapGraphQL(&quot;/internal&quot;, schemaName: &quot;internal&quot;);\n    });\n}\n</code></pre><p>The new configuration API, in combination with Microsoft`s new routing, makes it easy to map various schemas to various routes and secure and limit them as one pleases.</p><p>But there is even more to that. Since we also have some new schema stitching features in mind that will use the unique capabilities of this API. The new configuration API allows to hot reload schema configurations. Meaning you can push schema configurations to a running server. We will have more on this with the next few previews.</p><p>Another part that I mentioned is that we can more seamlessly configure a schema. If we wanted, for instance, to add apollo tracing support to our internal schema but not the default schema we can do that now with one line of code.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n        .AddGraphQLServer(&quot;internal&quot;)\n            .AddQueryType&lt;Query&gt;()\n            .AddTypeExtension&lt;InternalQueryExtension&gt;()\n            .AddApolloTracing();\n}\n</code></pre><p>Having configuration bound to specific schemas also means that the performance impact from components like apollo tracing effects only the schema it is applied to. We could also add this globally by adding apollo tracing to the service collection instead of the request builder. In this case, apollo tracing would be applied to all schemas.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddApolloTracing()\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n        .AddGraphQLServer(&quot;internal&quot;)\n            .AddQueryType&lt;Query&gt;()\n            .AddTypeExtension&lt;InternalQueryExtension&gt;();\n}\n</code></pre><p>We are still bringing more APIs over to the new configuration API, and it will take us some time to have everything in here.</p><h2>Subscriptions</h2><p>Another area that is now super simple to set up is subscriptions. To use in-memory subscriptions, we configure our schema like the following.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer()\n            .AddQueryType&lt;Query&gt;()\n            .AddMutationType&lt;Mutation&gt;()\n            .AddSubscriptionType&lt;Subscription&gt;()\n            .AddInMemorySubscriptions();\n}\n</code></pre><p>Again, I can have in-memory subscriptions on one schema and Redis subscriptions on another.</p><p>Next, we need to define our <code>Mutation</code> type to trigger subscriptions whenever something happens on our schema.</p><pre><code class=\"language-csharp\">public class Mutation\n{\n    public string SendMessage(\n        string userId\n        string message,\n        [Service] ITopicEventSender eventSender)\n    {\n        eventSender.SendAsync(userId, message);\n        return message;\n    }\n}\n</code></pre><p>In our example, we have a mutation that can send a text message to a user represented by the user API. To send a message to our subscription bus, we use the <code>userId</code> argument as a topic and the <code>message</code> argument as the payload of our subscription event. We also injected <code>ITopicEventSender</code>, which allows us to send events to our internal event stream. Events are topic-based, and a subscription can subscribe to a topic.</p><p>From a GraphQL standpoint, we would like to subscribe to a specific user to receive the messages for that user.</p><pre><code class=\"language-graphql\">subscription onMessage {\n  onMessage(userId: &quot;123&quot;);\n}\n</code></pre><p>This subscription will then pass down to us the message text for user <code>123</code> whenever the mutation is invoked with the userId <code>123</code>.</p><p>Let us have a look at how we would create our subscription type for that.</p><pre><code class=\"language-csharp\">public class Subscription\n{\n    [Subscribe]\n    public string OnMessage(\n        [Topic] string userId,\n        [EventMessage] string message) =&gt;\n        message;\n}\n</code></pre><p>If you look at the code above you, do not see any specific code that subscribes to the event system itself. We added an argument <code>userId</code> and annotated it to be our topic. The topic argument tells our system what events we would like to receive. Next, we added another argument <code>message</code>, which we annotated as our event message or payload. The <code>message</code> argument is where the system shall inject us the payload of the events whenever our subscription resolver is invoked.</p><p>There are many more variants with the new subscriptions, but I will cover that in a later blog post that only looks at subscriptions and what we can do with them.</p><h2>Extensibility</h2><p>One of our most significant investments was making the type system even more flexible to allow more complex features. We want to allow for very complex features to become fully transparent. Meaning, features like relay support should not dictate how you build your types. You should not need to handle id serialization or things like that. The system should understand your types and rewrite them into what you want them to be.</p><p>To this, there is an even better example. With version 11, we want to bring schema-first or SDL-first up to par with code-first. In SDL-first integrating paging is quite tedious at the moment, since you have to write all the paging and connection types and so forth. But if we could have a feature that can rewrite a schema, we could let people specify a schema like the following.</p><pre><code class=\"language-sdl\">type Query {\n  users: [User] @paging\n}\n\ntype User {\n  # removed for brevity\n}\n</code></pre><p>The configuration would take this initial schema and rewrite it to the following schema that includes all those types necessary for relay pagination.</p><pre><code class=\"language-sdl\">type Query {\n  users(first: Int, last: Int, after: String, before: String): [UserConnection]\n}\n\ntype UserConnection {\n  pageInfo: PageInfo\n  edges: [User]\n}\n\ntype PageInfo {\n  # removed for brevity\n}\n\ntype User {\n  # removed for brevity\n}\n</code></pre><p>To allow cross-cutting features like this, we are now allowing to intercept type configurations and rewrite them.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer(&quot;hello&quot;)\n            .AddQueryType(d =&gt; d\n                .Name(&quot;Query&quot;)\n                .Field(&quot;hello&quot;)\n                .Resolver(&quot;world&quot;))\n            .OnBeforeCompleteType&lt;ObjectTypeDefinition&gt;(\n                (context, definition, contextData) =&gt;\n                {\n                    if(definition.Name.Equals(&quot;Query&quot;))\n                    {\n                        ObjectTypeDescriptor.From(context.DescriptorContext, definition)\n                            .Field(&quot;foo&quot;)\n                            .Type&lt;StringType&gt;()\n                            .Resolver(resolverContext =&gt; &quot;say hello&quot;);\n                    }\n                });\n}\n</code></pre><p>In the above example, I am intercepting the configuration of the <code>Query</code> type and add a simple foo field to it. This feature allows for so much more since you can write very sophisticated interceptors that scope types and branch them into separate type trees. We will rewrite and decouple a lot of our current features with this.</p><h2>Execution Engine</h2><p>With this first dev preview, we are bringing the first part of our new execution engine in. It does not yet contain the execution plan bits but has a lot of the memory optimizations built-in. The execution engine now also is much easier to extend with features. All of the execution configurations are as-well backed into our new configuration API.</p><p>If I, for instance, wanted to use the persisted queries execution flow, I could do so by using the following configuration.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services\n        .AddGraphQLServer(&quot;hello&quot;)\n            .AddQueryType(d =&gt; d\n                .Name(&quot;Query&quot;)\n                .Field(&quot;hello&quot;)\n                .Resolver(&quot;world&quot;))\n            .UsePersistedQueryPipeline();\n}\n</code></pre><h2>Summary</h2><p>There are a ton more features in this preview, so many really that it is to much to go into every one of them. Also, we have just begun to bring our various bits together and hope to integrate those now more quickly. Over the next weeks, we will share with every new preview more new features with you and will drill down more specifically into those. This first post is meant to kick things off. Give us feedback on how you like the feel of the new configuration API.</p>",
            "url": "https://chillicream.com/blog/2020/07/16/version-11",
            "title": "What is up with 11",
            "summary": "When we at ChilliCream talked the other day, we reflected on the progress on version 11, where we are at this point, and how we got there…",
            "image": "https://chillicream.com/static/ba24fb16db9c88359a48bfca078b0d63/0514f/hotchocolate-where-is-v11-banner.png",
            "date_modified": "2020-07-16T00:00:00.000Z",
            "date_published": "2020-07-16T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2020/03/18/entity-framework",
            "content_html": "<p>In this post I will walk you through how to build a GraphQL Server using Hot Chocolate and <em>Entity Framework</em>.</p><p><em>Entity Framework</em> is an OR-mapper from Microsoft that implements the unit-of-work pattern. This basically means that with <em>Entity Framework</em> we work against a <code>DbContext</code> and once in a while commit changes aggregated on that context to the database by invoking <code>SaveChanges</code>.</p><p>With <em>Entity Framework</em> we can write database queries with <em>LINQ</em> and do not have to deal with <em>SQL</em> directly. This means that we can compile our database queries and can detect query errors before we run our code.</p><h2>Introduction</h2><p>This blog post is based on the Contoso University example application used by Microsoft to demonstrate the usage of <em>Entity Framework</em> with ASP.NET Core.</p><p>In this blog post we will take that example and build with it a simple GraphQL server for the university website. With it, we can query students, courses, and instructor information.</p><p>Before we get started let us setup our server project.</p><pre><code class=\"language-bash\">mkdir ContosoUniversity\ndotnet new web\n</code></pre><p>Next wee need to add <em>Entity Framework</em> to our project.</p><pre><code class=\"language-bash\">dotnet add package Microsoft.EntityFrameworkCore\n</code></pre><p>Last but not least we are adding the SQLLite <em>Entity Framework</em> provided in order to have a lightweight database.</p><pre><code class=\"language-bash\">dotnet add package Microsoft.EntityFrameworkCore.Sqlite\n</code></pre><p>For our data we have three models representing the student, the enrollments and the courses.</p><p>The student entity has some basic data about the student like the first name, the last name or the date when the student first enrolled into the university.</p><p>The enrollment entity represents the enrollment of a student to a specific course. The enrollment entity not only represents the relationship between the student and the course but also holds the Grade that a student achieved in that course.</p><p>Last but not least we have the course to which many students are enrolled to. The course has a title and a property defining the credit that a student can achieve in that course.</p><p>Let’s copy our models into our project.</p><pre><code class=\"language-csharp\">using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace ContosoUniversity\n{\n    public class Student\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n        public int Id { get; set; }\n        public string LastName { get; set; }\n        public string FirstMidName { get; set; }\n        public DateTime EnrollmentDate { get; set; }\n\n        public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }\n    }\n\n    public enum Grade\n    {\n        A, B, C, D, F\n    }\n\n    public class Enrollment\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n        public int EnrollmentId { get; set; }\n        public int CourseId { get; set; }\n        public int StudentId { get; set; }\n        public Grade? Grade { get; set; }\n\n        public virtual Course Course { get; set; }\n        public virtual Student Student { get; set; }\n    }\n\n    public class Course\n    {\n        [Key]\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n        public int CourseId { get; set; }\n        public string Title { get; set; }\n        public int Credits { get; set; }\n\n        public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }\n    }\n}\n</code></pre><p>For our models we do need a <code>DbContext</code> against which we can interact with our database.</p><pre><code class=\"language-csharp\">using Microsoft.EntityFrameworkCore;\n\nnamespace ContosoUniversity\n{\n    public class SchoolContext : DbContext\n    {\n        public DbSet&lt;Student&gt; Students { get; set; }\n        public DbSet&lt;Enrollment&gt; Enrollments { get; set; }\n        public DbSet&lt;Course&gt; Courses { get; set; }\n\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlite(&quot;Data Source=uni.db&quot;);\n        }\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            modelBuilder.Entity&lt;Student&gt;()\n                .HasMany(t =&gt; t.Enrollments)\n                .WithOne(t =&gt; t.Student)\n                .HasForeignKey(t =&gt; t.StudentId);\n\n            modelBuilder.Entity&lt;Enrollment&gt;()\n                .HasIndex(t =&gt; new { t.StudentId, t.CourseId })\n                .IsUnique();\n\n            modelBuilder.Entity&lt;Course&gt;()\n                .HasMany(t =&gt; t.Enrollments)\n                .WithOne(t =&gt; t.Course)\n                .HasForeignKey(t =&gt; t.CourseId);\n        }\n    }\n}\n</code></pre><p>The <code>SchoolContext</code> exposes access to our entities through <code>DbSet</code>. We can query a <code>DbSet&lt;T&gt;</code> with <em>LINQ</em> or add new entities to it. Moreover, our <code>ShoolContext</code> has some configuration that defines the relations between our entities.</p><p>Copy the context as well to our project.</p><p>Next, we need to register our <code>SchoolContext</code> with the dependency injection so that our GraphQL server can request instances of it. For that lets open our <code>Startup.cs</code> and replace the <code>ConfigureServices</code> method with the following code.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services.AddDbContext&lt;SchoolContext&gt;();\n}\n</code></pre><p>There is one last thing to finish up our preparations with the database and to get into GraphQL.</p><p>We somehow need to create our database. Since we are in this post only exploring how we can query data with entity framework and GraphQL we will also need to seed some data.</p><p>Add the following method to the <code>Startup.cs</code>:</p><pre><code class=\"language-csharp\">private static void InitializeDatabase(IApplicationBuilder app)\n{\n    using (var serviceScope = app.ApplicationServices.GetService&lt;IServiceScopeFactory&gt;().CreateScope())\n    {\n        var context = serviceScope.ServiceProvider.GetRequiredService&lt;SchoolContext&gt;();\n        if (context.Database.EnsureCreated())\n        {\n            var course = new Course { Credits = 10, Title = &quot;Object Oriented Programming 1&quot; };\n\n            context.Enrollments.Add(new Enrollment\n            {\n                Course = course,\n                Student = new Student { FirstMidName = &quot;Rafael&quot;, LastName = &quot;Foo&quot;, EnrollmentDate = DateTime.UtcNow }\n            });\n            context.Enrollments.Add(new Enrollment\n            {\n                Course = course,\n                Student = new Student { FirstMidName = &quot;Pascal&quot;, LastName = &quot;Bar&quot;, EnrollmentDate = DateTime.UtcNow }\n            });\n            context.Enrollments.Add(new Enrollment\n            {\n                Course = course,\n                Student = new Student { FirstMidName = &quot;Michael&quot;, LastName = &quot;Baz&quot;, EnrollmentDate = DateTime.UtcNow }\n            });\n            context.SaveChangesAsync();\n        }\n    }\n}\n</code></pre><p><code>InitializeDatabase</code> ensures that our database is created and seeds some initial data so that we can do some queries.</p><p>Next call <code>InitializeDatabase</code> in the first line of the <code>Configure</code> method in the <code>Startup.cs</code>. The updated <code>Configure</code> method should look like the following:</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    InitializeDatabase(app);\n\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =&gt;\n    {\n        endpoints.MapGet(&quot;/&quot;, async context =&gt;\n        {\n            await context.Response.WriteAsync(&quot;Hello World!&quot;);\n        });\n    });\n}\n</code></pre><p>We are basically done with our preparations. So far, we have defined our models, created our <code>ShoolContext</code> through which we can query the database. We also registered the <code>ShoolContext</code> with the dependency injection container and added some initialization logic so that our database is created with some initial data. With that settled let us move on and talk about GraphQL.</p><h2>GraphQL Schema</h2><p>Everything in GraphQL resolves around a schema. The schema defines the types that are available and the data that our GraphQL server exposes.</p><p>In GraphQL we interact with the data through root types. In this post we will only query data which means that we only need to define the query root type.</p><p>The query root type exposes fields which are called root fields. The root fields define how we can query for data. For our university GraphQL server we want to be able to query the students and then drill deeper into what courses a student is enrolled to or what grade he/she has in a specific course.</p><p>Before we actually can put some GraphQL types in our project we again need to add some packages. This time we need to add the <code>HotChocolate.AspNetCore</code> package to enable the core GraphQL server functionality. Also we need the <code>HotChocolate.Types.Selections</code> package to be able to use <em>Entity Framework</em> projections.</p><pre><code class=\"language-bash\">dotnet add package HotChocolate.AspNetCore\ndotnet add package HotChocolate.Types.Selections\n</code></pre><p>With Hot Chocolate and the <em>pure code-first</em> approach the query root type is represented by a simple class. Public methods or public properties on that type are inferred as fields of our GraphQL type.</p><p>The following class:</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// Gets all students.\n    /// &lt;/summary&gt;\n    public IQueryable&lt;Student&gt; GetStudents() =&gt; throw new NotImplementedException();\n}\n</code></pre><p>Is translated to the following GraphQL type:</p><pre><code class=\"language-graphql\">type Query {\n  &quot;&quot;&quot;\n  Gets all students\n  &quot;&quot;&quot;\n  students: [Student]\n}\n</code></pre><blockquote><p>Hot Chocolate will apply GraphQL conventions to inferred types which will remove the verb <code>Get</code> for instance from the method or if it is an async method the postfix <code>async</code> will be removed. These conventions can be configured.</p></blockquote><p>In GraphQL we call the method <code>GetStudents</code> a resolver since it resolves for us some data. Resolvers are executed independent from one another and each resolver has dependencies on different resources. Everything that a resolver needs can be injected as a method parameter. Our <code>GetStudents</code> resolver for instance needs the <code>ShoolContext</code> to fetch some data. By using argument injection the execution engine can better optimize how to execute a query.</p><p>OK, with this knowledge lets implement our <code>Query</code> class.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// Gets all students.\n    /// &lt;/summary&gt;\n    public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext schoolContext) =&gt;\n        schoolContext.Students;\n}\n</code></pre><p>Our query class up there would already work. But only for the first level. It basically would resolve all students but we could not drill deeper. The enrollments would always be empty. In Hot Chocolate we have a concept of field middleware that can alter the execution pipeline of our field resolver.</p><p>The middleware order is important since multiple middleware form a field execution pipeline.</p><p>In our case we want <em>Entity Framework</em> projections to work so that we can drill into data in our GraphQL query. For this we can add the selection middleware. Middleware in <em>pure code-first</em> are represented by simple attributes. Since middleware order is important the order of these middleware attributes is important too. Middleware attributes always start with the verb <code>Use</code>. So, for our selections middleware we add <code>[UseSelection]</code>.</p><pre><code class=\"language-csharp\">using System.Linq;\nusing HotChocolate;\nusing HotChocolate.Types;\n\nnamespace ContosoUniversity\n{\n    public class Query\n    {\n        /// &lt;summary&gt;\n        /// Gets all students.\n        /// &lt;/summary&gt;\n        [UseSelection]\n        public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext schoolContext) =&gt;\n            schoolContext.Students;\n    }\n}\n</code></pre><p>Let’s paste this file into our project.</p><p>I pointed out that in GraphQL everything resolves around a schema. In order to get our GraphQL server up and running we need to create and host a GraphQL schema in our server. In Hot Chocolate we define a schema with the <code>SchemaBuilder</code>.</p><p>Open the <code>Startup.cs</code> again and then let us add a simple schema with our <code>Query</code> type.</p><p>For that replace the <code>ConfigureServices</code> method with the following code.</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services.AddDbContext&lt;SchoolContext&gt;();\n\n    services.AddGraphQL(\n        SchemaBuilder.New()\n            .AddQueryType&lt;Query&gt;()\n            .Create(),\n        new QueryExecutionOptions { ForceSerialExecution = true });\n}\n</code></pre><p>The above code registers a GraphQL schema with the dependency injection container.</p><pre><code class=\"language-csharp\">SchemaBuilder.New()\n    .AddQueryType&lt;Query&gt;()\n    .Create()\n</code></pre><p>The schema builder registers our <code>Query</code> class as GraphQL <code>Query</code> root type.</p><pre><code class=\"language-csharp\">new QueryExecutionOptions { ForceSerialExecution = true }\n</code></pre><p>Also, we are defining that the execution engine shall be forced to execute serially since <code>DbContext</code> is not thread-safe.</p><blockquote><p>The upcoming version 11 of Hot Chocolate uses <code>DbContext</code> pooling to use multiple <code>DbContext</code> instances in one request. This allows version 11 to parallelize data fetching better with <em>Entity Framework</em>.</p></blockquote><p>In order to enable our ASP.NET Core server to process GraphQL requests we need to register the Hot Chocolate GraphQL middleware.</p><p>For that we need to replace the <code>Configure</code> method of our <code>Startup.cs</code> with the following code.</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    InitializeDatabase(app);\n\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseRouting();\n\n    app.UseGraphQL();\n\n    app.UseEndpoints(endpoints =&gt;\n    {\n        endpoints.MapGet(&quot;/&quot;, async context =&gt;\n        {\n            await context.Response.WriteAsync(&quot;Hello World!&quot;);\n        });\n    });\n}\n</code></pre><p><code>app.UseGraphQL();</code> registers the GraphQL middleware with the server. Since we did not specify any path the middleware will run on the root of our server. Like with field middleware the order of ASP.NET Core middleware is important.</p><h2>Testing a GraphQL Server</h2><p>In order to now query our GraphQL server we need a GraphQL IDE to formulate queries and explore the schema. If you want a deluxe GraphQL IDE as an application, you can get our very own Banana Cakepop which can be downloaded <a href=\"/docs/bananacakepop\">here</a>.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/142af/banana-cake-pop.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:61%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsSAAALEgHS3X78AAAC/klEQVQoz2VSW2tUVxQ+T1IoQh+Ugj/CvhgQFa+tEqtGTFpvRYlGRydUWiOEDKgv6Q+wdPakYxRBUBAsKuKDikSqSaPWSSaZJFp1xslczlySOWfOmXPdZ3+uPWoQu+Bjrb323t9e39pLadnUsXL9j12Da9uPR1dsO8xW7+pm2/eFWNueQ2zLrp/Yth8OsB27D7Ku7l/Zn/FB1rG/k635djvbsLWdrWttZxu/72Dfte2NtnYcGNyyc98qZcmarp/PsmsYeTqG+4+e4uFIAuNT/2FsYhrjY0lMTk4hlZpGOp2GaZp49SaD8dQMkslJPPk3idHnk3iWnEGCzt+8fecXZVnrqSOXb4/AqKpOIZ/z6tq8LyD8wLF9iMAHxQD+D+77QcOSsUdwCHj58sUx5YuWztAfV++iUszxV6/fiEKhAMt24HGOIAgQCLEAQXA9D5brwW00CBYEvUgbRO9jYmIirCxa0RmKXrmHcj7Lp6anRSaTgWHZmK/OwdY12I4Nw22g4VrkTRh2A5bjwiP5AQ/eEwKcjNqQDCtfrjwaYtceoFZV+dtsVqiqCpMIuSeVfDB5S4hm6NNFmwh9y4Lvc5lfIEylUmFl8apwKH79IVyrzotqSVQqlSahZlpwpCzXhs0daplHZBI+PrMmoWxPk/CrtSdC5//6G7ap8UJRFeVyGVrdgGGY8L33BI7rwLHtprfJG/U6LKrQdV04jiPIc7lOJBJhZcnGk6HBG48XCCvlspirzAtdrwuSIV8XpmHKh0StVhOZbE5kZ2cFkQrDNIVhGILGiWuahuHh4bDy9ebeoxdv/UPydK9YKvG5SoXPzes8r6ry57iUQ1XxarXK65rGn6czvKzr3KUcVdUE7XsNas/o6OhxmsNI94WbwzBqVczm8ijS2GRzBbxOZ6DrOuokT36U/P18Pi9nrbmWe7Iq6SVKpRKGhoZOKEtbdi8P9/52+tLF830sFusbGBiI/H7uXIQxFonFYpFoNNqMP0Lm4vH4p5B3+vr7+8/09PR88w7wDheNOWaCuAAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/7842b/banana-cake-pop.png\" srcSet=\"https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/f8f3a/banana-cake-pop.png 200w,https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/6a8a8/banana-cake-pop.png 400w,https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/7842b/banana-cake-pop.png 800w,https://chillicream.com/static/83aff166a4b32131eb13063c3d9f7a17/142af/banana-cake-pop.png 1082w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>But you can also opt for <em>Playground</em> and host a simple GraphQL IDE as a middleware with the server. If you want to use playground add the following package to the project:</p><pre><code class=\"language-bash\">dotnet add package HotChocolate.AspNetCore.Playground\n</code></pre><p>After that we need to register the playground middleware. For that add <code>app.UsePlayground();</code> after <code>app.UseGraphQL()</code>. By default, playground is hosted on <code>/playground</code> meaning in our case <code>http://localhost:5000/playground</code>.</p><p>The <code>Configure</code> method should now look like the following:</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    InitializeDatabase(app);\n\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseRouting();\n\n    app.UseGraphQL();\n    app.UsePlayground();\n\n    app.UseEndpoints(endpoints =&gt;\n    {\n        endpoints.MapGet(&quot;/&quot;, async context =&gt;\n        {\n            await context.Response.WriteAsync(&quot;Hello World!&quot;);\n        });\n    });\n}\n</code></pre><p>Let’s test our GraphQL server.</p><pre><code class=\"language-bash\">dotnet run --urls http://localhost:5000\n</code></pre><h3>Testing with Banana Cakepop</h3><p>If you have chosen <em>Banana Cakepop</em> to test and explore the GraphQL Schema open it now.</p><p><em>Banana Cakepop</em> will open with an empty tab. In the address bar type in the URL of our GraphQL server <code>http://localhost:5000</code> and hit <code>enter</code>.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/2b13e/banana-cake-pop-address.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:38.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABLElEQVQoz63QzU7CQBAH8H0jvw4qxg+MHBC9+AJIvCokHoxSS9CLD+AT+GClEERCm9JK+rG77fJ3dsMJSIyJk/wyszuT3W3Zw6MF2+6gbdnodl9QqV1hY/cYpXIVR5VLHJ7VcHB6TqpUX2CnVMYm9bf2lp1ge78M5n56mPgBviY+uJB4e/9AvdXFzf0rGq0OsXF9Z6F+2yZPpm40tedVNMt4liGOY+jI0hRBECAKQ4RESoG/BouiCJrv+8Z0OsVgMDAcx8FoNMJ4PIbruuj3++j1ehgOh2bW87wVjHOOOM0wm30jzyXJkdJLtSRJkNEX6Bldp8Rk6gkhIGh/GZN0QEL/jguOXM2NYg5DmUxrKtRirRY9vbcO0y8qlEKmb8gLyEJB6vybYj1z4H/GD/8CLbHE9Z09AAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/7842b/banana-cake-pop-address.png\" srcSet=\"https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/f8f3a/banana-cake-pop-address.png 200w,https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/6a8a8/banana-cake-pop-address.png 400w,https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/7842b/banana-cake-pop-address.png 800w,https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/5ece7/banana-cake-pop-address.png 1200w,https://chillicream.com/static/69e0f04fc210498531ec8707b5e18cd5/2b13e/banana-cake-pop-address.png 1425w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>Once our GraphQL IDE has fetched the schema we can start exploring it. On the left-hand side click on the <code>Book</code> button. The left-hand side now shows us the root types and the root fields.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:681px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/943d3b068d10d321830906928d7ac4ef/ad007/banana-cake-pop-root-types.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:74%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACy0lEQVQ4y5WSWU8TURiG5ycQwZgY0sYKYjRIEBekpIUCrSytVIogkWBKTLwAIRDElhYoi6gQl9gCKheQKKgYozdGiNx454WR1C50o6QL7Uxb+Ad9PTPUprh78eSc+b6Z53zvyVAaWVW8Vy1CXVtxXNxQAqGwDEJxKYrFEhSJSiEUSbi9WFKeoIKj5EfKdqAElV3gyTrj/LOd7Ir8ei1ONOpwrE6D0039KGjQIU+lgaCqC1k1PTik6MXhWi2O1umQe2EAeY1DyG8aRUHzLZxsGQeVKR+IZ9ePIls1Ek+XanFKfQ+iq0YUtt6HSjuL+r45SDumkVauQbqsjyNDpsPeSj32VQ9iv2IYmcqb4KvuQNBwF1SOagiydiOON99GkXockwtLePD0HYzz72EkexML2U+/WMbU81SWEixzvUcvP+Dx4sqOUEqEB5UGKLomwYT8WLN9xbrHCav5C7xuByLhIOhQgPR+DZ0CxZPrcaB2ABnSG5B3muB0umCz2eF2kNVqg8PphMezDqfLzfWcrj9D8RX9ECgHOeG57ikEAwEE/AF89rmxtuEh09rhcDjg9/sRDAZ/y+bmJrxeL6is8wZUtD3EkYZREnkKNB1GmDQttA+WoBcWs5lMbCN1Gtvb24hEIojFYtja2krC1ljYQykembBQPYEc1TAnjJIGE2EQDYQRXV3nXnKS2Ha7ncPn88FFolmtVu6ZXQMkFStke1RmdR94ch3SJD1c5AiR0QxDpgyBtm3A7XbDTKa0WCzcx2wsVsg+f6/vEha1z0CmXcCZjllcMjzjIjPMjpSORRCNRpPR2Kjshz/W2PdZOKFy5A0m3q7i2sxHtIwtgg4nhOTOGAL9jySFcsNr6Oc/odW4gstjr4gwlBQmpQy9q5Yq+UlYcMWEwrYnyG014WL/HCdITpiI8jd2CXk1evDJz72n/Dpqu6e5O0o99X+F3wBDXZOfcpeefwAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/943d3b068d10d321830906928d7ac4ef/ad007/banana-cake-pop-root-types.png\" srcSet=\"https://chillicream.com/static/943d3b068d10d321830906928d7ac4ef/f8f3a/banana-cake-pop-root-types.png 200w,https://chillicream.com/static/943d3b068d10d321830906928d7ac4ef/6a8a8/banana-cake-pop-root-types.png 400w,https://chillicream.com/static/943d3b068d10d321830906928d7ac4ef/ad007/banana-cake-pop-root-types.png 681w\" sizes=\"(max-width: 681px) 100vw, 681px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>In our current schema we can see that we have a single root field called <code>students</code>. If we click on that the schema explorer opens and we can drill into our type. We can see what fields we can request from our <code>Student</code> type. We also can see that we can drill in further and fetch the enrollments and from the enrollments the courses and so on.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/b2484/banana-cake-pop-expanded-schema.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:63.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAADKklEQVQ4y2WRW2gcVRzG58UXpVAQClYfilu6Ei+tdWu6urObVE2b1Foo6oOvglIoKFhIBympqyhSC3koFIq0abY2mtJ0I7VKS0FjwBTUBl9CTNyEye5m7vfbztk9X89MNLV6OL/zweHP979xfQOH8jv3vT609YVDg1u6DwqZwpvCjuIBoStXFI6894EwPDws9Ow7KGR35IXs9t3C413PCZknc0LmqV3C1me6heyzBSG7kx/s2tU79HT3nn5uc+mdz98aPI2zY9dw6txVnDo/iUvVGxivfo/bv85CFFdQ/e4mLoxN4OL4JEa/ucqoYvTrCVSYVsarGJu4jsvf3sDI2MQVbsOLh0988dUtgASh79pxK3Bj4nlx7Huxp0uxYxoxgDUIiUEZnWD9r90hiYYMyNLqCLftjaHy8PgUPMtoN1Yl2mRokkItWaK6rlPP92kQhtTQdCqJIlOZoVLLsqiqalQ3TOq4LrEdB/Pz86PcA7m3y8fPTCJwrfaqJFFJlqEsr6CxsICVRh2mocGybTiaCWO5Bts2EbViRsSKsKGIdWrZVjvwPSwu/lXhHtz9bvnE2WsImaEkyVSSJFiaDts04QQRWq0WWnELoePDqovwXQsxISmR5yPpxrHUdhS4qC0tV7gNhSPl8pfX0wrXDS0LQRDA9zz4vr9OEIQIwghRGCJkGrNkFMlFO5lhs9mscBtL75c/OffDfYaGYcB1XbDZpOoxY+9f5kmyhCiKEh/KTmrYaDQq3MMvHS1/OnKTGZr3GTpsyHYyO6b/4P4nQRiG/zfc1Hfso88u3ILvmCRdCsNg23UcO8V1nHu4Dvu7B6syaZd2Oh3CTFGv10e5zfuPf3zy0hQi3+koqgZNVSHJDEWDrOopimakqDpblLNWYVLp3y0np5M8iqJc5B4b+HAomaHcFFts7WSpViMzv/1BfvzldzI1c4f8xJiamU3159uz5M+FRbK8tERqLE4URcJMCGs1mpubw/T09HnuoUeyjz6x/fnSnt6eQqlU4ovFEt+/92X+tf17+QMDfWv0r+mr/a/wvT09LKbIJ7GFQoHP5/N8LpcrZDKZEiNzF3pdNNxkS+7oAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/7842b/banana-cake-pop-expanded-schema.png\" srcSet=\"https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/f8f3a/banana-cake-pop-expanded-schema.png 200w,https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/6a8a8/banana-cake-pop-expanded-schema.png 400w,https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/7842b/banana-cake-pop-expanded-schema.png 800w,https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/5ece7/banana-cake-pop-expanded-schema.png 1200w,https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/0d4f8/banana-cake-pop-expanded-schema.png 1600w,https://chillicream.com/static/b17c3abc623fa0a309a1081444f013f9/b2484/banana-cake-pop-expanded-schema.png 2972w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>Now close the schema tab again so that we can write some queries.</p><h3>Testing with Playground</h3><p>If you have opted for <em>Playground</em> open your browser and navigate to <code>http://localhost:5000/playground</code>.</p><p>On the right-hand side click on the <code>Docs</code> button. A pane will slide out showing us the root types and root fields of our schema.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/29524/playground-root-types.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:83.50000000000001%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC7UlEQVQ4y6WTzU/UQBTA9+ZBT2I4IB6IkqAmEgIJ33AyDWe9iQaWQMKXimK84D9gQOVrV4EF9ODZmxJkSfCoiTEgIOAWym4/t+1uW7a7bDvPNyUkghoJvOSXeZ12fn2TeeO7ei7vTGFBLnOl+DJTVlrG5F/IZ4qKipjKykqmvLycqaioYKprqpmamhovr6quYkrLSpm883keJSUlTG1tLVNcfK0hJ+dsrq+rubXyVXAIJqZDMDk1Dc9fDMJoIAihqSmYCE3COELnp16/gfGJkDc3NjYB/QPP4Gn/AASCL3F+EgaHR6C9o/OOb2hktG5zWwBRVl0uKhBelMl2TCQsF/OguayoRFF1wksKkaQ42RIEolkmSad3ibWTIjsp2zGtFLz/MNPiGxoarovGeJCUuCugTFbiRJIVIuJiQZKJqulkI7JJvi4ue/MyCle4CFFMjbhZB6U2cTCy2V2YnZ31+4LBYJ1lWZDOZEg6kyZ2Og2UtDfa4LouLK2uwUz4E5j4XSJhACcLICdVQCE4rkPwG2d3Nwtzc3N+XwCFScOAlG1j6bT8FBwG30EiaUBc08BMmPB29SOwKgeQyaDUIgDEoT8Oh8N/CuniffZldNQTCRTqnvDdygLELAVoYHEohINC4whCTd8TJnQDFtd+gJ4yPSHB2BfOz88fXagnkp7USJqwLmyBZhsnE9LqeFECQZBhiV07uVAQeeC4CPBRDr5v4paPL6QnbYMY/Qmx9c8gRb7B6voXFCb/Lfxf2+BtAEESYZuP4ZYlWObW/7pl75SxsWsN06TN7KDUxdGD5vug1OVF0d2OxVxBEN3lrQ1XSyVdr2sw0JnFy7InHA0E6jVdByqlldJcxQa2dnYOoKgqiIoC8bjqnbLl2HA4FhYWWn311xvKmjt6tpra77NN7T3s7ba7bGNrN+vvfMj6u34Dn5uRlq5etrHjHtv24DHb/egJ29nbR4l0Perjb95qvuHDOIUUIIXIpWNC115ETv8CN84suHH3hiIAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/7842b/playground-root-types.png\" srcSet=\"https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/f8f3a/playground-root-types.png 200w,https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/6a8a8/playground-root-types.png 400w,https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/7842b/playground-root-types.png 800w,https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/5ece7/playground-root-types.png 1200w,https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/0d4f8/playground-root-types.png 1600w,https://chillicream.com/static/8eef1f07104c1474c76431a653209c7b/29524/playground-root-types.png 2272w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>In our current schema we can see that we have a single root field called <code>students</code>. If we click on that the schema explorer opens and we can drill into our type. We can see what fields we can request from our <code>Student</code> type. We also can see that we can drill in further and fetch the enrollments and from the enrollments the courses and so on.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/d7166/playground-expanded-schema.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:67.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACfUlEQVQ4y6WSz08TQRTH96L8DXCSACbAxYPQEhO5SAKS0KoxtuVgIjFx9Y/TFKlQC+HIxYuRgAeiFGil3R/tbHd+zzxfd0sDiQeNk7zMzvvxmfe+s07u8YPXT58/e7u6uvpmbn7Ofbi46BaKRfdFoeAW0EqlkvtqY8Mtoq9QxPP6uvtoacnNZLNuJpNx+3XFUund8vLyS8dxbjvlzTLs7u/DzuddKG9tw8fKJ9ip1qBa20PfXuKv1nZxr6WGsa3KNmxuVRKrbFehijnvP5TVfCY76pzUz2i93dQyjiRoogBAGWMUCwNlWKCsFsqiDyTuiibxoXGOfqwDDYyL1pN8bszxw1D8uDyFyKtbGXtWSGkF5zYOm1bSjtVKWq215ZRaQXv2aimlLCNdqzg1CIc4jv1cbm3M+XJxLA6ahwDS2iTSv1obYL0YJOeglAYEQkQFFvUArAbkJTmE9MBIlpRRBK6tIfDr6XdxUD+CthfZuNMAwSJsX4LnBwgNQQiB0woIuhGEQRt43AHGKAipICQRKBEPO0yAF42mOLlsQJdEVnJMkDK5vRPFgMImHaOGgLrih8HuUo82FrpRBKhr2iEdAL3QFxfEB6P62qdDG6wiPdpPToF4tikJBsTkbFL/AEhRQ3yUduCLBmkjUF/F8HbUkDEwWibdDIHXwNf2m8B+hz9RG00DfLp4+ChSMOywN4T9AXRlN4Et3+O/ekEyqbFm+FsMhrN/sfQA6CXAgHSULwj875JShvl8fsz5dnRIjs9OJOkSFoYhD4KAt1qtfzHmeZ45Pz9vrKysjDp3xsfvT92dWpidnc3OzMxkp6ensxMTE/9qC5OTk/dGRkZu/QZLuJm56BPfOAAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/7842b/playground-expanded-schema.png\" srcSet=\"https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/f8f3a/playground-expanded-schema.png 200w,https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/6a8a8/playground-expanded-schema.png 400w,https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/7842b/playground-expanded-schema.png 800w,https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/5ece7/playground-expanded-schema.png 1200w,https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/0d4f8/playground-expanded-schema.png 1600w,https://chillicream.com/static/2e821a00db4e89f7a5ecb6efab42e845/d7166/playground-expanded-schema.png 2796w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>Now click onto <code>Docs</code> again so that the schema tab slides back in again. We are now ready to write our first query.</p><h3>Recap</h3><p>While we just added one field that exposes the <code>Student</code> entity to Hot Chocolate, Hot Chocolate explored what data is reachable from that entity. In conjunction with the <code>UseSelection</code> middleware we can now query all that data and drill into our graph.</p><p>We have explored tooling with which we can explore the schema before issuing the first request.</p><p>If we would print our schema it would now look like the following.</p><blockquote><p>The schema SDL can be downloaded from http://localhost:5000/schema.</p></blockquote><pre><code class=\"language-graphql\">schema {\n  query: Query\n}\n\ntype Query {\n  students: [Student]\n}\n\ntype Student {\n  enrollmentDate: DateTime!\n  enrollments: [Enrollment]\n  firstMidName: String\n  id: Int!\n  lastName: String\n}\n\ntype Course {\n  courseId: Int!\n  credits: Int!\n  enrollments: [Enrollment]\n  title: String\n}\n\ntype Enrollment {\n  course: Course\n  courseId: Int!\n  enrollmentId: Int!\n  grade: Grade\n  student: Student\n  studentId: Int!\n}\n\nenum Grade {\n  A\n  B\n  C\n  D\n  F\n}\n\n&quot;The `DateTime` scalar represents an ISO-8601 compliant date time type.&quot;\nscalar DateTime\n\n&quot;The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.&quot;\nscalar Int\n\n&quot;The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.&quot;\nscalar String\n</code></pre><h3>Writing Queries</h3><p>In both GraphQL IDEs we can type in the GraphQL queries on the left-hand pane. If we click on the play button the result will be displayed on the right-hand side pane.</p><p>Let us start with a simple query in which we ask for the first name of all students that we have in our database.</p><pre><code class=\"language-graphql\">query {\n  students {\n    firstMidName\n  }\n}\n</code></pre><p>The above query resolves correctly the data from our database, and we get the following result:</p><pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;students&quot;: [\n      {\n        &quot;firstMidName&quot;: &quot;Rafael&quot;\n      },\n      {\n        &quot;firstMidName&quot;: &quot;Pascal&quot;\n      },\n      {\n        &quot;firstMidName&quot;: &quot;Michael&quot;\n      }\n    ]\n  }\n}\n</code></pre><p>What is interesting is that the GraphQL engine rewrites the incoming GraphQL request to an expression tree that is applied onto the <code>IQueryable&lt;Student&gt;</code> our root field resolver returns. The expression will only query for data from the database that was needed to fulfill our request.</p><p>The SQL query in this case will look like the following:</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;FirstMidName&quot; FROM &quot;Students&quot; AS &quot;s&quot;\n</code></pre><p>Let us drill into the data a little more and fetch additionally to the <code>firstMidName</code> also the title of the course the students are enlisted to.</p><pre><code class=\"language-graphql\">query {\n  students {\n    firstMidName\n    enrollments {\n      course {\n        title\n      }\n    }\n  }\n}\n</code></pre><p>The above query returns:</p><pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;students&quot;: [\n      {\n        &quot;firstMidName&quot;: &quot;Rafael&quot;,\n        &quot;enrollments&quot;: [\n          {\n            &quot;course&quot;: {\n              &quot;title&quot;: &quot;Object Oriented Programming 1&quot;\n            }\n          }\n        ]\n      },\n      {\n        &quot;firstMidName&quot;: &quot;Pascal&quot;,\n        &quot;enrollments&quot;: [\n          {\n            &quot;course&quot;: {\n              &quot;title&quot;: &quot;Object Oriented Programming 1&quot;\n            }\n          }\n        ]\n      },\n      {\n        &quot;firstMidName&quot;: &quot;Michael&quot;,\n        &quot;enrollments&quot;: [\n          {\n            &quot;course&quot;: {\n              &quot;title&quot;: &quot;Object Oriented Programming 1&quot;\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre><p>In order to fetch the data, the GraphQL query is rewritten to the following SQL:</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;FirstMidName&quot;,\n       &quot;s&quot;.&quot;Id&quot;,\n       &quot;t&quot;.&quot;Title&quot;,\n       &quot;t&quot;.&quot;EnrollmentId&quot;,\n       &quot;t&quot;.&quot;CourseId&quot;\n    FROM &quot;Students&quot; AS &quot;s&quot;\n    LEFT JOIN (\n        SELECT &quot;c&quot;.&quot;Title&quot;,\n               &quot;e&quot;.&quot;EnrollmentId&quot;,\n               &quot;c&quot;.&quot;CourseId&quot;,\n               &quot;e&quot;.&quot;StudentId&quot;\n        FROM &quot;Enrollments&quot; AS &quot;e&quot;\n        INNER JOIN &quot;Courses&quot; AS &quot;c&quot;\n              ON &quot;e&quot;.&quot;CourseId&quot; = &quot;c&quot;.&quot;CourseId&quot;\n    ) AS &quot;t&quot; ON &quot;s&quot;.&quot;Id&quot; = &quot;t&quot;.&quot;StudentId&quot;\n    ORDER BY &quot;s&quot;.&quot;Id&quot;, &quot;t&quot;.&quot;EnrollmentId&quot;, &quot;t&quot;.&quot;CourseId&quot;\n</code></pre><p>The <code>UseSelection</code> middleware allows us by just attributing it to a field resolver that returns an <code>IQueryable&lt;T&gt;</code> to drill into that data set.</p><p>Without a lot of code, we already have a working GraphQL server that returns all the students. We are already able to drill into our data and the <code>UseSelection</code> middleware rewrites GraphQL selections into <code>IQueryable&lt;T&gt;</code> projections that ensures that we only select the data that we need from the database.</p><p>Think about it, we really just added entity framework and exposed a single root field that basically just returns the <code>DbSet&lt;Student&gt;</code>.</p><h2>Filtering</h2><p>Let us go further with this. We actually can do more here and Hot Chocolate provides you with a filter and sorting middleware to really give you the power to query your data with complex expressions.</p><p>First, we need to add two more packages that will add the sorting and filtering middleware.</p><pre><code class=\"language-bash\">dotnet add package HotChocolate.Types.Filters\ndotnet add package HotChocolate.Types.Sorting\n</code></pre><p>With these new packages in place let us rewrite our query type in order to enable proper filtering support.</p><pre><code class=\"language-csharp\">using System.Linq;\nusing HotChocolate;\nusing HotChocolate.Types;\n\nnamespace ContosoUniversity\n{\n    public class Query\n    {\n        [UseSelection]\n        [UseFiltering]\n        [UseSorting]\n        public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext context) =&gt;\n            context.Students;\n    }\n}\n</code></pre><p>The above query type has now two new attributes <code>UseFiltering</code> and <code>UseSorting</code>. Let me again state that the order of middleware is important.</p><p>In order to understand how a field pipeline with middleware works have a look at the following sequence diagram which depicts our data pipeline applied to the above resolver.</p><div class=\"mermaid\" data-processed=\"true\"><svg id=\"mermaid-1615885773325\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\" height=\"513\" style=\"max-width:1050px\" viewBox=\"-50 -10 1050 513\"><style>#mermaid-1615885773325{font-family:sans-serif;font-size:16px;fill:#333;}#mermaid-1615885773325 .error-icon{fill:#552222;}#mermaid-1615885773325 .error-text{fill:#552222;stroke:#552222;}#mermaid-1615885773325 .edge-thickness-normal{stroke-width:2px;}#mermaid-1615885773325 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1615885773325 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1615885773325 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1615885773325 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1615885773325 .marker{fill:#333333;}#mermaid-1615885773325 .marker.cross{stroke:#333333;}#mermaid-1615885773325 svg{font-family:sans-serif;font-size:16px;}#mermaid-1615885773325 .actor{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1615885773325 text.actor &gt; tspan{fill:black;stroke:none;}#mermaid-1615885773325 .actor-line{stroke:grey;}#mermaid-1615885773325 .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid-1615885773325 .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid-1615885773325 #arrowhead path{fill:#333;stroke:#333;}#mermaid-1615885773325 .sequenceNumber{fill:white;}#mermaid-1615885773325 #sequencenumber{fill:#333;}#mermaid-1615885773325 #crosshead path{fill:#333;stroke:#333;}#mermaid-1615885773325 .messageText{fill:#333;stroke:#333;}#mermaid-1615885773325 .labelBox{stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:#ECECFF;}#mermaid-1615885773325 .labelText,#mermaid-1615885773325 .labelText &gt; tspan{fill:black;stroke:none;}#mermaid-1615885773325 .loopText,#mermaid-1615885773325 .loopText &gt; tspan{fill:black;stroke:none;}#mermaid-1615885773325 .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243,59.7765363128%,87.9019607843%);fill:hsl(259.6261682243,59.7765363128%,87.9019607843%);}#mermaid-1615885773325 .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid-1615885773325 .noteText,#mermaid-1615885773325 .noteText &gt; tspan{fill:black;stroke:none;}#mermaid-1615885773325 .activation0{fill:#f4f4f4;stroke:#666;}#mermaid-1615885773325 .activation1{fill:#f4f4f4;stroke:#666;}#mermaid-1615885773325 .activation2{fill:#f4f4f4;stroke:#666;}#mermaid-1615885773325:root{--mermaid-font-family:sans-serif;}#mermaid-1615885773325 sequence{fill:apa;}</style><g></g><g><line id=\"actor0\" x1=\"75\" y1=\"5\" x2=\"75\" y2=\"502\" class=\"actor-line\" stroke-width=\"0.5px\" stroke=\"#999\"></line><rect x=\"0\" y=\"0\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"75\" y=\"32.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"75\" dy=\"0\">UsePaging</tspan></text></g><g><line id=\"actor1\" x1=\"275\" y1=\"5\" x2=\"275\" y2=\"502\" class=\"actor-line\" stroke-width=\"0.5px\" stroke=\"#999\"></line><rect x=\"200\" y=\"0\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"275\" y=\"32.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"275\" dy=\"0\">UseSelection</tspan></text></g><g><line id=\"actor2\" x1=\"475\" y1=\"5\" x2=\"475\" y2=\"502\" class=\"actor-line\" stroke-width=\"0.5px\" stroke=\"#999\"></line><rect x=\"400\" y=\"0\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"475\" y=\"32.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"475\" dy=\"0\">UseFiltering</tspan></text></g><g><line id=\"actor3\" x1=\"675\" y1=\"5\" x2=\"675\" y2=\"502\" class=\"actor-line\" stroke-width=\"0.5px\" stroke=\"#999\"></line><rect x=\"600\" y=\"0\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"675\" y=\"32.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"675\" dy=\"0\">UseSorting</tspan></text></g><g><line id=\"actor4\" x1=\"875\" y1=\"5\" x2=\"875\" y2=\"502\" class=\"actor-line\" stroke-width=\"0.5px\" stroke=\"#999\"></line><rect x=\"800\" y=\"0\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"875\" y=\"32.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"875\" dy=\"0\">Resolver</tspan></text></g><defs><marker id=\"arrowhead\" refX=\"5\" refY=\"2\" markerWidth=\"6\" markerHeight=\"4\" orient=\"auto\"><path d=\"M 0,0 V 4 L6,2 Z\"></path></marker></defs><defs><marker id=\"crosshead\" markerWidth=\"15\" markerHeight=\"8\" orient=\"auto\" refX=\"16\" refY=\"4\"><path fill=\"black\" stroke=\"#000000\" stroke-width=\"1px\" d=\"M 9,2 V 6 L16,4 Z\" style=\"stroke-dasharray:0, 0\"></path><path fill=\"none\" stroke=\"#000000\" stroke-width=\"1px\" d=\"M 0,1 L 6,7 M 6,1 L 0,7\" style=\"stroke-dasharray:0, 0\"></path></marker></defs><defs><marker id=\"sequencenumber\" refX=\"15\" refY=\"15\" markerWidth=\"60\" markerHeight=\"40\" orient=\"auto\"><circle cx=\"15\" cy=\"15\" r=\"6\"></circle></marker></defs><text x=\"175\" y=\"80\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">next(context)</text><line x1=\"75\" y1=\"109\" x2=\"275\" y2=\"109\" class=\"messageLine0\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"fill:none\"></line><text x=\"75\" y=\"113\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">1</text><g><rect x=\"270\" y=\"109\" fill=\"#EDF2AE\" stroke=\"#666\" width=\"10\" height=\"308\" rx=\"0\" ry=\"0\" class=\"activation0\"></rect></g><text x=\"378\" y=\"124\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">next(context)</text><line x1=\"280\" y1=\"153\" x2=\"475\" y2=\"153\" class=\"messageLine0\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"fill:none\"></line><text x=\"280\" y=\"157\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">2</text><g><rect x=\"470\" y=\"155\" fill=\"#EDF2AE\" stroke=\"#666\" width=\"10\" height=\"218\" rx=\"0\" ry=\"0\" class=\"activation0\"></rect></g><text x=\"578\" y=\"168\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">next(context)</text><line x1=\"480\" y1=\"197\" x2=\"675\" y2=\"197\" class=\"messageLine0\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"fill:none\"></line><text x=\"480\" y=\"201\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">3</text><g><rect x=\"670\" y=\"199\" fill=\"#EDF2AE\" stroke=\"#666\" width=\"10\" height=\"130\" rx=\"0\" ry=\"0\" class=\"activation0\"></rect></g><text x=\"778\" y=\"212\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">next(context)</text><line x1=\"680\" y1=\"241\" x2=\"875\" y2=\"241\" class=\"messageLine0\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"fill:none\"></line><text x=\"680\" y=\"245\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">4</text><g><rect x=\"870\" y=\"243\" fill=\"#EDF2AE\" stroke=\"#666\" width=\"10\" height=\"42\" rx=\"0\" ry=\"0\" class=\"activation0\"></rect></g><text x=\"775\" y=\"256\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">apply sorting</text><line x1=\"870\" y1=\"285\" x2=\"680\" y2=\"285\" class=\"messageLine1\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"stroke-dasharray:3, 3;fill:none\"></line><text x=\"870\" y=\"289\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">5</text><text x=\"575\" y=\"300\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">apply filters</text><line x1=\"670\" y1=\"329\" x2=\"480\" y2=\"329\" class=\"messageLine1\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"stroke-dasharray:3, 3;fill:none\"></line><text x=\"670\" y=\"333\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">6</text><text x=\"375\" y=\"344\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">apply projections</text><line x1=\"470\" y1=\"373\" x2=\"280\" y2=\"373\" class=\"messageLine1\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"stroke-dasharray:3, 3;fill:none\"></line><text x=\"470\" y=\"377\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">7</text><text x=\"173\" y=\"388\" text-anchor=\"middle\" dominant-baseline=\"middle\" alignment-baseline=\"middle\" class=\"messageText\" dy=\"1em\" style=\"font-family:&quot;trebuchet ms&quot;, verdana, arial;font-size:16px;font-weight:400\">apply paging</text><line x1=\"270\" y1=\"417\" x2=\"75\" y2=\"417\" class=\"messageLine1\" stroke-width=\"2\" stroke=\"none\" marker-end=\"url(#arrowhead)\" marker-start=\"url(#sequencenumber)\" style=\"stroke-dasharray:3, 3;fill:none\"></line><text x=\"270\" y=\"421\" font-family=\"sans-serif\" font-size=\"12px\" text-anchor=\"middle\" textLength=\"16px\" class=\"sequenceNumber\">8</text><g><rect x=\"0\" y=\"437\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"75\" y=\"469.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"75\" dy=\"0\">UsePaging</tspan></text></g><g><rect x=\"200\" y=\"437\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"275\" y=\"469.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"275\" dy=\"0\">UseSelection</tspan></text></g><g><rect x=\"400\" y=\"437\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"475\" y=\"469.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"475\" dy=\"0\">UseFiltering</tspan></text></g><g><rect x=\"600\" y=\"437\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"675\" y=\"469.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"675\" dy=\"0\">UseSorting</tspan></text></g><g><rect x=\"800\" y=\"437\" fill=\"#eaeaea\" stroke=\"#666\" width=\"150\" height=\"65\" rx=\"3\" ry=\"3\" class=\"actor\"></rect><text x=\"875\" y=\"469.5\" dominant-baseline=\"central\" alignment-baseline=\"central\" class=\"actor\" style=\"text-anchor:middle;font-size:14px;font-weight:400;font-family:Open-Sans, sans-serif\"><tspan x=\"875\" dy=\"0\">Resolver</tspan></text></g></svg></div><p>Each field middleware initially yields control to the next field middleware until the resolver is invoked. The resolver returns its result and the field middleware will now on the way back apply their functionality to the result. In our case the field middleware are applying expressions to the queryable to build up the database query.</p><p>With that upgraded <code>Query</code> type let us restart our server.</p><pre><code class=\"language-bash\">dotnet run --urls http://localhost:5000\n</code></pre><p>Now let us inspect our schema again. When we look at the <code>students</code> field we can see that there are new arguments called <code>where</code> and <code>orderBy</code>.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/b2484/banana-cake-pop-arguments.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:63.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC8klEQVQ4y4WRW2jTUByH8+KLMhAEwcuDWLEy71qd1azVCWNORBD1wVdBEQQFhRlEqlUUUaEPgiAy5zpXrVhXUfGCL7IXH3zwaQx6cVnbpEmaJj3NpUlz/p6TzXkFQ778TkL4zu+cw/T2Hwpv6TscW7Xz0MCKroNcgD3KbYoc4Dq3RrjTZ85xiUSC2913kAtuCnPBjTu4lZ1bucDaEBdYt41btaGLC25mueCW7oHObXti67t69jFLoyduHhu4C/dTr+DO4Au48zALo2PvIf3yHXz+8hV4fhqyrz/Ao1QGRtJZGH76gjAGw08ykCSZTI9BKvMGnr18D0OpzHOmY9epy7cffwRwTctAutMykeMi5Fhy1WlI046u1hzA2AEAB1yXjAmeOfNOaHsuTYsAVVEYYlYficUT6U/Q1NR2RRBxRRCwrmkYCQXsqFPYc1u47XlYVzUs8jxWFYkgY438I8sKrql13EDI1RsNmJycHGbmhY7HL93Lgom0tiCKWKxWQSoLoExPgVCVoa5pgJoIUE0DtVgAXa+D3XIINimhg8SXsKZrbdNoQi6XTzLzd5yMX77/CqxZYZUIZb4MlUIRyoIImqYCnR3VddBLPBhIA8d1feymAYoo4YYmt20TQaH4Lcl0sKfj8Qdv/IaiWMWiSCRKDXQyOzIssKwZTNMkkLRssP1vNjitFmCgN7TpHlYqlSSzMHo2fm3w7W9CtV6HZrMJiDZDyB9TDMPwmZGbYNs29WBy+cJyuZxkFu09H78+9IEI6z+FqgoNItN13c8fUPmvE9DmfwkX9164cuPRRzAaddc/FIKiKP4pUoj0N4h4DtKSLhd7nucSKZRKpWFm6f5LV2+NfgLbaHiSrIAsy35D2u4H/2pIc3bJ9PLoQ5KkEWZ5/8UY3cNqhW/l8nk3T8jlcm6hUPDHNP+kWCz6yfO8SyQuWao9MTEB4+PjD5kFS4LL1mzcHu3Zs5uNRqPd/yMSiczBsmx3OBzuDoVCbCAQiBIC3wGtoDW6erVRlAAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Hot Chocolate\" title=\"Hot Chocolate\" src=\"https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/7842b/banana-cake-pop-arguments.png\" srcSet=\"https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/f8f3a/banana-cake-pop-arguments.png 200w,https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/6a8a8/banana-cake-pop-arguments.png 400w,https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/7842b/banana-cake-pop-arguments.png 800w,https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/5ece7/banana-cake-pop-arguments.png 1200w,https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/0d4f8/banana-cake-pop-arguments.png 1600w,https://chillicream.com/static/2279da65617387b53c7d8447c66fbcec/b2484/banana-cake-pop-arguments.png 2972w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>For our first query let us fetch the students with the <code>lastName</code> <code>Bar</code> or <code>Baz</code>.</p><pre><code class=\"language-graphql\">query {\n  students(where: { OR: [{ lastName: &quot;Bar&quot; }, { lastName: &quot;Baz&quot; }] }) {\n    firstMidName\n    lastName\n    enrollments {\n      course {\n        title\n      }\n    }\n  }\n}\n</code></pre><p>Which will return the following result:</p><pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;students&quot;: [\n      {\n        &quot;firstMidName&quot;: &quot;Pascal&quot;,\n        &quot;lastName&quot;: &quot;Bar&quot;,\n        &quot;enrollments&quot;: [\n          {\n            &quot;course&quot;: {\n              &quot;title&quot;: &quot;Object Oriented Programming 1&quot;\n            }\n          }\n        ]\n      },\n      {\n        &quot;firstMidName&quot;: &quot;Michael&quot;,\n        &quot;lastName&quot;: &quot;Baz&quot;,\n        &quot;enrollments&quot;: [\n          {\n            &quot;course&quot;: {\n              &quot;title&quot;: &quot;Object Oriented Programming 1&quot;\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre><p>Again, we are rewriting the whole GraphQL query into one expression tree that translates into the following SQL.</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;FirstMidName&quot;,\n       &quot;s&quot;.&quot;LastName&quot;,\n       &quot;s&quot;.&quot;Id&quot;,\n       &quot;t&quot;.&quot;Title&quot;,\n       &quot;t&quot;.&quot;EnrollmentId&quot;,\n       &quot;t&quot;.&quot;CourseId&quot;\n    FROM &quot;Students&quot; AS &quot;s&quot;\n    LEFT JOIN (\n        SELECT &quot;c&quot;.&quot;Title&quot;,\n               &quot;e&quot;.&quot;EnrollmentId&quot;,\n               &quot;c&quot;.&quot;CourseId&quot;,\n               &quot;e&quot;.&quot;StudentId&quot;\n        FROM &quot;Enrollments&quot; AS &quot;e&quot;\n        INNER JOIN &quot;Courses&quot; AS &quot;c&quot;\n              ON &quot;e&quot;.&quot;CourseId&quot; = &quot;c&quot;.&quot;CourseId&quot;\n    ) AS &quot;t&quot; ON &quot;s&quot;.&quot;Id&quot; = &quot;t&quot;.&quot;StudentId&quot;\n    WHERE (&quot;s&quot;.&quot;LastName&quot; = &#x27;Bar&#x27;) OR (&quot;s&quot;.&quot;LastName&quot; = &#x27;Baz&#x27;)\n    ORDER BY &quot;s&quot;.&quot;Id&quot;, &quot;t&quot;.&quot;EnrollmentId&quot;, &quot;t&quot;.&quot;CourseId&quot;\n</code></pre><p>But we can go further and even allow more. Let’s say we want to allow the consumer of our API to search for specific grades in our student’s enrolment list.</p><p>In order to allow filtering on the enrollments we can add the same <code>UseFiltering</code> attribute in our entity on the <code>Enrollments</code> collection and this property becomes filterable.</p><pre><code class=\"language-csharp\">public class Student\n{\n    [Key]\n    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n    public int Id { get; set; }\n    public string LastName { get; set; }\n    public string FirstMidName { get; set; }\n    public DateTime EnrollmentDate { get; set; }\n\n    [UseFiltering]\n    public virtual ICollection&lt;Enrollment&gt; Enrollments { get; set; }\n}\n</code></pre><p>We don`t need to apply <code>UseSelections</code> again. <code>UseSelections</code> really only has to be applied where the data is initially fetched. In this case we do only want to support filtering but no sorting on enrollments. I could again add both but decided to only use filtering here.</p><p>Let us restart our server and modify our query further.</p><pre><code class=\"language-bash\">dotnet run --urls http://localhost:5000\n</code></pre><p>For the next query we will get all students with the last name <code>Bar</code> that are enrolled in the course with the <code>courseId</code> <code>1</code>.</p><pre><code class=\"language-graphql\">query {\n  students(where: { lastName: &quot;Bar&quot; }) {\n    firstMidName\n    lastName\n    enrollments(where: { courseId: 1 }) {\n      courseId\n      course {\n        title\n      }\n    }\n  }\n}\n</code></pre><p>The following query translates again to a single SQL statement.</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;FirstMidName&quot;,\n       &quot;s&quot;.&quot;LastName&quot;,\n       &quot;s&quot;.&quot;Id&quot;,\n       &quot;t&quot;.&quot;CourseId&quot;,\n       &quot;t&quot;.&quot;Title&quot;,\n       &quot;t&quot;.&quot;EnrollmentId&quot;,\n       &quot;t&quot;.&quot;CourseId0&quot;\n    FROM &quot;Students&quot; AS &quot;s&quot;\n    LEFT JOIN (\n        SELECT &quot;e&quot;.&quot;CourseId&quot;,\n               &quot;c&quot;.&quot;Title&quot;,\n               &quot;e&quot;.&quot;EnrollmentId&quot;.\n               &quot;c&quot;.&quot;CourseId&quot; AS &quot;CourseId0&quot;,\n               &quot;e&quot;.&quot;StudentId&quot;\n        FROM &quot;Enrollments&quot; AS &quot;e&quot;\n        INNER JOIN &quot;Courses&quot; AS &quot;c&quot;\n              ON &quot;e&quot;.&quot;CourseId&quot; = &quot;c&quot;.&quot;CourseId&quot;\n        WHERE &quot;e&quot;.&quot;CourseId&quot; = 1\n    ) AS &quot;t&quot; ON &quot;s&quot;.&quot;Id&quot; = &quot;t&quot;.&quot;StudentId&quot;\n    WHERE &quot;s&quot;.&quot;LastName&quot; = &#x27;Bar&#x27;\n    ORDER BY &quot;s&quot;.&quot;Id&quot;, &quot;t&quot;.&quot;EnrollmentId&quot;, &quot;t&quot;.&quot;CourseId0&quot;\n</code></pre><p>With filtering and sorting we infer complex filters from our models without almost any code. This allows us to query our data with complex expressions while drilling into the data graph.</p><p>Hot Chocolate supports complex expressions with a variety of query operators that can be enabled by just adding a simple attribute on your field resolver. We can also configure the filter capabilities which we want to allow. This means you can for instance disallow <code>OR</code> combinations of filter clauses.</p><h2>Paging</h2><p>But we still might get too much data back. What if we select all the students from a real university database? This is where our paging middleware comes in. The paging middleware implements the relay cursor pagination spec.</p><blockquote><p>Since we cannot do a skip while with <em>Entity Framework</em>, we actually use an indexed based pagination underneath. For convenience we are wrapping this as really cursor pagination. With mongoDB and other database provider we are supporting real cursor based pagination.</p></blockquote><p>Like with filtering, sorting and selection we just annotate the paging middleware and it just works. Again, middleware order is important, so we need to put the paging attribute on the top since the most top field middleware is actually applied last like shown in the diagram.</p><pre><code class=\"language-csharp\">using System.Linq;\nusing HotChocolate;\nusing HotChocolate.Types;\nusing HotChocolate.Types.Relay;\n\nnamespace ContosoUniversity\n{\n    public class Query\n    {\n        [UsePaging]\n        [UseSelection]\n        [UseFiltering]\n        [UseSorting]\n        public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext context) =&gt;\n            context.Students;\n    }\n}\n</code></pre><p>Since paging adds metadata for pagination like a <code>totalCount</code> or a <code>pageInfo</code> the actual result structure now changes. Also, the paging middleware adds arguments to our field that we need to navigate between pages.</p><p>Our <code>students</code> field now returns a <code>StudentConnection</code> which allows us to either fetch the actual <code>Student</code> nodes of the current page or to ask for the pagination metadata.</p><p>We could in fact just fetch the <code>totalCount</code> of our data set.</p><pre><code class=\"language-graphql\">query {\n  students(first: 1) {\n    totalCount\n  }\n}\n</code></pre><p>Which would again translate to a simple SQL.</p><pre><code class=\"language-sql\">SELECT 1 FROM &quot;Students&quot; AS &quot;s&quot;\n</code></pre><p>Next let us just fetch the <code>lastName</code> of the first student.</p><pre><code class=\"language-graphql\">query {\n  students(first: 1) {\n    nodes {\n      lastName\n    }\n  }\n}\n</code></pre><p>Which translates to a simple limit query for <em>SQLLite</em>.</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;LastName&quot;\n    FROM &quot;Students&quot; AS &quot;s&quot;\n    LIMIT @__p_0\n</code></pre><p>In order to navigate forward through pages we also need to get data from our <code>pageInfo</code> like if there is a next page and the last cursor of the current page.</p><pre><code class=\"language-graphql\">query {\n  students(first: 1) {\n    nodes {\n      lastName\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n  }\n}\n</code></pre><pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;students&quot;: {\n      &quot;nodes&quot;: [\n        {\n          &quot;lastName&quot;: &quot;Foo&quot;\n        }\n      ],\n      &quot;pageInfo&quot;: {\n        &quot;hasNextPage&quot;: true,\n        &quot;endCursor&quot;: &quot;eyJfX3RvdGFsQ291bnQiOjMsIl9fcG9zaXRpb24iOjB9&quot;\n      }\n    }\n  }\n}\n</code></pre><p>With the <code>endCursor</code> of a page we can get the next page that comes after the <code>endCursor</code> by feeding the <code>endCursor</code> into the <code>after</code> argument.</p><pre><code class=\"language-graphql\">query {\n  students(first: 1, after: &quot;eyJfX3RvdGFsQ291bnQiOjMsIl9fcG9zaXRpb24iOjB9&quot;) {\n    nodes {\n      lastName\n    }\n    pageInfo {\n      hasNextPage\n      endCursor\n    }\n  }\n}\n</code></pre><pre><code class=\"language-json\">{\n  &quot;data&quot;: {\n    &quot;students&quot;: {\n      &quot;nodes&quot;: [\n        {\n          &quot;lastName&quot;: &quot;Bar&quot;\n        }\n      ],\n      &quot;pageInfo&quot;: {\n        &quot;hasNextPage&quot;: true,\n        &quot;endCursor&quot;: &quot;eyJfX3RvdGFsQ291bnQiOjMsIl9fcG9zaXRpb24iOjF9&quot;\n      }\n    }\n  }\n}\n</code></pre><p>This will then be translated into simple offset navigation when using <em>Entity Framework</em>.</p><pre><code class=\"language-sql\">SELECT &quot;s&quot;.&quot;LastName&quot;\n    FROM &quot;Students&quot; AS &quot;s&quot;\n    ORDER BY (SELECT 1)\n    LIMIT @__p_0 OFFSET @__p_0\n</code></pre><p>Again, without a lot of effort we were able to create a powerful GraphQL server with advanced filter and pagination capabilities by just writing basically one line of code with lots of attributes on top of that.</p><pre><code class=\"language-csharp\">using System.Linq;\nusing HotChocolate;\nusing HotChocolate.Types;\nusing HotChocolate.Types.Relay;\n\nnamespace ContosoUniversity\n{\n    public class Query\n    {\n        [UsePaging]\n        [UseSelection]\n        [UseFiltering]\n        [UseSorting]\n        public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext context) =&gt;\n            context.Students;\n    }\n}\n</code></pre><p>Each request in GraphQL translates into native SQL. Whenever possible we translate it into a single SQL request reducing the need to fetch multiple times from the database.</p><h2>Single Selects</h2><p>We still can improve our query and allow to explore the data from different angles.</p><pre><code class=\"language-csharp\">using System.Linq;\nusing HotChocolate;\nusing HotChocolate.Types;\nusing HotChocolate.Types.Relay;\n\nnamespace ContosoUniversity\n{\n    public class Query\n    {\n        [UsePaging]\n        [UseSelection]\n        [UseFiltering]\n        [UseSorting]\n        public IQueryable&lt;Student&gt; GetStudents([Service]SchoolContext context) =&gt;\n            context.Students;\n\n        [UsePaging]\n        [UseSelection]\n        [UseFiltering]\n        [UseSorting]\n        public IQueryable&lt;Course&gt; GetCourses([Service]SchoolContext context) =&gt;\n            context.Courses;\n    }\n}\n</code></pre><p>With the above code we can now drill into the data from both sides. In order to get an even nicer API, we might also want to allow dedicated fetches maybe for a <code>Student</code> by the student ID.</p><p>We could do something like the following and it would work.</p><pre><code class=\"language-csharp\">public Task&lt;Student&gt; GetStudentByIdAsync([Service]SchoolContext context, int studentId) =&gt;\n    context.Students.FirstOrDefaultAsync(t =&gt; t.Id == studentId);\n</code></pre><p>If we did something like that with <em>Entity Framework</em> we actually would need to write a couple more resolvers to fetch the edges of the entity like the <code>Enrollments</code> since with this resolver there is no middleware that does the hard work for us. With the resolver above we are fully in control of the data fetching.</p><p>Also doing it like that will lead into other problems since now we are causing multiple fetches to the database and we would no need to think about things like <code>DataLoader</code> to guarantee consistency between fetches in a single request.</p><p>But we actually have a simple solution for this since we could use our selection middleware still and just tell the middleware pipeline that we actually just want a single result for that resolver.</p><p>Let us rewrite the above resolver and look at it again.</p><pre><code class=\"language-csharp\">[UseFirstOrDefault]\n[UseSelection]\npublic IQueryable&lt;Student&gt; GetStudentById([Service]SchoolContext context, int studentId) =&gt;\n    context.Students.Where(t =&gt; t.Id == studentId);\n</code></pre><p>This now looks like the initial resolvers that we wrote to fetch all students. We predefined the where clause and we added a new middleware called <code>UseFirstOrDefault</code>. The <code>UseFirstOrDefault</code> middleware will rewrite the result type for the GraphQL schema from <code>[Student]</code> to <code>Student</code> and ensure the we will only fetch a single entity from the database.</p><p><code>UseFirstOrDefault</code> from a semantics perspective aligns to <code>FirstOrDefaultAsync</code> provided by the <em>Entity Framework</em>. Hot Chocolate also provides you with a <code>UseSingleOrDefault</code> middleware that will produce a GraphQL field error whenever there is more than one result.</p><h2>Conclusion and Outlook</h2><p>Hot Chocolate has a powerful execution model that allows to natively integrate with data sources of any kind.</p><p>The middleware that we showed you here like <code>UseSelection</code> or <code>UseFiltering</code> etc. do not only work with <em>Entity Framework</em> but also support other providers that support <code>IQueryable&lt;T&gt;</code> to express database queries.</p><p>But even if you want to support native SQL without <code>IQueryable&lt;T&gt;</code> it is super simple to inherit from our query rewriter base classes and and add this translation.</p><p>By just implementing such a query rewriter you are creating a native database provider for Hot Chocolate that integrates fully with the query engine.</p><p>We also support the full features shown here with multiple other approaches like code-first with schema types or SDL first.</p><p>With version 11 we are introducing a new more powerful query engine that will provide full query execution plan support. Version 11 will have even better filters and push what we showed here today to the limit.</p><p>The example used in this post can be found <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/blog/2020/2020-03-18-entity-framework/ContosoUni\">here</a>.</p><p>We also have a more complex real-time GraphQL server example in multiple flavors and different database integrations <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/workshop/src/Server\">here</a>.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2020/03/18/entity-framework",
            "title": "Get started with Hot Chocolate and Entity Framework",
            "summary": "In this post I will walk you through how to build a GraphQL Server using Hot Chocolate and  Entity Framework . Entity Framework  is an OR…",
            "image": "https://chillicream.com/static/1187c5d634010aea953e8fcc1ebbfdb8/0514f/banner-entityframework.png",
            "date_modified": "2020-03-18T00:00:00.000Z",
            "date_published": "2020-03-18T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/12/26/hot-chocolate-10.3.0",
            "content_html": "<p>Today we are releasing Hot Chocolate version 10.3.0. Although the version number sounds like a small change, it is quite a nice update with lots of new features making Hot Chocolate the most versatile and feature rich GraphQL server on the .NET platform.</p><p>We are now working for a long time on version 11. Work on that has begun long before version 10.0.0 was finished. As we progressed with version 11, we felt that we could push some nice productivity features down to the version 10 branch and make users of Hot Chocolate much happier.</p><p>This decision culminated in version 10.3.0 and it really feels like a major update with an array of new possibilities that will make you smile.</p><p>With version 10.3.0 we are introducing a new code-first variant which we internally call <em>pure code-first</em>.</p><p>We now really can for the first time build a fully-fledged GraphQL server just with C#.</p><blockquote><p>If you want to see how the Star Wars example looks like with the new 10.3.0 and <em>pure code-first</em> then head over <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/PureCodeFirst\">here</a>.</p></blockquote><p>Let`s dive into the features and explore what we can do with the newest version of Hot Chocolate.</p><h2>Nullability</h2><p>The first feature that I want to introduce is C# 8 nullable reference type support.</p><p>With previous versions of C# we always had the problem that C# had only nullable reference types, hence we had to give our classes always some extra context to be able to infer non-null GraphQL types.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    [GraphQLNonNull]\n    public string SayHello(string name)\n    {\n        return name is null ? &quot;Hello!&quot; : $&quot;Hello {name}!&quot;\n    }\n}\n</code></pre><p>It is needless to say that we also could do that with our schema types.</p><pre><code class=\"language-csharp\">public class QueryType : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;Query&gt; descriptor)\n    {\n        descriptor.Field(t =&gt; t.SayHello(default)).Type&lt;NonNullType&lt;StringType&gt;&gt;();\n    }\n}\n</code></pre><p>With C# 8.0 <em>Microsoft</em> introduced a new language feature called nullable reference types that allows us to define when reference types can be null.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    public string SayHello(string? name)\n    {\n        return name is null ? &quot;Hello!&quot; : $&quot;Hello {name}!&quot;\n    }\n}\n</code></pre><p>When activated either setting the <em>MSBuild</em> property <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> or by adding a preprocessor directive <code>#nullable enable</code> Hot Chocolate will automatically infer the nullability of GraphQL types from the corresponding .NET types.</p><p>Hence the above class is now correctly inferred and translates nicely into GraphQL types.</p><pre><code class=\"language-graphql\">type Query {\n  &quot;This field says hello.&quot;\n  sayHello(name: String): String!\n}\n</code></pre><h2>Descriptor Attributes</h2><p>One big issue that we still saw with <em>pure code-first</em> was how people should apply middleware to their fields. This was for a long time a roadblock for us in making this experience more powerful and easy to use.</p><p>Our solution to this are descriptor attributes which act as a kind of an interceptor into the inferred schema type. This allows users to create their own attributes in an easy way and with all the power that is available through the schema type APIs.</p><pre><code class=\"language-csharp\">public sealed class ToUpperAttribute : ObjectFieldDescriptorAttribute\n{\n    protected override void OnConfigure(\n        IDescriptorContext context,\n        IObjectFieldDescriptor descriptor,\n        MemberInfo member)\n    {\n        descriptor.Use(next =&gt; async ctx =&gt;\n        {\n            await next(ctx);\n\n            if(ctx.Result is string s)\n            {\n                ctx.Result = s.ToUpperInvariant();\n            }\n        })\n    }\n}\n</code></pre><p>The attributes very cleanly package all the logic for a middleware or other configuration aspects. This makes it very easy to use. By just applying an attribute to a class, property, method or any other member kind we can add completely new functionality to that specific element or even completely reconfigure it.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    [ToUpper]\n    public string SayHello(string? name)\n    {\n        return name is null ? &quot;Hello!&quot; : $&quot;Hello {name}!&quot;\n    }\n}\n</code></pre><p>We have created attribute base classes for all the important descriptors.</p><ul><li>EnumTypeDescriptorAttribute</li><li>EnumValueDescriptorAttribute</li><li>InputObjectTypeDescriptorAttribute</li><li>InputFieldDescriptorAttribute</li><li>InterfaceTypeDescriptorAttribute</li><li>InterfaceFieldDescriptorAttribute</li><li>ObjectTypeDescriptorAttribute</li><li>ObjectFieldDescriptorAttribute</li><li>ArgumentDescriptorAttribute</li><li>UnionTypeDescriptorAttribute</li></ul><p>But sometimes we even want to drill deeper with attributes and use a single attribute with multiple descriptors.</p><p>Maybe we only want to apply arguments through an attribute to a field if the field is on an interface.</p><pre><code class=\"language-csharp\">public interface IFoo\n{\n    [UseOffsetPaging]\n    IQueryable&lt;IFoo&gt; GetFoos();\n}\n</code></pre><pre><code class=\"language-graphql\">interface Foo {\n  foos(skip: Int, take: Int): [Foo!]!\n}\n</code></pre><p>But if the same attribute is applied to an object field then we might also want to apply a middleware that adds some cross-cutting functionality to it like a paging algorithm.</p><pre><code class=\"language-csharp\">public interface Bar : IFoo\n{\n    [UseOffsetPaging]\n    IQueryable&lt;IFoo&gt; GetFoos();\n}\n</code></pre><pre><code class=\"language-graphql\">type Bar implements Foo {\n  foos(skip: Int, take: Int): [Foo!]!\n}\n</code></pre><p>For this we can use the attribute base class <code>DescriptorAttribute</code>.</p><pre><code class=\"language-csharp\">public sealed class UseOffsetPagingAttribute : DescriptorAttribute\n{\n    protected internal override void TryConfigure(\n        IDescriptorContext context,\n        IDescriptor descriptor,\n        ICustomAttributeProvider element)\n    {\n        if (element is MemberInfo m)\n        {\n            if (descriptor is IObjectFieldDescriptor ofd)\n            {\n                // do something\n            }\n            else if (descriptor is IInterfaceFieldDescriptor ifd)\n            {\n                // do something\n            }\n        }\n    }\n}\n</code></pre><p>The <code>TryConfigure</code> method passes in the <code>IDescriptorContext</code> which provides us access to conventions and other services. Also, we have access to the <code>descriptor</code> that is associated with the annotated element. Additionally the <code>element</code> to which the attribute is annotated to is also passed in.</p><p>With this it is very easy to probe for different cases and build complex functionality in a simple attribute that is easy to use by others.</p><p>Last but not least we also have added a set of built-in attributes for paging, filtering, sorting and authorization.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    [Authorize(Policy = &quot;MyPolicy&quot;)]\n    [UsePaging]\n    [UseFiltering]\n    [UseSorting]\n    public IQueryable&lt;Customer&gt; GetCustomers()\n    {\n        ...\n    }\n}\n</code></pre><p>The attributes can be chained just like with the fluent API. The above code would translate into the following schema type.</p><pre><code class=\"language-csharp\">public class QueryType : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor descriptor)\n    {\n        descriptor.Field(t =&gt; t.GetCustomers())\n            .Description(&quot;This field says hello.&quot;)\n            .Authorize(&quot;MyPolicy&quot;)\n            .UsePaging&lt;ObjectType&lt;Customer&gt;&gt;()\n            .UseFiltering()\n            .UseSorting();\n    }\n}\n</code></pre><h2>Type Attributes</h2><p>Another issue that we had was telling the schema builder that we want to force types to bind as specific GraphQL type.</p><p>A class for instance is automatically inferred as an object type when the type is discovered in an output context. But a <code>struct</code> on the other hand is not automatically inferred if it is not mapped as a scalar since it could become quite messy with distinguishing if a <code>struct</code> should become a scalar or an object type or an input object type.</p><p>For this problem we have created a special set of descriptor attributes that mark the .NET type as a specific GraphQL type.</p><pre><code class=\"language-csharp\">[ObjectType(Name = &quot;QueryRoot&quot;)]\npublic struct Query\n{\n    public string Foo =&gt; &quot;Foo&quot;;\n}\n</code></pre><p>The same would work if we wanted to enforce that an abstract base class for instance becomes an interface or even a union type. It is important that the context in which this type is discovered also matters. So, one type could translate into an input type and an output type at the same time.</p><pre><code class=\"language-csharp\">public class Query\n{\n    public Foo GetFoo(Foo foo) =&gt; foo;\n}\n\npublic class Foo\n{\n    public string Bar { get; set; }\n}\n</code></pre><p>The above example would automatically translate into a GraphQL schema where <code>Foo</code> would be represented by two types in the GraphQL schema.</p><pre><code class=\"language-graphql\">type Query {\n  foo(input: FooInput): Foo\n}\n\ntype Foo {\n  bar: String\n}\n\ninput FooInput {\n  bar: String\n}\n</code></pre><p>OK, it starts to feel quite nice :)</p><p>But still we are not there yet.</p><p>When people start building big APIs, they tend to want to split up types. The most asked question on our slack channel is how to split up the query type.</p><p>With SDL-first and our traditional code-first approach this is as easy as eating pie since we can write type extensions.</p><p>So, we added for 10.3.0 the ability to also split up types with the <em>pure code-first</em> approach.</p><p>Let`s say we have a query type and we want to divide this up into logical units. We could add a bodiless query type by either adding an empty class to our <code>SchemaBuilder</code> or by using a schema type.</p><p><strong>Approach 1 - Empty Class</strong></p><pre><code class=\"language-csharp\">public class Query\n{\n}\n\nSchemaBuilder.New()\n    .AddQueryType&lt;Query&gt;()\n    ...\n</code></pre><p><strong>Approach 2 - Schema Type</strong></p><pre><code class=\"language-csharp\">public class Query : ObjectType\n{\n    protected override void Configure(IObjectTypeDescriptor descriptor)\n    {\n        descriptor.Name(&quot;Query&quot;);\n    }\n}\n\nSchemaBuilder.New()\n    .AddQueryType&lt;QueryType&gt;()\n    ...\n</code></pre><p>Next we could create standard C# classes to extend on the query type. We can divide our type into as many classes as we want. Also, since each class is independent we could for instance have extra query fields during development time by just adding an extension class on dev to our schema builder and on prod we could leave that away.</p><pre><code class=\"language-csharp\">[ExtendObjectType(Name = &quot;Query&quot;)]\npublic class FooQueries\n{\n    public string Hello() =&gt; &quot;abc&quot;;\n}\n\nSchemaBuilder.New()\n    .AddQueryType&lt;QueryType&gt;()\n    .AddType&lt;FooQueries&gt;()\n    .Create();\n</code></pre><p>The above code would result in the following schema:</p><pre><code class=\"language-graphql\">type Query {\n  hello: String\n}\n</code></pre><p>Object type extensions let us divide our GraphQL types into multiple .NET types. This lets us be more flexible in building our API. Moreover, we can divide our query type into logical units and test them independently from each other. We can do that by just writing a clean C# class that only really would need one attribute to mark it as an extension.</p><h2>Interfaces</h2><p>Hot Chocolate is able to infer interface types from C# APIs since version 10.0.0. But now with the new capabilities of Hot Chocolate in 10.3.0 this becomes a really great feature.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// Get my pet :)\n    /// &lt;/summary&gt;\n    public IPet? GetPet(int id)\n    {\n        // some code\n    }\n}\n\npublic interface IPet\n{\n    // some code\n}\n\npublic class Dog : IPet\n{\n    // some code\n}\n\npublic class Cat : IPet\n{\n    // some code\n}\n\nSchemaBuilder.New()\n    .AddQuery&lt;Query&gt;()\n    .AddType&lt;Dog&gt;()\n    .AddType&lt;Cat&gt;()\n    .Create();\n</code></pre><pre><code class=\"language-graphql\">type Query {\n  &quot;Get my pet :)&quot;\n  pet(id: Int!): IPet\n}\n\ninterface Pet {\n    // fields\n}\n\ntype Dog implements Pet {\n    // fields\n}\n\ntype Cat implements Pet {\n    // fields\n}\n</code></pre><p>This feels awesome. The schema builder translates our C# types exactly the way we meant them into a clean GraphQL schema. We do not have to write all those schema types anymore. We just write clean C# code and let the schema builder handle the rest.</p><blockquote><p>It is important to know that we still can use schema types. Also, we can mix our approach, for instance we could use schema types in situations where we do not want to add attributes to our types.</p></blockquote><h2>Optional</h2><p>Another concept we are introducing with 10.3.0 is optional on input object types. We are planning to use optional even more with version 11 but with 10.3.0 you can use them on input object types in order to distinguish between <strong>not set</strong> and <strong>null</strong>.</p><pre><code class=\"language-csharp\">public class Foo\n{\n    public Optional&lt;string&gt; Bar { get; set; }\n}\n</code></pre><p>The important thing with optional is that they implicitly convert to the type specified as type parameter. This means that the following is valid code:</p><pre><code class=\"language-csharp\">var foo = new Foo { Bar = &quot;ABCDEF&quot; };\nstring fooValue = foo.Bar;\n</code></pre><p>But we also can now distinguish between <strong>not set</strong> and <strong>null</strong> since we can ask the optional if it has a value.</p><pre><code class=\"language-csharp\">var foo = new Foo { Bar = &quot;ABCDEF&quot; };\nif(foo.Bar.HasValue)\n{\n    // property was set.\n}\n</code></pre><p>Optional in 10.3.0 only work on properties of input objects meaning we cannot use them on output types. With 10.3.0 the execution engine has no knowledge about optional at all.</p><p>Also, we cannot use optional on arguments in the way that we could ask the context for an optional like the following:</p><pre><code class=\"language-csharp\">context.Argument&lt;Optional&lt;string&gt;&gt;(&quot;foo&quot;);\n</code></pre><p>We will introduce this with the upcoming version 11 release. We decided to not change the execution engine to much with 10.3.0 since we are doing a lot of work on the execution engine with version 11.</p><p>Another caveat here is that if you are using <code>Optional&lt;T&gt;</code> on a property, the property cannot have a default value. This is also one thing we will change with version 11.</p><p>Still, optional can help already in version 10.3.0 with some scenarios and with version 11 we will go all the way to make this an awesome addition.</p><h2>Type Extensions</h2><p>For the last few paragraphs I only talked about the <em>pure code-first</em> approach but we actually also added a new feature to the schema types (aka <em>code-first</em> approach).</p><p>For a long time now, we can extend types or break types up into multiple parts.</p><pre><code class=\"language-csharp\">public class FooExtension : ObjectTypeExtension\n{\n    protected override void Configure(ObjectTypeDescriptor descriptor)\n    {\n        descriptor.Name(&quot;Foo&quot;);\n        descriptor.Field&lt;Foo&gt;(t =&gt; t.Bar).Use(...);\n        descriptor.Field(&quot;baz&quot;).Use(...);\n    }\n}\n</code></pre><p>But the type extension until now did not allow to specify an underlying model. With 10.3.0 we now allow you to specify any type extension with a generic type parameter.</p><pre><code class=\"language-csharp\">public class FooExtension : ObjectTypeExtension&lt;Foo&gt;\n{\n    protected override void Configure(ObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.Name(&quot;Foo&quot;);\n        descriptor.Field(t =&gt; t.Bar).Use(...);\n    }\n}\n</code></pre><h2>Immutable Input Objects</h2><p>We are not done yet :) There are still more features on 10.3.0.</p><p>Another feature we have integrated into the input object types is support for immutable input objects. This becomes important when working with C# 8.0 and nullable reference types.</p><p>With version 10.3.0 we can now specify immutable classes like the following one as input object.</p><pre><code class=\"language-csharp\">public class ImmutableFoo\n{\n    public ImmutableFoo(string bar)\n    {\n        Bar = bar;\n    }\n\n    public string Bar { get; }\n}\n</code></pre><p>If we use the above class as input object the type can deserialize or parse it correctly by using the constructor instead of setting the properties.</p><p>Also supported is to use the constructor just for non-null reference types like the following:</p><pre><code class=\"language-csharp\">public class Foo\n{\n    public Foo(string bar)\n    {\n        Bar = bar;\n    }\n\n    public string Bar { get; set; }\n\n    public string? Baz { get; set; }\n}\n</code></pre><h2>Subscriptions</h2><p>Last but not least we did some work to make subscriptions easier and allow people to leverage the power of async streams.</p><p>If you are happy with subscriptions today, you do not need to change anything.</p><p>But if you want to easily hook up Azure ServiceBus or stream something over what ever, then this has become super simple with the new subscribe resolver.</p><pre><code class=\"language-csharp\">public class SubscriptionType : ObjectType\n{\n    protected override void Configure(ObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.Field(&quot;foo&quot;)\n            .Subscribe(async ctx =&gt;\n            {\n                async foreach(var payload in await serviceBus.OnMessageReceiveAsync())\n                {\n                    yield return payload;\n                }\n            })\n            ...\n    }\n}\n</code></pre><p>You also can bind the subscribe resolver like any other resolver to an underlying method.</p><pre><code class=\"language-csharp\">public class SubscriptionType : ObjectType&lt;Subscription&gt;\n{\n    protected override void Configure(ObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor\n            .Field(t =&gt; t.GetMessageAsync())\n            .Subscribe(t =&gt; t.OnReceiveMessage())\n            ...\n    }\n}\n</code></pre><p>The subscribe resolvers accepts <code>IAsyncEnumerable&lt;T&gt;</code>, <code>IEnumerable&lt;T&gt;</code> and <code>IObservable&lt;T&gt;</code> as result.</p><h2>Wrapping it up</h2><p>With Hot Chocolate 10.3.0 we focused on productivity features that have a minor impact on the overall system. This means that we enable a whole bunch of new scenarios with the current Hot Chocolate server generation.</p><p>With version 11 we will take this to a whole new level with a completely new execution engine that is much more efficient and allows for completely new features like <code>@defer</code>.</p><p>Also, version 11 will introduce new tools and libraries to the platform like <em>Banana Cakepop</em> (preview dropping very soon), <em>Strawberry Shake</em> or our new <em>Visual Studio for Windows Integration</em>.</p><p>We have a lot more in our pipeline and are totally obsessed with GraphQL and .NET.</p><p>I hope you will enjoy 10.3.0 as much as I already do and join the Hot Chocolate fold.</p><p>BTW, head over to our <em>pure code-first</em> <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/PureCodeFirst\">Star Wars example</a>.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2019/12/26/hot-chocolate-10.3.0",
            "title": "GraphQL - Hot Chocolate 10.3.0",
            "summary": "Today we are releasing Hot Chocolate version 10.3.0. Although the version number sounds like a small change, it is quite a nice update with…",
            "image": "https://chillicream.com/static/7be2244f6a40210dca5845da740253e6/0514f/hotchocolate-banner.png",
            "date_modified": "2019-12-26T00:00:00.000Z",
            "date_published": "2019-12-26T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/11/29/schema-design",
            "content_html": "<p>When you think about how we build our GraphQL schemas with Hot Chocolate we always need to fall back to either the schema types or the GraphQL SDL in order to get the typings right.</p><p>This brings with it a lot of boiler plate code that we actually could infer from our C# code. With version 10.3.0 we have decided to integrate some of the version 11 features to make it possible to have these capabilities now instead of next year.</p><h2>Nullability</h2><p>First, let us get the obvious out of the way. C# with version 8.0 has now nullable reference types, or actually they now have non-null reference types.</p><p>It does not matter how you look at it, but the result is that we now can differentiate between nullable reference types and reference types that cannot be null.</p><p>With version 10.3.0-preview.2 we can infer these, and you finally do not need helpers like attributes and other things to define your schema types with non-null types.</p><p>A simple query like ...</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    public string SayHello(string? name)\n    {\n        return name is null ? &quot;Hello!&quot; : $&quot;Hello {name}!&quot;\n    }\n}\n</code></pre><p>... is now correctly inferred to:</p><pre><code class=\"language-graphql\">type Query {\n  &quot;This field says hello.&quot;\n  sayHello(name: String): String!\n}\n</code></pre><p>Do not get me wrong here, I still love our schema types and we will not get rid of them since they are the foundation of every schema. We still are using them in the above example, you just do not need to see them anymore. Moreover, we see these improvements more as an additional way to define a GraphQL schemas with pure C# types.</p><p>In the beginning we decided that people should be free in their way of how they want to define their schemas. We are still 100% committed to SDL first, code-first with schema types and code-first with pure C# types.</p><h2>Interfaces</h2><p>Since version 10.0.0 Hot Chocolate is able to infer interface types from API usage. This means that we will correctly infer the interfaces that you use and the types that implement those interfaces.</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// Get my pet :)\n    /// &lt;/summary&gt;\n    public IPet? GetPet(int id)\n    {\n        // some code\n    }\n}\n\npublic interface IPet\n{\n    // some code\n}\n\npublic class Dog : IPet\n{\n    // some code\n}\n\npublic class Cat : IPet\n{\n    // some code\n}\n\nSchemaBuilder.New()\n    .AddQuery&lt;Query&gt;()\n    .AddType&lt;Dog&gt;()\n    .AddType&lt;Cat&gt;()\n    .Create();\n</code></pre><pre><code class=\"language-graphql\">type Query {\n  &quot;Get my pet :)&quot;\n  pet(id: Int!): IPet\n}\n\ninterface Pet {\n    // fields\n}\n\ntype Dog implements Pet {\n    // fields\n}\n\ntype Cat implements Pet {\n    // fields\n}\n</code></pre><p>This feels awesome. The schema builder translates our C# types exactly the way we meant them. We do not have to tell the schema builder any more how to do that it will just work.</p><h2>Descriptor Attributes</h2><p>But what about field middleware and other more complex features like type extensions and so on.</p><p>This was something we contemplated for a long time. In the end we came up with powerful descriptor attributes. This basically allows you to create attributes for your schema in which you have access to the full descriptor API. Let me give you an example for this.</p><p>Let us say we want to create a simple middleware that can be put on properties and methods and that applies a <code>ToUpper</code> on every resulting <code>string</code> on the annotated member.</p><pre><code class=\"language-csharp\">public sealed class ToUpperAttribute : ObjectFieldDescriptorAttribute\n{\n    protected override void OnConfigure(IObjectFieldDescriptor descriptor)\n    {\n        descriptor.Use(next =&gt; async ctx =&gt;\n        {\n            await next(ctx);\n\n            if(ctx.Result is string s)\n            {\n                ctx.Result = s.ToUpperInvariant();\n            }\n        })\n    }\n}\n</code></pre><p>The neat thing is that we have full access to all the things we have on our fluent API. The attributes very cleanly packages all the logic and makes it very easy applicable. By just applying an attribute to a property or method I can add huge functionality to that member (resolver).</p><pre><code class=\"language-csharp\">public class Query\n{\n    /// &lt;summary&gt;\n    /// This field says hello.\n    /// &lt;/summary&gt;\n    [ToUpper]\n    public string SayHello(string? name)\n    {\n        return name is null ? &quot;Hello!&quot; : $&quot;Hello {name}!&quot;\n    }\n}\n</code></pre><p>This allows us to enable the full power of schema types with pure C# types. The new attributes will arrive with 10.3.0-preview.3 probably on Monday.</p><p>We will add attributes for each descriptor type. Moreover, you can apply input and output attributes on the same type, and we will create automatically an output- and an input-version of that type.</p><p>We will also provide attributes for all our middleware like paging, filtering, sorting and authorization. So, you will have the full power of Hot Chocolate even when you do not use our schema type directly.</p><blockquote><p>I really love this feature :)</p></blockquote><h2>Type Extensions</h2><p>Another thing we want to make better with 10.3.0 are the code-first type extensions. You could already do cool things with the type extensions but there are two things that did not feel nice enough.</p><p>First, we did not have a generic type extension type. This means that defining fields can sometimes be a pain. We had to either declare fields and provide the declaring type with them or we had to specify the field with a string name.</p><pre><code class=\"language-csharp\">public class FooExtension : ObjectTypeExtension\n{\n    protected override void Configure(ObjectTypeDescriptor descriptor)\n    {\n        descriptor.Name(&quot;Foo&quot;);\n        descriptor.Field&lt;Foo&gt;(t =&gt; t.Bar).Use(...);\n        descriptor.Field(&quot;baz&quot;).Use(...);\n    }\n}\n</code></pre><p>With the new version we can now basically do the same than we do with standard types by providing a type parameter:</p><pre><code class=\"language-csharp\">public class FooExtension : ObjectTypeExtension&lt;Foo&gt;\n{\n    protected override void Configure(ObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.Name(&quot;Foo&quot;);\n        descriptor.Field(t =&gt; t.Bar).Use(...);\n    }\n}\n</code></pre><p>The second thing that is sometimes good and other times bad is that we have to provide an name. With 10.3.0 we first of all can now infer the type from the mode.</p><p>You also can just type in the name like before. Or you provide as with the type that you want to actually extend.</p><pre><code class=\"language-csharp\">public class FooExtension : ObjectTypeExtension&lt;Foo&gt;\n{\n    protected override void Configure(ObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.Extend&lt;FooType&gt;()\n        descriptor.Field(t =&gt; t.Bar).Use(...);\n    }\n}\n</code></pre><h2>Optional</h2><p>Another concept we will introduce with 10.3.0 is optionals. This is often a thing we want to use when we are talking about input types. We have introduced this concept already with <em>Strawberry Shake</em> and like it a lot.</p><p>So, we are porting it now back to the server. In your resolvers you can now use for every argument the optional wrapper type and this will tell you if the argument was not provided. This will allow you to easily do partial updates. We could do partial updates before but not as elegant as now. With version 11 we will improve on that by having a nice patch type.</p><pre><code class=\"language-csharp\">public async Task&lt;Foo&gt; GetMyFoo(Optional&lt;string&gt; id)\n{\n    // ...\n}\n</code></pre><p>Also you can use optionals in input objects.</p><pre><code class=\"language-csharp\">public class Foo\n{\n    public Optional&lt;string&gt; Bar { get; set; }\n}\n</code></pre><p>The nice thing with the inputs are that they implicitly convert.</p><pre><code class=\"language-csharp\">var foo = new Foo { Bar = &quot;My String&quot; };\n</code></pre><h2>Wrapping it up</h2><p>Hot Chocolate 10.3.0 will bring a lot new improvements to how we can create GraphQL schemas. All these changes are just additions and there are no breaking changes involved meaning we give you a lot of version 11 productivity improvements now.</p><p>So, when can you expect 10.3.0. We will deliver nullable ref types with 10.3.0-preview.2 (tonight) and the attributes will come 10.3.0-preview.3. We think the final version should be ready end of next week. We initially planned end of this week but we still have some bug fixing to do.</p><p>I hope you are as exited as I am about this. Happy Thanksgiving :) and get a super awesome Hot Chocolate with marshmallows to get into your GraphQL groove.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2019/11/29/schema-design",
            "title": "Lets supercharge your GraphQL schema :)",
            "summary": "When you think about how we build our GraphQL schemas with Hot Chocolate we always need to fall back to either the schema types or the…",
            "image": "https://chillicream.com/static/7be2244f6a40210dca5845da740253e6/0514f/hotchocolate-banner.png",
            "date_modified": "2019-11-29T00:00:00.000Z",
            "date_published": "2019-11-29T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/11/25/strawberry-shake_2",
            "content_html": "<p>We are busy, busy, busy working on version 11 of Hot Chocolate and <em>Strawberry Shake</em>.</p><p>In this post I want to explore the client side of GraphQL on .NET more with a special emphasis on subscriptions.</p><p>Since, with the new version of <em>Strawberry Shake</em> our initial blog has become kind of invalid I also will walk you trough the basics again before heading into subscriptions and what lies beyond.</p><h2>Getting Started</h2><p>Let us have a look at how we want to tackle things with <em>Strawberry Shake</em>. For this little walk-through I will use our <a href=\"https://github.com/ChilliCream/hotchocolate/tree/master/examples/AspNetCore.StarWars\"><em>Star Wars</em> server example</a>.</p><p>If you want to follow along then install the <a href=\"https://dotnet.microsoft.com/download/dotnet-core/3.0\">.NET Core 3 SDK</a> . We are also supporting other .NET variants but for this example you will need the .NET Core 3 SDK.</p><p>Before we can start let us clone the Hot Chocolate repository and start our <em>Star Wars</em> server.</p><pre><code class=\"language-bash\">git clone https://github.com/ChilliCream/hotchocolate.git\ncd hotchocolate\ndotnet run --project examples/AspNetCore.StarWars/\n</code></pre><p>Now that we have our <em>Star Wars</em> server running, lets create a folder for our client and install the <em>Strawberry Shake</em> CLI tools.\nThe <em>Strawberry Shake</em> CLI tools are optional but make initializing the client project much easier.</p><pre><code class=\"language-bash\">mkdir berry\ndotnet new tool-manifest\ndotnet tool install StrawberryShake.Tools --version 11.0.0-preview.58 --local\n</code></pre><p>In our example we are using the new .NET CLI local tools. <code>dotnet new tool-manifest</code> creates the tools manifest which basically is like a packages.config and holds the information of which tools in which version we are using in our directory.</p><p>This is the great thing about local tools if you think about it, you can install tools to your repository and have always the right set of tools available to you in the moment you clone that repository.</p><p>The next command <code>dotnet tool install StrawberryShake.Tools --version 11.0.0-preview.58 --local</code> installs our <em>Strawberry Shake</em> tools. Once we have a final release of <em>Strawberry Shake</em> you do not need to speciefy the version anymore.</p><p>Next we need a little project. Let’s create a new console application so that we can easily run and debug what we are doing.</p><pre><code class=\"language-bash\">dotnet new console -n BerryClient\ncd BerryClient\ndotnet add package StrawberryShake --version 11.0.0-preview.58\ndotnet add package Microsoft.Extensions.Http --version 3.0.0\ndotnet add package Microsoft.Extensions.DependencyInjection --version 3.0.0\n</code></pre><p>OK, now that we have a project setup lets initialize the project by creating a local schema. Like with <em>Relay</em> we are holding a local schema file that can be extended with local types and fields. Our <em>GraphQL</em> compiler will use this schema information to validate the queries we write. This makes <em>GraphQL</em> query documents a part of the compilation process and with that a first-class citizen of our C# library.</p><blockquote><p>For the next step ensure that the <em>Star Wars</em> <em>GraphQL</em> server is running since we will fetch the schema from the server.</p></blockquote><blockquote><p>If you want to check out what commands are available with the tools just run <code>dotnet graphql</code> and the CLI tools will output the available commands.</p></blockquote><pre><code class=\"language-bash\">dotnet graphql init http://localhost:5000/graphql -n StarWars -p ./StarWars\n</code></pre><p>The init command will download the schema as GraphQL SDL and create a config to re-fetch the schema. Also, the config contains the client name. The client name defines how the client class and interface shall be named.</p><blockquote><p>Note: You can pass in the token and scheme if your endpoint is authenticated. There is also an update command to update the local schema.</p></blockquote><p>The configuration will look like the following:</p><pre><code class=\"language-json\">{\n  &quot;Schemas&quot;: [\n    {\n      &quot;Name&quot;: &quot;StarWars&quot;,\n      &quot;Type&quot;: &quot;http&quot;,\n      &quot;File&quot;: &quot;StarWars.graphql&quot;,\n      &quot;Url&quot;: &quot;http://localhost:5000/graphql&quot;\n    }\n  ],\n  &quot;ClientName&quot;: &quot;StarWarsClient&quot;\n}\n</code></pre><p>OK, now let’s get started by creating our first client API. For this open your editor of choice. I can recommend using <em>VSCode</em> for this at the moment since you will get GraphQL highlighting. As we move forward, we will refine the tooling and provide proper IntelliSense.</p><p>Now let us create a new file in our <code>StarWars</code> folder called <code>Queries.graphql</code> and add the following query:</p><blockquote><p>The file does not necessarily have to be called queries. You can call it however you want. The GraphQL compiler will figure out what files contain queries and what files contain schema definitions.</p></blockquote><pre><code class=\"language-graphql\">query getFoo {\n  foo\n}\n</code></pre><p>Now build your project.</p><pre><code class=\"language-bash\">dotnet build\n</code></pre><p>When we now compile, we get an <em>MSBuild</em> error on which we can click in <em>VSCode</em> and we are pointed to the place in our query file from which the error stems from. The error tells us that there is no field <code>foo</code> on the <code>Query</code> type.</p><pre><code class=\"language-bash\">/Users/michael/Local/play/berry/BerryClient/StarWars/Queries.graphql(2,3): error GQL: The field `foo` does not exist on the type `Query`. [/Users/michael/Local/play/berry/BerryClient/BerryClient.csproj]\n</code></pre><p>Your GraphQL query document is not just a string, it properly compiles and is fully typed. Let&#x27;s change our query and compile again:</p><pre><code class=\"language-graphql\">query getFoo {\n  hero {\n    name\n  }\n}\n</code></pre><pre><code class=\"language-bash\">dotnet build\n</code></pre><p>Now our project changes and we get a new <code>Generated</code> folder that has all the types that we need to communicate with our backend.</p><p>Let us have a closer look at our client interface for a minute.</p><pre><code class=\"language-csharp\">public interface IStarWarsClient\n{\n    Task&lt;IOperationResult&lt;IGetFoo&gt;&gt; GetFooAsync(\n        CancellationToken cancellationToken = default);\n}\n</code></pre><p>The named operation <code>getFoo</code> has become the method <code>GetFooAsync</code> in our generated client. This is nice since we kind of control from our GraphQL document the shape of our C# API. But there is more to that. A query document can hold multiple named operations. In essence the query document describes the interface between the client and the server.</p><pre><code class=\"language-graphql\">query function_a {\n  ...\n}\n\nquery function_b {\n  ...\n}\n\nquery function_c {\n  ...\n}\n</code></pre><p>Since, with GraphQL you essentially design your own service API by writing a query document you want to have control over the structure of your generated types. <em>Strawberry Shake</em> uses fragments to help you describe clean and reusable code components.</p><p>Let us redesign our query with fragments and make it a bit more complex.</p><pre><code class=\"language-graphql\">query getHero {\n  hero {\n    ...SomeDroid\n    ...SomeHuman\n  }\n}\n\nfragment SomeHuman on Human {\n  ...HasName\n  homePlanet\n}\n\nfragment SomeDroid on Droid {\n  ...HasName\n  primaryFunction\n}\n\nfragment HasName on Character {\n  name\n}\n</code></pre><p>The fragments will yield in the following type structure:</p><pre><code class=\"language-csharp\">public interface ISomeHuman\n    : IHasName\n{\n    string HomePlanet { get; }\n}\n\npublic interface ISomeDroid\n    : IHasName\n{\n    string PrimaryFunction { get; }\n}\n\npublic interface IHasName\n{\n    string Name { get; }\n}\n</code></pre><p>Let us reflect on that, fragments not only let us re-use type selections in our query document but also let us create and mold our C# API into a clean type structure. This puts us as the consumer of <em>Strawberry Shake</em> in the driver seat.</p><p><strong>We</strong> decide what data we <strong>need</strong> and how they are <strong>shaped</strong>.</p><blockquote><p>We are currently looking into how we can aggregate data and flatten the type structure. We initially thought about introducing some directives to flatten the type structure. But as we thought further on that and we really felt we want to have something like <a href=\"https://github.com/APIs-guru/graphql-lodash\">lodash</a>. We are still discussing on what we want to do here. So stay tuned.</p></blockquote><p>Let&#x27;s make one more tweak to our query and then we get this example running.</p><pre><code class=\"language-graphql\">query getHero($episode: Episode) {\n  hero(episode: $episode) {\n    ...SomeDroid\n    ...SomeHuman\n  }\n}\n\nfragment SomeHuman on Human {\n  ...HasName\n  homePlanet\n}\n\nfragment SomeDroid on Droid {\n  ...HasName\n  primaryFunction\n}\n\nfragment HasName on Character {\n  name\n}\n</code></pre><p>By defining a variable with our operation we now can pass in arguments. This makes our operation re-usable and a good interface with the server. GraphQL servers can pre-compile and optimize those parametrized query documents.</p><pre><code class=\"language-csharp\">public interface IStarWarsClient\n{\n    Task&lt;IOperationResult&lt;IGetHero&gt;&gt; GetHeroAsync(\n        Optional&lt;Episode&gt; episode = default,\n        CancellationToken cancellationToken = default);\n}\n</code></pre><p>OK, let&#x27;s get it running and then go into more details.</p><p>By default the generator will also generate dependency injection code for <code>Microsoft.Extensions.DependencyInjection</code>.</p><p>In order to get our client up and running we just have to set up a dependency injection container.</p><blockquote><p>Note: You can shut off dependency injection generation with a <em>MSBuild</em> property. The client can also be instantiated with a builder or by using a different dependency injection container.</p></blockquote><p>Replace your <code>Program</code> class with the following code.</p><pre><code class=\"language-csharp\">class Program\n{\n    static async Task Main(string[] args)\n    {\n        var serviceCollection = new ServiceCollection();\n        serviceCollection.AddHttpClient(\n            &quot;StarWarsClient&quot;,\n            c =&gt; c.BaseAddress = new Uri(&quot;http://localhost:5000/graphql&quot;));\n        serviceCollection.AddStarWarsClient();\n\n        IServiceProvider services = serviceCollection.BuildServiceProvider();\n        IStarWarsClient client = services.GetRequiredService&lt;IStarWarsClient&gt;();\n\n        IOperationResult&lt;IGetHero&gt; result = await client.GetHeroAsync(Episode.Newhope);\n        Console.WriteLine(((ISomeDroid)result.Data.Hero).Name);\n\n        result = await client.GetHeroAsync(Episode.Empire);\n        Console.WriteLine(((ISomeHuman)result.Data.Hero).Name);\n    }\n}\n</code></pre><p>Run the console and it will output the following;</p><pre><code class=\"language-bash\">R2-D2\nLuke Skywalker\n</code></pre><p>That is quite awesome. The client is easy to setup and easy to use. We just had to initialize our project and write a GraphQL query document and everything was generated so that we can focus on using our GraphQL endpoint instead of writing a bunch of code that we do not want to actually write. Moreover, we only get the types from the schema that we actually use in our query documents, that means we are not burdened with all the schema types and fields and so on that we do not need and do not want.</p><p><em>Strawberry Shake</em> let`s you take all the power of GraphQL and package it up into a fully typed client that works well with .NET. It does not limit you by introducing a new programming model like Linq or some other .NET API, instead <em>Strawberry Shake</em> makes <strong>GraphQL a first class citizen in the .NET world</strong>.</p><p>OK, now let us have a look at the result object since we also carefully discussed how we expose results to the consumer.</p><p>The result of an operation can be a <code>IOperationResult&lt;T&gt;</code> or a <code>IResponseStream&lt;T&gt;</code>.</p><p>The operation result represents a single result and we expose the GraphQL result structure as specified in the GraphQL spec.</p><p>This means that we give you a chance to take advantage of partial results in case of errors. However, we also make it easy to raise an exception in case of any error with the <code>EnsureNoErrors</code> method on the result object. This is kind of like with responses from a <code>HttpClient</code>.</p><p>Also, we allow you to have full access to provider specific data that is included in a dictionary called <code>Extensions</code>. This for instances is used in cases like active persisted queries or other provider specific extensions.</p><h2>Renaming Type Elements</h2><p>Did you notice the enum type <code>Episode.Newhope</code> in the upper example. This really is not nice to see as a C# developer :). Since the generator is built on top of the stitching API we easily can amend things like that in order to make our client API nice to use.</p><p>So, before we go into subscriptions let`s fix that :)</p><p>First, add another GraphQL file and call it <code>StarWars.Extensions.graphql</code>. Again, the name does not really matter, you could call it <code>Foo.graphql</code> and <em>Strawberry Shake</em> would also handle it correctly.</p><p>GraphQL allows to extend types with the <code>extend</code> keyword in the GraphQL SDL. In the example below we extend the <code>Episode</code> enum and add a directive (annotation) called <code>@name</code>. The <code>@name</code> directive allows us to provide the generator with a name for a type element that we actually want to use in our C# client API.</p><p>Now add the following type extension to the GraphQL file <code>StarWars.Extensions.graphql</code>:</p><pre><code class=\"language-graphql\">extend enum Episode {\n  NEWHOPE @name(value: &quot;NewHope&quot;)\n}\n</code></pre><p>Rebuild your project and voila ... <code>Episode.NewHope</code> is now correctly cased.</p><p>The nice thing is that we are just describing what we want to change in this schema extension file, so every time you update the server schema, we will preserve this file and reapply the type extensions to the newly downloaded schema.</p><p>## Subscriptions</p><p>OK, OK, most of this was already in place, so let us have a look at something more challenging like subscriptions.</p><p>Subscriptions will need a state-full connection to a server through a WebSocket. There are other ways to do this like SignalR (which essentially is a socket abstraction) or gRPC or even over a standard TCP socket.</p><p>While we are in the works to get SignalR and gRPC in let us have a look at how we can do it through WebSockets.</p><p>When we started on this we found that WebSockets should be as easy as setting up the HttpClient nowadays. So, we have introduced a new interface called <code>IWebSocketClientFactory</code>. But just having a factory is not enough since we want to maybe pool socket connections and reuse those with multiple subscriptions.</p><p>With the solution that we are introducing with version 11.0.0-preview.58 we are making WebSockets super simple to setup, and we will do all the hard parts like reusing the connection and things like that without you ever noticing it.</p><p>Let us have a look at how we can get subscriptions to work.</p><p>The first thing we have to do is going back to our query document. The <em>Star Wars</em> server has one subscription that is raised whenever a review is written. So, let’s use it and add it to our query file.</p><pre><code class=\"language-graphql\">query getHero($episode: Episode!) {\n  hero(episode: $episode) {\n    ...SomeDroid\n    ...SomeHuman\n  }\n}\n\nsubscription onReviewCreated(episode: $episode) {\n  onReview(episode: $episode) {\n    commentary\n    stars\n  }\n}\n\nfragment SomeHuman on Human {\n  ...HasName\n  homePlanet\n}\n\nfragment SomeDroid on Droid {\n  ...HasName\n  primaryFunction\n}\n\nfragment HasName on Character {\n  name\n}\n</code></pre><p>Now, lets rebuild our project and then look at the client interface.</p><pre><code class=\"language-csharp\">public interface IStarWarsClient\n{\n    Task&lt;IOperationResult&lt;IGetHero&gt;&gt; GetHeroAsync(\n        Optional&lt;Episode&gt; episode = default,\n        CancellationToken cancellationToken = default);\n\n    Task&lt;IResponseStream&lt;IOnReviewCreated&gt;&gt; OnReviewCreatedAsync(\n        Optional&lt;Episode&gt; episode = default,\n        CancellationToken cancellationToken = default);\n}\n</code></pre><p>Our client has now a new method that returns a response stream. A response stream is essentially an <code>IAsyncEnumerable</code> that will loop over the subscription event stream until the stream completes or the client disposes the stream.</p><p>Now let us put everything together. First we need to configure the WebSocket client connection.</p><pre><code class=\"language-csharp\">services.AddWebSocketClient(\n    &quot;StarWarsClient&quot;,\n    c =&gt; c.Uri = new Uri(&quot;ws://localhost:5000/graphql&quot;));\n</code></pre><p>This kind of looks exactly the way we would configure an HttpClient and it hides all the complex logic about connecting and pooling WebSocket connections. It also lets you easily intercept the connect process to include authentication logic.</p><p>The next thing we need to do to consume data from subscriptions is to read from our event stream.</p><pre><code class=\"language-csharp\">class Program\n{\n    static async Task Main(string[] args)\n    {\n        var serviceCollection = new ServiceCollection();\n        serviceCollection.AddHttpClient(\n            &quot;StarWarsClient&quot;,\n            c =&gt; c.BaseAddress = new Uri(&quot;http://localhost:5000/graphql&quot;));\n        serviceCollection.AddStarWarsClient();\n\n        IServiceProvider services = serviceCollection.BuildServiceProvider();\n        IStarWarsClient client = services.GetRequiredService&lt;IStarWarsClient&gt;();\n\n        var stream = await client.OnReviewCreatedAsync(Episode.NewHope);\n\n        await foreach (var result in stream)\n        {\n            result.EnsureNoErrors();\n            Console.WriteLine(result.Data!.OnReview.Commentary);\n        }\n    }\n}\n</code></pre><p>If you look at the code above it looks so easy how you can use subscription with <em>Strawberry Shake</em>, it almost looks no different from fetching a simple query with the <code>HttpClient</code>. This is exactly what we want the experience to be, simple but when you want to get into the pluming then we will allow you to easily intercept and extend the whole pipeline.</p><p>So, in order to try subscriptions out in your example open a tool like playground and the fire the following query against the local GraphQL Server while your console app is running.</p><pre><code class=\"language-graphql\">mutation {\n  createReview(\n    episode: NEWHOPE\n    review: { commentary: &quot;Awesome movie.&quot;, stars: 5 }\n  ) {\n    commentary\n    stars\n  }\n}\n</code></pre><p>As soon as you trigger the above mutation the client will print the commentary to the console, it is kind of like magic :)</p><h2>Custom Scalars</h2><p>The mean thing with all these examples that I posted in this blog is that I am only using the <em>Star Wars</em> example. The <em>Star Wars</em> uses no custom scalars and is super simple to use. That is the reason why I like to use it for demos, because people get easily on board with it. But it also is frustrating when you want to go deeper. This is especially true with custom scalars.</p><p><em>Strawberry Shake</em> supports an array of built-in scalars that go beyond the GraphQL spec. But still if you download the GitHub schema for instance you will get a ton of custom scalars.</p><p>With the current version we have made dealing with custom scalars a lot easier. First, if we do not know a scalar, then we will treat it as a <code>String</code>. While this is not always what you want, it lets you get started quickly and then change things when you really need them to change.</p><p>Let us have a look at how we can bring in a custom scalar. For this example, let us assume we have a scalar called <code>ByteArray</code>. This scalar serializes a <code>System.Byte[]</code> to a base64 string. This is easy enough. So on the client side we want the generator to generate models that expose <code>System.Byte[]</code> as property type. But in the communication between server and client the type shall be serialized as base64 string.</p><p>So, in order to give the generator a hint about these things we need to extend our schema. We would need to create a GraphQL file that holds our schema extensions (basically like with the enum example, where we renamed the enum value). The same way we can extend enums we can extend other types. In this case we want to annotate a scalar type.</p><pre><code class=\"language-graphql\">extend scalar ByteArray\n  @runtimeType(name: &quot;System.Byte[]&quot;)\n  @serializationType(name: &quot;System.String&quot;)\n</code></pre><p>The above example declares that for the <code>ByteArray</code> scalar the runtime type (the type that is used in the C# models) shall be a <code>System.Byte[]</code> and that the serialization type (the type which client and server use to send the data) shall be a <code>System.String</code>. For the generator that is enough to generate everything accordingly.</p><p>We still have to implement an <code>IValueSerializer</code> to specify the logic how the type shall actually serialize and deserialize.</p><pre><code class=\"language-csharp\">public class ByteArrayValueSerializer\n    : ValueSerializerBase&lt;byte[], string&gt;\n{\n    public override string Name =&gt; &quot;ByteArray&quot;;\n\n    public override ValueKind Kind =&gt; ValueKind.String;\n\n    public override object? Serialize(object? value)\n    {\n        if (value is null)\n        {\n            return null;\n        }\n\n        if (value is byte[] b)\n        {\n            return Convert.ToBase64String(b);\n        }\n\n        throw new ArgumentException(\n            &quot;The specified value is of an invalid type. &quot; +\n            $&quot;{ClrType.FullName} was expeceted.&quot;);\n    }\n\n    public override object? Deserialize(object? serialized)\n    {\n        if (serialized is null)\n        {\n            return null;\n        }\n\n        if (serialized is string s)\n        {\n            return Convert.FromBase64String(s);\n        }\n\n        throw new ArgumentException(\n            &quot;The specified value is of an invalid type. &quot; +\n            $&quot;{SerializationType.FullName} was expeceted.&quot;);\n    }\n}\n</code></pre><p>The serializer can be added as a singleton and will be automatically integrated by the generated client.</p><pre><code class=\"language-csharp\">services.AddSingleton&lt;IValueSerializer, ByteArrayValueSerializer&gt;();\n</code></pre><blockquote><p>We are refining how those serializers are registered. This is important for cases where one wants to have multiple clients with different kinds of serializers. I know this is rare but still this should work. The coming versions of <em>Strawberry Shake</em> will fine tune this.</p></blockquote><h2>Digging Deeper</h2><p>Apart from being able to add custom scalars we might want to dig deeper and allow new scenarios with our client like persisted queries. It is needles to say that we will add persisted query support out of the box. But it is also a good example to use to show how we can enable advance server / client protocols with <em>Strawberry Shake</em>.</p><p>The way we built-in things like that is by providing a operation middleware. This basically works like the query middleware in the server on the request level.</p><p><em>Strawberry Shake</em> allows us to swap out the default operation execution pipeline and add our own custom operation execution pipeline.</p><p>In order to setup a custom operation execution pipeline you can use for instance the <code>HttpPipelineBuilder</code>. Each transport has it`s own transport specific pipeline since the protocol between socket communication and stateless communication is quite different.</p><pre><code class=\"language-csharp\">serviceCollection.AddSingleton&lt;OperationDelegate&gt;(\n    sp =&gt; HttpPipelineBuilder.New()\n        .Use&lt;CreateStandardRequestMiddleware&gt;()\n        .Use&lt;CustomMiddleware&gt;()\n        .Use&lt;SendHttpRequestMiddleware&gt;()\n        .Use&lt;ParseSingleResultMiddleware&gt;()\n        .Build(sp));\n</code></pre><pre><code class=\"language-csharp\">public class CustomMiddleware\n{\n    private readonly OperationDelegate _next;\n    private readonly IOperationSerializer _service;\n\n    public CustomMiddleware(\n        OperationDelegate next,\n        ISomeCustomService service)\n    {\n        _next = next ?? throw new ArgumentNullException(nameof(next));\n        _service = service ?? throw new ArgumentNullException(nameof(service));\n    }\n\n    public async Task InvokeAsync(IHttpOperationContext context)\n    {\n        // the custom middleware code\n        await _next(context);\n    }\n}\n</code></pre><h2>Generation Options</h2><p>By default <em>Strawberry Shake</em> generates dependency injection code for <code>Microsoft.Extensions.DependencyInjection</code> this can be switched of by adding the following <code>MSBuild</code> property <code>&lt;GraphQLEnableDI&gt;false&lt;/GraphQLEnableDI&gt;</code>.</p><p>The generator will automatically detect if you are using C# 8.0 with nullable reference types or if you are using an older version of C#.</p><p>You can use the following <code>MSBuild</code> properties to control this.</p><pre><code class=\"language-xml\">&lt;PropertyGroup&gt;\n  &lt;LangVersion&gt;8.0&lt;/LangVersion&gt;\n  &lt;Nullable&gt;enable&lt;/Nullable&gt;\n&lt;/PropertyGroup&gt;\n</code></pre><p>We also by default take the root namespace from the project for generating files. You can however override this by providing the <code>&lt;BerryNamespace /&gt;</code> property. However, we will change this to an item group soon in order to also enable multiple clients in a single project to use different namespaces.</p><pre><code class=\"language-xml\">&lt;PropertyGroup&gt;\n  &lt;BerryNamespace&gt;$(RootNamespace)&lt;/BerryNamespace&gt;\n&lt;/PropertyGroup&gt;\n</code></pre><h2>Dependency Injection</h2><p>The client API can be used with other dependency injection container and also without dependency injection at all.</p><p>We initially had a limited builder API for this but decided to give it a do over. So, at the moment you could look at the generated dependency injection code and build your own integration.</p><p>We will allow with future build to add custom generators that can provide additional code for custom use cases. The way that would work is that such a generator would sit in a NuGet package that is being added to the project. The custom generator would register its generators to an item group and <em>Strawberry Shake</em> would pick those up and integrate them. These custom generators however are somewhere in the version 12 timeframe.</p><h2>Roadmap</h2><p>What are our next steps on <em>Strawberry Shake</em> and when are we planning to release it?</p><p>We have some more ground to cover before we have this version complete.</p><ol><li><p>MSBuild Integration\nWe are working on making the <em>MSBuild</em> integration better. There are still instances with <em>VSCode</em> where you have to compile twice. This is OK for a preview,but we are on it and think that in the next view preview builds we will have this fixed. With <em>Visual Studio for Windows</em> you can already enjoy design time code generation. This means that when you save a GraphQL file the generator will update the C# files.</p></li><li><p>Tooling\nWe are heavy at work on <em>Bananacake Pop</em> which is our GraphQL IDE that will help you write and analyze GraphQL queries.\nWe plan to use what we have done for <em>Bananacake Pop</em> to create a nice integration with <em>VSCode</em>. We want to have a rich integration with which you can work on huge schemas.</p><p>Beyond <em>VSCode</em> we are looking at writing a nice integration with <em>Visual Studio for Windows</em> and <em>Visual Studio for macOS</em> that will make <em>Strawberry Shake</em> and <em>GraphQL</em> a first-class citizen in Microsoft IDEs.</p><p>We hope to deliver all of this in the version 11 timeframe.</p></li><li><p>Persisted Query Support\nPersisted queries are one of our very next features that we will add to the client. We want to allow the same flows that we support on the server side.</p></li><li><p>Batching Support\nBatching support with the <code>@export</code> directive is as well planned for the initial release of <em>Strawberry Shake</em>.</p></li><li><p>Code Generation\nThe current code generation produces quite nice code, but it can produce issues where the types from your own project collide with the generated code. With the next view builds we will add an option to use full type names in those cases.\nAlso, we will add the code generation attribute to the generated files. So there are refinements going on in this area.</p></li><li><p>Defer / Stream\nWe are planning to add support for defer and stream to the client. This feature depends on our server implementation so we will have to see how far we are on execution plans before we can start on it for the client.</p></li></ol><p>I hope you enjoy what we are building. We are tying to bring GraphQL on .NET to the next level. While we still are miles away from what the JavaScript world has to offer we hope to close these gaps over the next year and even pull ahead in some areas. We love GraphQL and are passionate about it. We strongly believe that with our newest member <em>Strawberry Shake</em> we really can make things like <em>Xamarin</em> and <em>Blazor</em> so much better. We have planned a lot more and hope to bring data fetching in .NET to a whole new level over the next year. Ideally you just want to decalre in your .NET component the data that you need and all the client logic is infered from that, kind of the way relay works in JavaScript.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2019/11/25/strawberry-shake_2",
            "title": "Building a real-time .NET GraphQL Client API",
            "summary": "We are busy, busy, busy working on version 11 of Hot Chocolate and  Strawberry Shake . In this post I want to explore the client side of…",
            "image": "https://chillicream.com/static/edfb5cf97791063a5ee862e3cf5cb76e/0514f/strawberry-shake-banner.png",
            "date_modified": "2019-11-25T00:00:00.000Z",
            "date_published": "2019-11-25T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/09/27/strawberry-shake",
            "content_html": "<p><strong>This post has been updated, please head over to the newer post <a href=\"https://chillicream.com/blog/2019/11/25/strawberry-shake_2\">here</a>.</strong></p><p>We for a while now have two big GraphQL server projects on the .NET platform. So, if you just want to build a decent GraphQL server you can pick and choose between <em>GraphQL .NET</em> or Hot Chocolate.</p><p>If you are looking at consuming a GraphQL server in your <em>Blazor</em> or <em>Xamarin</em> application, then things are not so promising. You can either go with a bare bone client from the <em>GraphQL .NET</em> project or you can decide to go it alone and build on <code>HttpClient</code>.</p><p>After the version 10 release of our Hot Chocolate GraphQL server we have started to build a new GraphQL client API that is more in line with how people in JavaScript consume GraphQL endpoints.</p><h2>Introduction</h2><p>Before we get into it let me first outline what our goals for our approach are:</p><ul><li>Strongly typed API.</li><li>Define the API with GraphQL.</li><li>No magic strings.</li><li>Everything compiles.</li><li>Customizable request pipelines.</li><li>Support for local resolvers.</li><li>Support for custom scalars.</li></ul><p>The preview that we released today is a prototype that has a ton of bugs and is meant at the moment to get feedback. Starting with this preview we will now release every other day a new preview and think that we will release this new API with version 11 of Hot Chocolate.</p><h2>Getting Started</h2><p>Let us have a look at how we want to tackle things with <em>Strawberry Shake</em>. For this little walkthrough I will use our <a href=\"https://github.com/ChilliCream/hotchocolate/tree/master/examples/AspNetCore.StarWars\"><em>Star Wars</em> server example</a>.</p><p>If you want to follow along then install the <a href=\"https://dotnet.microsoft.com/download/dotnet-core/3.0\">.NET Core 3 SDK</a> . We are also supporting other .NET variants but for this example you will need the .NET Core 3 SDK.</p><p>Before we can start let us clone the Hot Chocolate repository and start our <em>Star Wars</em> server.</p><pre><code class=\"language-bash\">git clone https://github.com/ChilliCream/hotchocolate.git\ncd hotchocolate\ndotnet run --project examples/AspNetCore.StarWars/\n</code></pre><p>Now that we have our <em>Star Wars</em> server running, lets create a folder for our client and install the <em>Strawberry Shake</em> tools.</p><pre><code class=\"language-bash\">mkdir berry\ndotnet new tool-manifest\ndotnet tool install StrawberryShake.Tools --version 11.0.0-preview.35 --local\n</code></pre><p>In our example we are using the new .NET CLI local tools. <code>dotnet new tool-manifest</code> creates the tools manifest which basically is like a packages.config and holds the information of which tools in which version we are using.</p><p>The next command <code>dotnet tool install StrawberryShake.Tools --version 11.0.0-preview.35 --local</code> installs our <em>Strawberry Shake</em> tools.</p><p>Next we need a little project. Let’s create a new console application so that we can easily run and debug what we are doing.</p><pre><code class=\"language-bash\">dotnet new console -n BerryClient\ncd BerryClient\ndotnet add package StrawberryShake --version 11.0.0-preview.35\ndotnet add package Microsoft.Extensions.Http --version 3.0.0\ndotnet add package Microsoft.Extensions.DependencyInjection --version 3.0.0\n</code></pre><p>OK, now that we have a project setup lets initialize the project by creating a local schema. Like with <em>relay</em> we are holding a local schema file that can be extended with local types and fields. Our <em>Graphql</em> compiler will use this schema information to validate the queries.</p><blockquote><p>For the next step ensure that the <em>Star Wars</em> <em>GraphQL</em> server is running since we will fetch the schema from the server.</p></blockquote><pre><code class=\"language-bash\">dotnet graphql init ./StarWars http://localhost:5000/graphql -n StarWars\n</code></pre><p>The init command will download the schema as GraphQL SDL and create a config to refetch the schema. Also, the config contains the client name. The client name defines how the client class is and interface is named.</p><blockquote><p>Note: You can pass in the token and scheme if your endpoint is authenticated. There is also an update command to update the local schema.</p></blockquote><p>The configuration will look like the following:</p><pre><code class=\"language-json\">{\n  &quot;Schemas&quot;: [\n    {\n      &quot;Name&quot;: &quot;StarWars&quot;,\n      &quot;Type&quot;: &quot;http&quot;,\n      &quot;File&quot;: &quot;StarWars.graphql&quot;,\n      &quot;Url&quot;: &quot;http://localhost:5000/graphql&quot;\n    }\n  ],\n  &quot;ClientName&quot;: &quot;StarWarsClient&quot;\n}\n</code></pre><p>OK, now let’s get started by creating our first client API. For this open your editor of choice. I can recommend using VSCode for this at the moment since you will get GraphQL highlighting. As we move forward, we will refine the tooling more and provide proper IntelliSense.</p><p>Now let us create a new file in our <code>StarWars</code> folder called <code>Queries.graphql</code> and add the following query:</p><pre><code class=\"language-graphql\">query getFoo {\n  foo\n}\n</code></pre><p>Now build your project.</p><pre><code class=\"language-bash\">dotnet build\n</code></pre><p>When we now compile, we get an <em>MSBuild</em> error on which we can click in VSCode and we are pointed to the place in our query file from which the error stems from. The error tells us that there is no field <code>foo</code> on the <code>Query</code> type.</p><pre><code class=\"language-bash\">/Users/michael/Local/play/berry/BerryClient/StarWars/Queries.graphql(2,3): error GQL: The field `foo` does not exist on the type `Query`. [/Users/michael/Local/play/berry/BerryClient/BerryClient.csproj]\n</code></pre><p>Your GraphQL query document is not just a string, it properly compiles and is fully typed. Let&#x27;s change our query to the following and compile again:</p><pre><code class=\"language-graphql\">query getFoo {\n  hero {\n    name\n  }\n}\n</code></pre><pre><code class=\"language-bash\">dotnet build\n</code></pre><p>Now our project changes and we get a new <code>Generated</code> folder that has all the types that we need to communicate with our backend.</p><p>Let us have a look at our client interface for a minute.</p><pre><code class=\"language-csharp\">public interface IStarWarsClient\n{\n    Task&lt;IOperationResult&lt;IGetFoo&gt;&gt; GetFooAsync();\n\n    Task&lt;IOperationResult&lt;IGetFoo&gt;&gt; GetFooAsync(\n        CancellationToken cancellationToken);\n}\n</code></pre><p>The client will have for each operation in your query file one method that will execute that exact operation.</p><p>Since, with GraphQL you essentially design your own service API by writing a query document your types can become quite messy very quickly.</p><p>In order to avoid getting a messy API and to give you control over how your C# API will look like we are using fragments to infer types.</p><p>Let us redesign our query with fragments and make it a bit more complex.</p><pre><code class=\"language-graphql\">query getHero {\n  hero {\n    ...SomeDroid\n    ...SomeHuman\n  }\n}\n\nfragment SomeHuman on Human {\n  ...HasName\n  homePlanet\n}\n\nfragment SomeDroid on Droid {\n  ...HasName\n  primaryFunction\n}\n\nfragment HasName on Character {\n  name\n}\n</code></pre><p>The fragments will yield in the following type structure:</p><pre><code class=\"language-csharp\">public interface ISomeHuman\n    : IHasName\n{\n    string HomePlanet { get; }\n}\n\npublic interface ISomeDroid\n    : IHasName\n{\n    string PrimaryFunction { get; }\n}\n\npublic interface IHasName\n{\n    string Name { get; }\n}\n</code></pre><p>As we go forward, we will introduce some directives that will let you further manipulate the types like <code>@spread</code>. <code>@spread</code> will let you spread the fields of a child object over its parent object.</p><p>Let&#x27;s make one more tweak to our query and then we get this example running.</p><pre><code class=\"language-graphql\">query getHero($episode: Episode) {\n  hero(episode: $episode) {\n    ...SomeDroid\n    ...SomeHuman\n  }\n}\n\nfragment SomeHuman on Human {\n  ...HasName\n  homePlanet\n}\n\nfragment SomeDroid on Droid {\n  ...HasName\n  primaryFunction\n}\n\nfragment HasName on Character {\n  name\n}\n</code></pre><p>By definig a variable with our operation we now can pass in arguments into our operation.</p><pre><code class=\"language-csharp\">public interface IStarWarsClient\n{\n    Task&lt;IOperationResult&lt;IGetHero&gt;&gt; GetHeroAsync(\n        Episode episode);\n\n    Task&lt;IOperationResult&lt;IGetHero&gt;&gt; GetHeroAsync(\n        Episode episode,\n        CancellationToken cancellationToken);\n}\n</code></pre><p>OK, let&#x27;s get it running and then go into more details. By default the generator will also generate dependency injection code for <code>Microsoft.Extensions.DependencyInjection</code>. In order to get our client up and running we just have to set up a dependency injection container.</p><blockquote><p>Note: You can shut of dependency injection generation with a <em>MSBuild</em> property. The client can also be instantiated with a builder or by using a different dependency injection container.</p></blockquote><p>Replace you <code>Program</code> class with the following code.</p><pre><code class=\"language-csharp\">class Program\n{\n    static async Task Main(string[] args)\n    {\n        var serviceCollection = new ServiceCollection();\n        serviceCollection.AddDefaultScalarSerializers();\n        serviceCollection.AddStarWarsClient();\n        serviceCollection.AddHttpClient(&quot;StarWarsClient&quot;)\n            .ConfigureHttpClient(client =&gt;\n                client.BaseAddress = new Uri(&quot;http://localhost:5000/graphql&quot;));\n\n        IServiceProvider services = serviceCollection.BuildServiceProvider();\n        IStarWarsClient client = services.GetRequiredService&lt;IStarWarsClient&gt;();\n\n        IOperationResult&lt;IGetHero&gt; result = await client.GetHeroAsync(Episode.Newhope);\n        Console.WriteLine(((ISomeDroid)result.Data.Hero).Name);\n\n        result = await client.GetHeroAsync(Episode.Empire);\n        Console.WriteLine(((ISomeHuman)result.Data.Hero).Name);\n    }\n}\n</code></pre><p>Run the console and it will output the following;</p><pre><code class=\"language-bash\">R2-D2\nLuke Skywalker\n</code></pre><h2>Generation Options</h2><p>By default, <em>Strawberry Shake</em> will generate C# 7.3 without nullable reference types. We also by default generate dependency injection code for <code>Microsoft.Extensions.DependencyInjection</code>.</p><p>If the generator detects that you are using C# 8.0 and enabled support for nullable reference types, then the generate is switching to produce code with nullable reference types.</p><pre><code class=\"language-xml\">&lt;PropertyGroup&gt;\n  &lt;LangVersion&gt;8.0&lt;/LangVersion&gt;\n  &lt;Nullable&gt;enable&lt;/Nullable&gt;\n&lt;/PropertyGroup&gt;\n</code></pre><p>In order to manually overwrite those defaults, we added some build properties that you can use.</p><pre><code class=\"language-xml\">&lt;PropertyGroup&gt;\n  &lt;BerryLangVersion&gt;CSharp_8_0&lt;/BerryLangVersion&gt;\n  &lt;BerryEnableDI&gt;true&lt;/BerryEnableDI&gt;\n  &lt;BerryNamespace&gt;$(RootNamespace)&lt;/BerryNamespace&gt;\n&lt;/PropertyGroup&gt;\n</code></pre><h2>Dependency Injection</h2><p>The client API can be used with other dependency injection container and also without dependency injection at all.</p><p>The execution pipeline can be extended or completely swapped out. This is an important aspect of <em>Strawberry Shake</em> since this allows us to add cross-cutting concerns like auto-batching, persisted query support and other features.</p><pre><code class=\"language-csharp\">private static IServiceCollection TryAddDefaultHttpPipeline(\n    this IServiceCollection serviceCollection)\n{\n    serviceCollection.TryAddSingleton&lt;OperationDelegate&gt;(\n        sp =&gt; HttpPipelineBuilder.New()\n            .Use&lt;CreateStandardRequestMiddleware&gt;()\n            .Use&lt;SendHttpRequestMiddleware&gt;()\n            .Use&lt;ParseSingleResultMiddleware&gt;()\n            .Build(sp));\n    return serviceCollection;\n}\n</code></pre><p>When used with Microsoft&#x27;s dependency injection container then we are also using the <code>IHttpFactory</code> which allows for integration with polly and others.</p><h2>Roadmap</h2><p>We are still heavy at work on the client and generator and this first preview is where we invite people to try it out in order to get feedback.</p><p>There is still a ton of work to be done and a ton of tests to be written to get this up for prime time.</p><p>We will have I think two more weeks to work on the generator to iron out generation issues. We will add documentation tags and things like that over the next view weeks.</p><p>Also, there are some generator directives that should show up next week like <code>@spread</code>, <code>@name</code> and <code>@type</code>.</p><p>Moreover, we will add support for local schema stitching. We already integrated the stitching engine into the generator but have a view more things to do before this works properly.</p><p>Local schema stitching will allow you to focus on your client API without having to wonder which client you have to use for which service. Also, it will allow you to form one local schema from which you can generate the types exactly like you want them.</p><p>Furthermore, there are execution features that we are currently adding like auto-batching and manual-batching. Support for subscription, ´@defer´ and persisted queries are also coming.</p><p>Last but not least we have a lot to do on the tooling side. We want to have a nice integration with all Visual Studios and are working on things like live generation. You can get a feeling for this by doing <code>dotnet watch build</code>. We have updated the watch information to exclude the generated files and include the <em>GraphQL</em> files.</p><p>Please check it out and give us feedback so we can adjust and refine the experience further.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2019/09/27/strawberry-shake",
            "title": "Building a .NET GraphQL Client API",
            "summary": "This post has been updated, please head over to the newer post  here . We for a while now have two big GraphQL server projects on the .NET…",
            "image": "https://chillicream.com/static/edfb5cf97791063a5ee862e3cf5cb76e/0514f/strawberry-shake-banner.png",
            "date_modified": "2019-09-27T00:00:00.000Z",
            "date_published": "2019-09-27T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/08/14/hot-chocolate-10.0.0",
            "content_html": "<p>Today we have released version 10 of Hot Chocolate. We originally started building version 9.1 which grew bigger and at one point became version 10. We have focused a lot on our server implementation. But let me walk you through our latest release.</p><h2>Filters</h2><p>So, while we focused a lot on the server implementation, we also added some nice features to the GraphQL core. The main feature we added here is the new filter API.</p><p>Filters let you query your backend with a powerful query input type that translates into native database queries.</p><pre><code class=\"language-graphql\">{\n  persons(\n    where: { OR: [{ firstName_starts_with: &quot;abc&quot; }, { lastName: &quot;def&quot; }] }\n  ) {\n    firstName\n    lastName\n  }\n}\n</code></pre><p>The above query would translate to a something like <code>persons.Where(t =&gt; t.FirstName.StartsWith(&quot;abc&quot;) || t.LastName == def)</code>.</p><p>This works out of the box if you are using <code>IQueryable</code>.</p><p>All you have to do in your schema type is to add a <code>UseFiltering</code> to your field descriptor.</p><pre><code class=\"language-csharp\">public class QueryType\n  : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjetcTypeDescriptor&lt;Query&gt; descriptor)\n    {\n        descriptor.Field(t =&gt; t.GetPersons(default))\n          .Type&lt;ListType&lt;PersonType&gt;&gt;()\n          .UseFiltering();\n    }\n}\n</code></pre><p>Filters are easily combined with our pagination.</p><pre><code class=\"language-csharp\">public class QueryType\n  : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjetcTypeDescriptor&lt;Query&gt; descriptor)\n    {\n        descriptor.Field(t =&gt; t.GetPersons(default))\n          .UsePaging&lt;PersonType&gt;()\n          .UseFiltering();\n    }\n}\n</code></pre><p>Also, it is possible to customize filters by describing what fields are filterable and what operators are allowed.</p><pre><code class=\"language-csharp\">public class QueryType\n  : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjetcTypeDescriptor&lt;Query&gt; descriptor)\n    {\n        descriptor\n          .Field(t =&gt; t.GetPersons(default))\n          .UsePaging&lt;PersonType&gt;()\n          .UseFiltering(d =&gt; d.Ignore(t =&gt; t.LastName));\n    }\n}\n</code></pre><p>If you want to use the same filter multiple times all over your schema you can also describe the filter input type separately.</p><pre><code class=\"language-csharp\">public class PersonFilterType\n    : FilterInputType&lt;Person&gt;\n{\n    protected override void Configure(\n        IFilterInputTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor\n            .BindFieldsExplicitly()\n            .Filter(t =&gt; t.Name)\n            .BindOperationsExplicitly()\n            .AllowEquals().Name(&quot;equals&quot;).And()\n            .AllowContains().Name(&quot;contains&quot;).And()\n            .AllowIn().Name(&quot;in&quot;);\n    }\n}\n</code></pre><p>And then use this filter type where you need it.</p><pre><code class=\"language-csharp\">public class QueryType\n  : ObjectType&lt;Query&gt;\n{\n    protected override void Configure(IObjetcTypeDescriptor&lt;Query&gt; descriptor)\n    {\n        descriptor\n          .Field(t =&gt; t.GetPersons(default))\n          .UsePaging&lt;PersonType&gt;()\n          .UseFiltering&lt;PersonFilterType&gt;());\n    }\n}\n</code></pre><p>The nice thing here is that the filter works out of the box on <code>IQueryable</code> and <code>IEnumerable</code> so you can use it for database queries as well as for in-memory lists.</p><p>With version 10 of Hot Chocolate we are supporting filters on scalar fields. But we are already working on support for object filters and enumerable filters.</p><p>Also, we are working on sorting which should be included in the first preview of version 11.</p><p>If you want to give input or follow our work, you can head over to these four issues that will be coming with version 11.</p><ul><li><a href=\"https://github.com/ChilliCream/hotchocolate/issues/921\">Object Filters #921</a></li><li><a href=\"https://github.com/ChilliCream/hotchocolate/issues/922\">IEnumerable Filters #922</a></li><li><a href=\"https://github.com/ChilliCream/hotchocolate/issues/923\">Sorting #923</a></li><li><a href=\"https://github.com/ChilliCream/hotchocolate/issues/924\">Aggregations #924</a></li></ul><blockquote><p>If you want to check out more about filters head over to our <a href=\"https://hotchocolate.io/docs/filters\">documentation</a>.</p></blockquote><p>Let me also thank <a href=\"https://github.com/PascalSenn\">Pascal</a> for his awesome work on this one.</p><h2>Subscriptions</h2><p>Subscriptions was another big investment that we took for this release.</p><h3>Redis</h3><p>For the core API we introduced a <em>Redis</em> subscription provider. This means that you now can use <em>Redis</em> as a pub/sub system without a hassle.</p><pre><code class=\"language-csharp\">var configuration = new ConfigurationOptions\n{\n    Ssl = true,\n    AbortOnConnectFail = false,\n    Password = password\n};\n\nconfiguration.EndPoints.Add(&quot;host:port&quot;);\n\nservices.AddRedisSubscriptionProvider(configuration);\n</code></pre><p>That`s all you have to do to connect the query engine with <code>Redis</code>.</p><p><strong>So why should we want to use <code>Redis</code> anyway.</strong></p><p>The thing with in-memory subscriptions is that they will only work reliable if you have one instance of Hot Chocolate. When you have deployed multiple instance of <em>Hot Chcocolate</em> or if you are scaling on demand with a massive amount of subscribers then you want to make sure that your pub/sub system scales and that mutations executed on one server raise an event on another one.</p><p>But there is more, sometimes you want to raise an event without triggering a mutation, maybe there was an event somewhere in your infrastructure that you want to relay as a GraphQL subscription, this can also be done through an external pub/sub system like Redis.</p><p>With version 11 We will add <em>Kafka</em> and <em>Azure EventHub</em> support and are also looking into other pub/sub systems, so that you can use whatever feels best to you.</p><h3>Pipelines</h3><p>We also rebuild the whole WebSocket handling in the server by using the new <code>Pipeline</code> API that Microsoft introduced to .Net. This makes it now super-efficient how we handle the messages with our new <code>UTF8RequestParser</code>. But we are not done here and will with version 11 further optimize our parser to work even better with pipelines.</p><blockquote><p>If you want to check out more about subscriptions head over to our <a href=\"https://hotchocolate.io/docs/code-first-subscription\">documentation</a>.</p></blockquote><p>Let me also thank <a href=\"https://github.com/glucaci\">Gabriel</a> for his great work on subscriptions.</p><h2>Batching</h2><p>Another big feature we have invested in was batching. When we started on this one we reflected a lot about how we want to do this and if we really need this one. In the end we decided that batching could enable great scenarios and is worth adding to our server.</p><p>When Lee Byron initially showed batching off, he explained that this would be useful in cases where you want to fetch important data first and delay more expensive data without needing to issue two separate calls.</p><p>They had this example that they want to fetch the news stream of a given user and the comments should appear once those are available.</p><p><code>POST /graphql?batchOperations=[NewsFeed, StoryComments]</code></p><pre><code class=\"language-graphql\">query NewsFeed {\n  stories {\n    id @export(as: &quot;ids&quot;)\n    actor\n    message\n  }\n}\n\nquery StoryComments {\n  stories(ids: $ids) {\n    comments(first: 2) {\n      actor\n      message\n    }\n  }\n}\n</code></pre><p>In the above query we would first fetch the stories, collect all the story ids and use these as an input to the next query to fetch all the comments for the former stories.</p><p>The nice thing is that this is done in one HTTP call and as soon as query one is executed, we will write the result into the stream and the client can already work with that data while waiting for the second result.</p><p>This all is working over one HTTP call without WebSockets and is super-efficient.</p><p><strong>Why did we question its use?</strong></p><p>The thing is that with version 11 we will introduce <code>@defer</code> which will allow you to do the following:</p><pre><code class=\"language-graphql\">query NewsFeed {\n  stories {\n    id @export(as: &quot;ids&quot;)\n    actor\n    message\n    ... @defer {\n      comments(first: 2) {\n        actor\n        message\n      }\n    }\n  }\n}\n</code></pre><p>The fragment that is annotated with <code>@defer</code> will be deferred to when it is ready. This means you can write queries much cleaner with this and reap the same benefits.</p><p><strong>What makes batching a great feature then?</strong></p><p>First, you can defer query parts with this now in version 10.</p><p>Second, I think batching is very interesting with mutations where you can write complex mutation flows that use the results of one mutation to feed data in the next mutation. The ability to export result data into variables lets you write nice data flows.</p><p>Look at how easy you can export data as variable by just adding <code>@export</code>.</p><pre><code class=\"language-graphql\">{\n  foo {\n    bar @export\n  }\n}\n</code></pre><p>What`s important to know here is that you also can export objects that will convert to a matching input type.</p><pre><code class=\"language-graphql\">{\n  foo @export(as: &quot;something&quot;) {\n    bar\n  }\n}\n</code></pre><p>Third, we also wanted to support Apollo batching where Apollo collects all the queries of a client in a certain time window and sends those in one request to our server. One batch will share the <em>DataLoader</em> instances which means that the batch request will be faster than sending them in separately.</p><blockquote><p>We are supporting operation batching and request batching and if you would like to know more about it head over to our <a href=\"https://hotchocolate.io/docs/batching\">documentation</a>.</p></blockquote><h2>Persisted Queries</h2><p>With version 10 we now support persisted queries. With persisted queries you can add well-knonw queries to a second-level cache. All queries stored in there are considered valid.</p><p><strong>So, what is this for?</strong></p><p>Persisted queries are faster, since we validate those only once. Moreover, you do not need to send us the query every time, you can instead just send the query name and the server will look up the query and execute it. This can dramatically improves performance, reduces bandwidth and memory usage.</p><p>This makes it feasible to use a simple <code>GET</code> request instead of a <code>POST</code> request which can also have benefits when using things like CDNs.</p><p><code>GET http://example.com/graphql?namedQuery=QUERYNAME&amp;variables={&quot;id&quot;:&quot;QVBJcy5ndXJ1&quot;}</code></p><p>We have opted to support both active persisted queries and persisted queries.</p><blockquote><p>Read more about this <a href=\"https://hotchocolate.io/docs/persisted-queries\">here</a>;</p></blockquote><h2>Server Modularization</h2><p>With Version 10 we have now a modularized server implementation. That each middleware is placed in its own package. You can still just add our <code>HotChocolate.AspNetCore</code> or <code>HotChocolate.AspNetClassic</code> package and do not worry what is included in your server. But with version 10 you could now just add some of the middleware like maybe just HTTP-GET or HTTP-POST. This way if you do not use for instance subscriptions than there will not even be the code for subscriptions.</p><p>With version 10 we have the following middleware available:</p><ul><li>HotChocolate.AspNetCore.HttpPost</li><li>HotChocolate.AspNetCore.HttpGet</li><li>HotChocolate.AspNetCore.HttpGetSchema</li><li>HotChocolate.AspNetCore.Subscriptions</li><li>HotChocolate.AspNetCore.Authorization</li></ul><blockquote><p>Read more about this right <a href=\"https://hotchocolate.io/docs/aspnet\">here</a></p></blockquote><h2>UTF-8 Request Parser</h2><p>With GraphQL most requests are provided as <code>JSON</code> that contains the request as an escaped string. This is kind of bad for performance since we first parse the <code>JSON</code> then take the string and parse again a string that we actually do not need.</p><p>With the new <em>UTF-8 request parser</em> we can finally just read the binary request stream and parse the JSON and the GraphQL request in one go. But there is more, we have given our new UTF-8 request parser access to our document cache, meaning while we parse the JSON request and hit the part were the GraphQL request is, we can look up if this query is already cached. This dramatically reduces memory usage and performance since we will not consume the query property anyway.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/21cd7/request_parser_mem.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:87.00000000000001%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACtElEQVQ4y4WUy04UQRSGW0B078oQF64IGxQXbjDxAYyJRKMxYQPRhAcwPgBGja40RsUgKEhkoeI1JiQuJAaJEjWK6HAbupkLM+IwM32/1m+d6h5ocNDu/Km/uqu+Pqf6VEngF2OMGniuC8s0YVuWkBW11fpxb/I5juMIhhQHFktlrJZV6KYFVTdQUjVohsVlxvqmEHl6Rp7gxWIRvu+HQC8Igb1TGvY+8nHwNXDgFdDyMmwr2txvfgEcHgUoNlPX4HpeCHT9ENj9QYN0w4V0j4fex/6vXoYdDwLoHgHVGDCK8PIkB/a42DkE1A2yf2o7l3SfYdcwg+HHgLR+FeClSRXSbRv1/Ks1Az62cdUMBAJQu0l1WwHjEV78aEG6CdQOIEyb1M91N9gy5XoO1uPAIAiwkEyi+Os3JtILuD4zjj75M3qTn3BrfgJPUimM54Gx5QBvsz7ecU8iP7bM8D7PEPBgNE2FV0nZCzwR4fNUD05N70bX/D50zTXjdKIBTwtXEF4u1QPWL/IsEqCqETAsm3DgyFI/2r42onPmEDoTrTj+vQlDuWvine17sF0PVBAk8h43frRcWjXgMw488a0RZ2dbcWamFSenmzCcD4E0hiasxcc9ZVfZFFUjfKzcwZEvDWj/2YL2H/txdGoPBnNXI6D7F5DWvyrQZ+HAN9kRnJs7hgupDnQrHTifbMNo8aF4F9AdBGvAuBcpa9r6T6l8pVQqoayW+d40oRs6VP7naOOTDMMQk0wr7JOnZ+Q37uUYkBbWoJPDdqDrOnK5HGzbFidJoVAQfddx4fJTifzKyop4R8B0Oi3GSiGMweLF6fiUls970c3YhoUPi8fhf9YX1RJfw0orBRFwVgUS2VVkUgqy2Szy+TySvOCpzWQyWFJS0EwVspWArMhYTC5CURQhWZaFKO0/jwCyAuuMI+sAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Request Parser Memory\" title=\"Request Parser Memory\" src=\"https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/7842b/request_parser_mem.png\" srcSet=\"https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/f8f3a/request_parser_mem.png 200w,https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/6a8a8/request_parser_mem.png 400w,https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/7842b/request_parser_mem.png 800w,https://chillicream.com/static/79eb87e528f8d0453db52a6e085d38e6/21cd7/request_parser_mem.png 962w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p>The new request parser does only allocate 1/3 of the memory that GraphQL-DotNet uses with it`s combination of JSON.Net and it`s string based GraphQL parser.</p><p>The Hot Chocolate GraphQL parser is twice as fast than the GraphQL-DotNet parser on average. The whole request pipeline is 3 times faster on average, but we are not done yet and will double down on performance with the new query execution plans and our updated syntax tree that allows to further reduce string usage.</p><h2>Everything Else</h2><p>With version 10 we added a ton of bug fixes and also, we added a lot of API improvements that will make your day to day business so much easier.</p><p>Like now you can add error filter to the dependency injection instead of registering them with the execution builder.</p><pre><code class=\"language-csharp\">services.AddErrorFilter&lt;MyCustomErrorFilter&gt;();\n</code></pre><p>The same goes for class <em>DataLoader</em>.</p><pre><code class=\"language-csharp\">services.AddDataLoader&lt;MyCustomDataLoader&gt;();\n</code></pre><p>When you use this extension, we also will add the <em>DataLoader</em> registry.</p><p>Also, we refined things like the schema builder so that you can in place now define all the types:</p><pre><code class=\"language-csharp\">SchemaBuilder.New()\n  .AddEnumType(d =&gt; d.Name(&quot;MyEnum&quot;).Value(&quot;FOO))\n  ...\n  .Create();\n</code></pre><p>There are so many little things that can make your day :)</p><h2>Version 11</h2><p>Like with every release we are giving a little outlook for the next version. As the releases are fluid, we are sometimes moving things around.</p><p>We want to really focus on two major topics with the next release.</p><h2>Query Execution Plans</h2><p>We originally planned for this one for version 10 (aka version 9.1) but decided that the current set of new features is already a good version that is worth to release. But with the next release this is one of the two things we really will focus on. With this in place we will double down on performance and will introduce features like <code>@defer</code> and <code>@stream</code>.</p><p>Moreover, this one will be the backbone of our new stitching layer that will bring lots of new features to schema stitching.</p><h2>Client API</h2><p>The second thing we already started work on is a client API for .NET Core. We are currently experimenting with how we design this new piece of API. We have started a discussion around this in our slack channel and will start with some coding soon.</p><h2>Banana Cakepop</h2><p><strong>Oh, didn`t you forget something?</strong></p><p>Yes, yes originally, we had planned to release <em>Banana Cakepop</em> alongside this version. We ran into some performance issues with the tree we originally selected when using large schemas with more than 1000 types.</p><p>We have now started to write the tree component ourselves which is taking some extra time. We already see that we can handle now massive schemas far beyond 1000 types without any hiccups. But we have still lots to do on the new tree.</p><p>I hope that we can see the promised preview in the next 4 to 8 weeks. We want to release something really good and not something half-backed.</p><h2>The Other Things</h2><p>We also will add more features to our filter API and make working with databases even easier.</p><p>Also, we will add more subscription provider like Kafka and EventHub.</p><p>Furthermore, we will rework our <code>Utf8GraphQLReader</code> to use <code>ReadOnlySequence&lt;byte&gt;</code> instead of <code>ReadOnlySpan&lt;byte&gt;</code> in order to make this even better work with the Pipeline API. Apart from that we will optimize the syntax tree to be able to work with raw bytes instead of strings. At the moment scalar like String, Int, Float and Enum are parsed as string representation like with the original node parser. The scalar type parses then the string into the native type. The same goes for the new UTF-8 request parser. This is unnecessary with the <code>Utf8Parser</code> and <code>Utf8Formater</code>. We will change the AST to instead have the raw bytes. The current <code>Value</code> property will still be there but only for compatibility with tools that use the current version of the AST. The new scalar types will have access to a <code>ReadOnlySpan&lt;byte&gt;</code> and can decide how to efficiently parse literals.</p><p>If you want to get into contact with us head over to our slack channel and join our community.</p>",
            "url": "https://chillicream.com/blog/2019/08/14/hot-chocolate-10.0.0",
            "title": "GraphQL - Hot Chocolate 10.0.0",
            "summary": "Today we have released version 10 of Hot Chocolate. We originally started building version 9.1 which grew bigger and at one point became…",
            "image": "https://chillicream.com/static/7be2244f6a40210dca5845da740253e6/0514f/hotchocolate-banner.png",
            "date_modified": "2019-08-14T00:00:00.000Z",
            "date_published": "2019-08-14T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/06/05/hot-chocolate-9.0.0",
            "content_html": "<p>Today we have released version 9 of Hot Chocolate. This release was mainly focused on the schema APIs and performance. Furthermore, we started work on the wider <em>ChilliCream GraphQL Platform</em> and today you will get some insides where we are heading with this.</p><h2>Schema Builder</h2><p>The schema builder API is the most visible <strong>new</strong> API with version 9. It provides a simpler API that is easier to extend.</p><pre><code class=\"language-csharp\">SchemaBuilder.New()\n    .AddQueryType&lt;MyQueryType&gt;()\n    .AddObjectType(d =&gt; d.Name(&quot;Foo&quot;).Field(&quot;bar&quot;).Resolver(&quot;baz))\n    .ModifyConfiguration(o =&gt; o.UseXmlDocumentation = true)\n    .SetSchema(d =&gt; d.Description(&quot;This is my schema.&quot;))\n    .AddServices(services)\n    ...\n    .Create();\n</code></pre><p>With the new API you have a lot more capabilities, but do not worry, we did not throw out the old API. You still can use <code>Schema.Create</code> to build your schema. The classic API now uses the schema builder underneath so that you should have a seamless upgrade from version 8 to version 9.</p><blockquote><p>Read more about the new schema builder <a href=\"2019-04-12-type-system.md\">here</a>.</p></blockquote><h2>Extensibility</h2><p>With the new schema builder, we have opened up the type system so that it is now easily extendable. Things like our relay integration and the upcoming GraphQL filters are built upon these new APIs. It is now very easy to introduce generic schema types and translate those to GraphQL types.</p><pre><code class=\"language-csharp\">public class EdgeType&lt;TSchemaType&gt;\n    : ObjectType&lt;IEdge&gt;\n    where T : IOutputType\n{\n    protected override void Configure(\n        IObjectTypeDescriptor&lt;IEdge&gt; descriptor)\n    {\n        descriptor.Name(dependency =&gt; dependency.Name + &quot;Edge&quot;)\n            .DependsOn&lt;TSchemaType&gt;();\n    }\n}\n</code></pre><p>Moreover, we have introduced metadata support to almost every corner of the GraphQL core. This means that you can pass in context data not only into the execution pipeline but also into types, fields, arguments, directives and even into the query result. This means we let you store custom context/state objects everywhere. This makes it very easy to customize the API without introducing new base types.</p><pre><code class=\"language-csharp\">descriptor\n  .Extend()\n  .OnBeforeCreate(definition =&gt;\n  {\n      definition.ContextData[&quot;Foo&quot;] = &quot;Bar&quot;;\n  });\n</code></pre><p>You can access the context data on a type object like the following:</p><pre><code class=\"language-csharp\">schema.GetType&lt;ObjectType&gt;(&quot;Query&quot;).ContextData.ContainsKey(&quot;Foo&quot;);\n</code></pre><blockquote><p>Read more about extending the type system <a href=\"2019-04-12-type-system.md\">here</a>.</p></blockquote><h2>Relay</h2><p>We added a lot of APIs in the past to make it easy to create relay compliant schemas. With version 9 we will now make implementing the <code>Relay Global Object Identification Specification</code> as simple as eating cake.</p><p>In order to enable general support for relay you can now opt-in like the following:</p><pre><code class=\"language-csharp\">SchemaBuilder.New()\n    .EnableRelaySupport()\n    ...\n    .Create();\n</code></pre><p>This will automatically add the node field to your query type and add the node resolver logic. You now just have to declare which type is a node type and you are done:</p><pre><code class=\"language-csharp\">public class EntityType\n    : ObjectType&lt;Entity&gt;\n{\n    protected override void Configure(\n        IObjectTypeDescriptor&lt;Entity&gt; descriptor)\n    {\n        descriptor.AsNode()\n            .IdField(t =&gt; t.Id)\n            .NodeResolver((ctx, id) =&gt;\n                ctx.Service&lt;Repository&gt;().GetEntityAsync(id));\n    }\n}\n</code></pre><blockquote><p>Also see our new <a href=\"https://hotchocolate.io/docs/relay\">documentation</a> about relay support.</p></blockquote><h2>Performance</h2><p>Starting with this version we have begun to invest into making Hot Chocolate one of the fastest GraphQL servers out there. Do not get me wrong, we are not quite there yet, and it will be an ongoing effort for quite a while.</p><p>With version 9 we are introducing the first step on this road with our new UTF-8 GraphQL parser. This new parser is not anymore, a port of the original graphql-js parser but a reimplementation that uses the raw bytes instead of strings, meaning we are using all those nice new <code>Span&lt;T&gt;</code> APIs. This makes it use less memory and perform faster. The new UTF-8 GraphQL parser is the fastest and most standard compliant parser on the .Net platform.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/d447e/lexer_mem.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:105.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC3ElEQVQ4y7VUXU8TQRTdJ6M/QR98MH48+Td88EHj3/CfmBiJDyYkEjRBEq1EECUE2i08CDWQKC0tRZGCtPaLQtvdbru7szvHe6dMKdD65iQn98zcmTN37p0ZA0Oabds4Pj7G0dGRsrVaDVbTQr1eR6PRGLYMht2y8Wt3F7m9PUJO2d1cDqnNTWym09hIJpFMpZD4msBqYhVfVlZobAM/d3aQzmTUvMzWllrrOA6MUqmExVgUsbiJqGkquxiLkY0rmEuMJUx/nMHbSASRqfdqfPbzJzwbGcHE5CRmZmdpbQzVw0MYfJS5uTksLCwgGo1ifn4e6+vryG5vI0MRKGxlYFkWfN+H53n4fXCA/f19ZLNZHJIIj7daLWUNzpFJkS0vL2OJIonT7mtra9jjFNDRGcxd11U5CsMQQgiV4yAIFLixn8cNnsDKendBNhQ+pJQ98BwNyIuF4DkszNY473RoTaomUMjnUaT85vMFlMpleL5QWjkni0q1imKxhELhD8rlChrN5mmV+yMBR0PwA1INBSHoQvKxpAJ5yYTdMeULFbSGcT50bg3bQcOTsGht3Q0Vb2rudsdVvxMqa/sS4iSXxqkYIMKu4FjawdV3Ie5MAzc/SIVbJ1Zzxm3C9SmJe4sStivOCnLTgk+/t2GMhjBe0RHG/wH2v5S4QaKWFtTHlCp33Tw9T5LgeIgrbyQuTQzHZYLxWuLuTJ9gf+50e/KtA+MFRTjWjWAo2D8qcS0yIMImlb5cqcKz65j60VJ5eRQHHphS4eEZTmBrhrgfAx4nJBzvnCA/bP5FbHpCbsvC6Q3m6oUDOPtFjwfBP47ctGx1Fzmlngjg9XNBT4+4TwV06bKLk9vBz+5CUTTnd6qeGcdE92sQ57lapJ8PvNj/VZCtHu/nuq/XaT5QkP82PaHT6fR25y+KfyQdbbvd7glzUYe+ZRbRgpVKRW3Ajf9Ohr4VxWJRcf768vQ78cZ/AbfaCJYjPTQgAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Lexer Memory\" title=\"Lexer Memory\" src=\"https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/7842b/lexer_mem.png\" srcSet=\"https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/f8f3a/lexer_mem.png 200w,https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/6a8a8/lexer_mem.png 400w,https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/7842b/lexer_mem.png 800w,https://chillicream.com/static/f7cabb37d746a966fa055de8aff5062e/d447e/lexer_mem.png 1064w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/28203/lexer_perf.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:107%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADfUlEQVQ4y31VzWsbVxDXpYFADiG39tCQWyGBQAOltLkktBRyzCFpmlNqCi2lt1JI83Hp/xBicOIkNg7UToPr2lJxZFsixkTESqJIsuNYsQpaabUr2bJW2u99v857b9efIgM/dnbnze/NvJl5G0MPcV0X3W4XnU5HwLZsmPRuWRZs2xa2XsIYQ8w0TdRUFWq9TlChaRpWS6vI5/MoFArIvc4JfWFhAfPz88hkMsjT97W1NYHVUglKVUGr1RKkMUVR8O+TaSRnZ/BkhiNJ+ixmU3OYmZvDXDqF6WQSjx4/xujYGMYn/kb66VPcHRzE7f5+/EnfJib/wctXryShStGNj48jkUhgcmoS8XgczxcX8ZqiyuVytPAllpaXYHQMAV3XRVQrKysi8s3NTQHDMGTKjUYDSYoglUphliJLp9PIZrMol8sipRI5VyqVXedbq9bgOI4g4MLTbbfbMsIgCIQxgkvwycnzfXieJ+CTztexgBEgdSJjYSG4nUMQ7q1U0wUKmgm1WqEiaagoVeiUBZdNfwPl1ir0ehPVWk2gruli860qi51C0Cd4Ad+Rh+ERfAkelhDu6Mp35ksgEH6Rf2xnD3GxKeVa24buAJoFqF1fPDWLQe0E0EnXbaBuBgQmbBsO259yEBLWDBcn/7Lx0ShwdIzh49EQPfRj9DzykOFymnyZRxwhIY8uIqy0XRwechC7Q8ZBSuHue3CP0M9wNtGD0A8koUKEH45YiN1nODAU4IMHHKT3wMFhIrzDcG56B2F0dpEoho9D9wPEBiCj5OD6ANsPIovdYjg9tSdC3n98AtabDSjNFn7NVPBjpoafCT89U3A16+LmC+DaYoAbLxgBuJ4NcDPL8Ntz4N5bJrqCRYS8QnysrC5V16jij3fncfW/s7hW/hq/l79CK3gTxu+I1thuoaidmBgAUeW9KTdtDT/kz+Db4klcLp7Cd8VP8bZbEDbTdWSfkovj+XCpXz3S+flvEW5XWe7WtOr4ZekbXHnzGfqWv8D3y59jzVqSc+xtz280jpH/LkLZh9LYsFT05b/EheInuFQ8gYvF4yiZeZnwHkJ/x8jtI4wWGnYbCXUE8fUhxJvDmGoOoeU1QhJv1+0c+YgMw2j3EbqOK89enjWYuW3nv4JoHb/pOUR2RMZ/FT0JudHzXaqfL56WY4GFleVpbW1MVxxH5Mtbj8v/gb/ur3ipFaIAAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Lexer Performance\" title=\"Lexer Performance\" src=\"https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/7842b/lexer_perf.png\" srcSet=\"https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/f8f3a/lexer_perf.png 200w,https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/6a8a8/lexer_perf.png 400w,https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/7842b/lexer_perf.png 800w,https://chillicream.com/static/64c1183409d96db4f97ebf220b09d746/28203/lexer_perf.png 1094w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/9ed60/parser_mem.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:107%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAABYlAAAWJQFJUiTwAAADbUlEQVQ4y5VVW28TRxReIW6VeED8g1ZCfYFIvPBA+8JTfwCqCkWVkGj4DUggcWkr3lB5QC1RSwhxEwhVIVEISkIEuRQ1tsFu6rudEuXi69pevN71Xmb368xZ20kdA2Ki43PmzMx3zvnmzEZqNBpQVRX1ep20rutYWVlBPB5HKpVCNBpFMplELBZDPBFHJBpBoViEaZq0V4g4a9s2xJAi/MCz2VnM/7lAMrcwj+dzc20RvieTk/i1vx/3H4xg5PcH+PHGDQz6fBi6N0z29MwMijwIAb4KhTA6NobJqSk8npjA1PQUFv1+BIIB+AMBsoMvg0imkvh7aYn7g5jkAfwBP2K8iqV/PJ+iKB5gOBzG6KNR2jQ+Pk5a+DKZDNLpNBKJBNbW1mjz6uoqKpUyDMOgEh3HIX82m4WgjgCr1So58vkcsrkcilwr/FCtpnKpkQiOGGPQ6jpsi9FBASZAXdclHtscomOoLiDrNnRNhdYkXG/otGbDhGKWoda8SxSiaRoFE0OAS+JHiONwJNeBbAD/llTkCwUU5ApyxRLKyhswvqwyDdl6FiVZQb5U5iKjWlWIgjZgOzU+IcVE6gzbh9uU7qPFp7SJ5222LRO3IjouhoCrYReXXjFc4bqrHXJQNrxAVieHVDqFstHzhwnpJl/s4yX0cX3L9WSrTXMXCcXL3twK2OKRAJmF4+MGpH7gI5+L3YPbZY/Qd13s5Tpd6wBslbpJho1jYzqkXxikARvSHSHcvuNukx0DLlJv3pKhZVmcBwbHauCLCWDnAHBgCNj/G7DPB+y662VFetDTe7plSBfBJ/l8nhq8Wq7A9/oprmVGcH35Ia6lhjG4GkC4DCwWbARlFy9lwF90ECg5MJgHaHeW7HHI/7j/h+VvcDr5Cc6ljuBU/GPczp9v3py5pXUEktM+a3e7FLK5/7t0L07Ge3A28Tm+ih7GzxuXaK3BW4qJR8C3Cnps9l5AL8PvM9/i6/hh9CY/w8nYIfRlPUDTNtuBxXNrNfM2wM3G9gAvp8/gy9inOJM4ihORg/hp44IHaBkfCshLMS0kqiFEtL8Q0wJYUl9g3Vj+3/PqpOmdT0982h2juZEHlTcqpB3+4VhfX6d/E2Lk+KdOlmWyK5UKdUhXQKGZy8vhwniTG2aDbOGnYM1MRN+2yhTli7kY/wHGAO8IJRcQjAAAAABJRU5ErkJggg==&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Parser Memory\" title=\"Parser Memory\" src=\"https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/7842b/parser_mem.png\" srcSet=\"https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/f8f3a/parser_mem.png 200w,https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/6a8a8/parser_mem.png 400w,https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/7842b/parser_mem.png 800w,https://chillicream.com/static/b7dc8afffeb13b8da051f2c434fb604a/9ed60/parser_mem.png 1058w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/9ed60/parser_perf.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:110.00000000000001%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD20lEQVQ4y4VUS29bVRD2CsEaCbEDqVQqVYFFC1JA4rlBqkQK4iEEtBSQgAUSYgG/gA2QqlVF20BoVQpUSnBC1EZJU8cOCyKcVBGN49jYjl+F+Hl97/V9Pz/mnGvfhOKIo3yeycy535kzM2ciGLA0VYOu61AUhUvDMKCqKpemaXLboOX7PiKqpqHeaKDZbHLUG3Wsr69jY2MDqfUURzqdxsqNG1haWsLKygp+TyZRrpTRarVQqVRQq9XQpcPZihRLJcxdn8dCIo5YnEAy/usi4osJwiISpDP7xUvfY3xiApO/TOHs6Ci+PnMGP16+jBMnT2IiGkUmmw0Iy+UypqenMTc3h6szM5ghJJeXsZZK4Y+bNznW1tZQq9dQ2NxEPp/H6uoqUuRvNBuo1+vI5XL8dpywWq1idnYWsesxzF+7hlgshmRyGUX6uFAocBSLRXiehwalhoHlil1TFEVO0ul0IElSQGjbNjTKIwPLp0GwDR2WZROsEK7rcsANCsAOYOjr3McIb6+USvai5EDuCBSBhHa7DVmWw4//NkrcLkoij1AQBF79sMrspw8ywSDCmuqgQ5tFWUFHkiErKmzXB/2hbbb4/1I38IlyF5phwusFFNnZQ2y5tkWNSLlxqddsDbCUbWnIgEm6o23buE4HKiIcx9km9HqEkm7heMLA4QXgyIKHF2IuhkkeiftcDi+4ZA905nsx7uH5GPDpkgrPsf5L2NZs3P0DOUYp/DHKyRjJb/3BGOvtOQccjFKkbo+QXbdPKBDhA+MmIheBOy/5uON/cBchcgF45gpLhRUUZecSdAf3/qTTyR4i591dwHx+gAssWmBoakeErId03aADTLS6Bp69CuyJAvungH2TwIM99PW95Lv/Z59jT9THPePAK/Ma/H4O2QRhT6jZoAEhNvFd+SxOVb/A6eoITlW+JPlVgMoIRsqfIyH8hi41Q53SI5g+OkyX6EHYA67ctSR8lHkOr2X24s3MAbyR2R/irexDeCl9HyZbp4NCuibvXR6UrvEXtaMoQWt2TRGfZIdxNHsI72Qfx/HsUIh3s0/g9Y2HifCbgIQi6heTPduQMCDdJvw4c5giegTHMo/iaOZQiLezj+HV9D5Em+f4Xss2wweh7U4o4bPcy3gvP4QP8k/h/fyTIT7MP41jfx7EFeE83+t4TpgqNsVvIwxOMkwDxWYOf3VLqEqbKAk53JKKuCUXUekUUO7k0VaaFJHOhwaLjJGxETaQkI0zQ6NkU8C24aDdEOCaHh9biqRCpWqyy6iqgq2tLT5pWNuxyfNvwl61+OSB37MExQp9gQW7LfbtPxA6DHuGF2AzAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Parser Performance\" title=\"Parser Performance\" src=\"https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/7842b/parser_perf.png\" srcSet=\"https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/f8f3a/parser_perf.png 200w,https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/6a8a8/parser_perf.png 400w,https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/7842b/parser_perf.png 800w,https://chillicream.com/static/c54a7fae6e81fa68fe27bb657dc13831/9ed60/parser_perf.png 1058w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><strong>What do these charts mean?</strong></p><p>The new <code>Utf8GraphQLReader</code> is our new lexer implementation, it does not allocate any extra memory to do its work. All allocations are done on the stack which means that we produce less work for the garbage collector.</p><p>Also, we only need 1/4th of the time to lex a document compared to the <code>GraphQL-DotNet</code> lexer.</p><p>What you can also see is that the <code>GraphQL-DotNet</code> lexer is unable to lex the kitchen sink test query which is used by the reference implementation to verify that the parser and lexer implementation perform as specified.</p><p>Furthermore, the new UTF-8 GraphQL parser uses 1/3 of the memory that the <code>GraphQL-DotNet</code> parser uses, meaning that we again produce less work for the GC which means that your server has more time to execute your business logic.</p><p><strong>Why does the parser still allocate some memory?</strong></p><p>The new parser still allocates some memory since we are producing a syntax tree here. The syntax tree is still the same syntax tree we produced with our old parser implementation in order to be compatible. This is where the allocation stems from. The parser itself is a <code>ref struct</code> and lives on the stack. So, all the parser state is allocated also on the stack and is gone after the execution has finished.</p><p><strong>So, how do we compare to graphql-js?</strong></p><p>Since, graphql-js is the reference implementation all other implementations of GraphQL should compare themselves to it.</p><p>At the moment graphql-js parses round about 52000 kitchen sink queries a second on my MacBook Pro compared to our new parser that does 48000 kitchen sink queries a second.</p><p>So, with version 9.0.0 they are still a little faster.</p><p>With our new version 9.1 parser preview we are hitting about 54000 kitchen sink queries a second. While version 9 has become the fastest .Net GraphQL parser implementation version 9.1 will start to rival other platform implementations.</p><p>Apart from that we have started making our execution engine more efficient. We are just starting here and there will be a much larger investment with version 9.1 when we are introducing our new UTF-8 request parser and the new execution plans feature.</p><p>With our release today Hot Chocolate is depending on the use case at least to times faster in executing queries and uses half of the memory compared to GraphQL-DotNet. If you are using schema-first then the performance gains are more dramatic and you could look at up to 13 times faster execution performance compared to GraphQL-DotNet.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/4dc7d/exec_mem.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:111.99999999999999%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAABYlAAAWJQFJUiTwAAADiklEQVQ4y4VVTW/bRhDlD+ih17Y/oLecemtvRXtu/kl+RuICbU5t049cirbooQcnctzaomNVsS05luQEiA1YkfXh6JOiSMqUSO5y+Tq7K9KKIqAEnnYw2nk7M2+4NLDyJEmCyWQCz/Pguq6yJaTt+z5s24bjOJjP51gXawRBgGaruUALjcsGqrUaaoQXL1+gUq2idnqKYrGIw6ND8r3E3tM92lNFu9PBKf13UjlBu91WpMaETtvJ57Fj5tW6u2fCpAC57pqmWp8WCvj2/n18/+AH5bu7cQ8PfvoRuSdb+PnhL/jtj9/psCNN6FJpeSLbJbI8Bf+zs4NC8V+UymUclY4WKOHg8ADFZ88omwrZh9inQyqU5auzM5SPj6myS004nU6xtbWFXC6H7e1tbG5u4oACLy4uFOqE8/NzcM4xn83Q7XZVoOzxaDRSdodKl71VhGEYotFooF6v4zWh2XiNFvVDbh6PxwrWyAKLGBhnikgIgZB6f+3PSQgosVKRjGWVYsJM/iQCPI5VoIgFGELM2YxIOWLyR1FE5LRR+OCRTz6hKlAqyx8ZSP/CDoFX/SnsYQ+j4QDe1MN4ZMNmQ1zZLQx6Q1hji7J00R/aSII23HETb7oD9Pt9MMY0IaWkUperfJjMQjsWA4a1j1jjV4QpuNDkv54F+OSR3iBLk2WqlizZgvZy6ikWFWYlvzXpi/VJc4CvCiVEYowkpr5x6kWiVxFHyk4EA2dBZseSUGYomXu9HgaDAfXiCp51jdLIxO36xziYl3SWaYkLpIfHy4IK3IiiVKOGhlEgBUanb+Lx81voXdxB0vwGUeMu4ubXYJf3FKTNmxtgDWlvgJOP++13xyY9P+z8RXUbiP82EGwbCP8HAe1l1v67oiSJJnScLiKnDDGtIXar4IRkeqrWeGELrwbuVG7syFuXoX6uXJ71Ryz1Kl7pIU+W+hnrpIxUcrmqkSBnzx2SLRWU6gUK2pYqc/UmJSKmuGjJ5mqW1eUgFZaTPqC3w7EnaDutLJNlZSkJIoyzy1SSpLac0UzlG+jNXi+PsPwZ2MmXiJ5/jujkC7DjT8G6f2pymdUK4frBXhDO3uQQmO8j2v8QUeEDwkcIzffA2t/p4U90NvoOwFv2Soa6y75/TaUxVaznTjDzvcwvvydq2GluLcvK4mTbZJbG6kdGv6ciew0Z43SV6dP54upK98i7NI2RtvT9B2s2asi4He/qAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Execution Memory\" title=\"Execution Memory\" src=\"https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/7842b/exec_mem.png\" srcSet=\"https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/f8f3a/exec_mem.png 200w,https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/6a8a8/exec_mem.png 400w,https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/7842b/exec_mem.png 800w,https://chillicream.com/static/0fbdc6bb987029489a6d4b423f213bde/4dc7d/exec_mem.png 1066w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/79afa/exec_perf.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:108.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAABYlAAAWJQFJUiTwAAADlklEQVQ4y3VVz28bRRS2EJWQ+udwKidu/AVIHLn0Au21cEAgpF45A0WQliQVAiQUcEhxSGwnacHk1IPXre16HTn+seuN1157d707O/sx743XcX50pKedeTPzvZn3fW82h0tNSokwDDGfz9m4vxhTP7Moii5vRZqmyCVJgkAtCIKAN41GIzSbTbRaLZhtE41mg/vkazR0v16vo9PpMKjv+5jNZryXWu7s7Ax7xX0UyyXsl0ooHZRx+PQIB0dkh/w9evYM6xsb+PnXX3ju+7Uf8NvWFv7aLWDj8SYerf+Iyn8VDegowGK5zICZUYD9UpFtr1hUQQ6w9vAh1jc3UT48wDcPvlVAj3nfk0KB11eNqgYcj8fI5/PY2dlBQUXc3t5GpVJB7UWNFxmGgWq1Clo3HA7R7fX4enT1gWVhOp1yChzH0YCe56GsImVWVNc+Pj6GaZpsbbPNmwmENvcUIDXXdRkkVnkkH80xIDFDzBI5MhGKKslj8i9NEoWaxdW5RJJP+7OWg17LbaCIet7zYPd76Fs2PG+CoeVgKLs4GaordgcgEl33DAN7DAQvMXGaOO3ZGAz6EELoE6Y6DKT6xBQ2CZFGAfxAyymYKwt83VcWssxInz7CFT/rMAOU/CVlC3zxr4ef6qFCD+Cp3IS8ec6aI9PiDpT+/GURUE75hFfkjgS3thJ8+Xyh/mSlEmSigspspHO+aBQojmPkSOXEFkWg/ARegPv1+7hdfx+fn3yIe60P0I5M3iQoG2kGp8cZH4TDJyRkAiKdjdwRfC/EWusuPq29jc9q7+IT4xba4z0gUhLxTST+CdL5KWTYgZi11anFRcArjwNN/vMekic5iL9vQuy+hWj3BuaFN6+xNyD9VwtA7yLLWkspYpHCb3wFYdxGXLuLqPoRRO0OW2x8zCaUPzbu8FwaDReA04uAUupkTIII3dlKni6d/pwSou9cw6+98jRKcOoq0SJSDIcQ0Ux9leJTgUREitmI+6mMIeJwWSVLQGKYzLItuCMX1qiPbmhde0IuTymXjykBXAHMxEoOEunEn2LYzyO1/0Bi/4m4v4XE2eXTJkozBPo6QNbhFZbVfPD0HcT5HCLFdLyjbP8mMO+sZO/8yc8ald41LKtqU2odmb/Da34Hr/UIjvE1xq824E+V+McT1izdiJ4reh/pS2CWehvphrnL0ShKGGkGyZxxjCDSFUHit217+SPrdrtcxzQmP83/DwRcZNAVpO4pAAAAAElFTkSuQmCC&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Execution Performance\" title=\"Execution Performance\" src=\"https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/7842b/exec_perf.png\" srcSet=\"https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/f8f3a/exec_perf.png 200w,https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/6a8a8/exec_perf.png 400w,https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/7842b/exec_perf.png 800w,https://chillicream.com/static/4b5b87ea53242bcab448e6b107947acd/79afa/exec_perf.png 1078w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><strong>What will the new UTF-8 request parser help?</strong></p><p>The UTF-8 request parser will be an integrated JSON and GraphQL parser that does not any longer parse first the JSON and then extract a string that is then being parsed by the GraphQL parser. The parser will be able to parse a GraphQL JSON request in one go.</p><p>Also, we will create a server benchmarking suite based on <em>GraphQL Bench</em> so that it is more transparent what we test and how we test.</p><p>We did our performance comparison against GraphQL-DotNet version 2.4 and 3.0.0-preview-1107.</p><p>## Documentation</p><p>As we promised in the past, we are adding more documentation with every release. With version 9 we are adding documentation for our type system and a completely new tutorial that starts from scratch and shows how to build a GraphQL server with mongo as a database. We know that the more effort we are putting into our documentation the easier we make the life for you.</p><p>With this release we have published a first draft of the new documentation and will add missing parts during this week.</p><h2>Banana Cakepop</h2><p>When we released Hot Chocolate version 8 we announced a new <em>Hot Chocolate Developer Tool</em>. Since that announcement we were heavily at work building that new tool.</p><p>Today we are anouncing <em>Banana Cake Pop</em>, a new tool that will help you explore and query GraphQL schemas.</p><p><span class=\"gatsby-resp-image-wrapper\" style=\"position:relative;display:block;margin-left:auto;margin-right:auto;max-width:800px\">\n      <a class=\"gatsby-resp-image-link\" href=\"https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/a0718/banana.png\" style=\"display:block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom:60.5%;position:relative;bottom:0;left:0;background-image:url(&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACfklEQVQoz2WS204TURSG52kMidHoBW/hpcZojOHCC298Bg+RaIxGTOQoYEQBIwom3PgAHjAEoaWlBaYUgZbOtHOe2XvPnsPvmoEmVlfyZ63Zk/2t01YGBmdxb3wJT6aXcXd0EfcnljH2/gum5j5jbOYTRt8sYHhqDsOTsxiZnsermQWMvJ7H+MwHvJiax9DEO4o/YvztIiZml6Ccu/kMqxubaBzu4/DoCI3GEXzPAxcSju2AuQ5kJCFiCR4J2PTNhUDIGFwWgocSURQhlBECxqFcuD6IDZVAmo5Ouw2PYGEYwqOfgW1DODYBOLwwgE9qascIuICwLDC6Y7qcwBJdU/ouP8DX4i4qag379To0TYPvB4jjBMI0kFD2v80yLXApEVMS5/cBLIMqljHSNM2lnLnyEL/KKnRdQ7N5nAM930dIoEBrgdF5Ep9cyMwwTbgBI6CAo6oIdL0nodJ39RGKlRocyyCYngNt16WsNBealyB1s2fWMQw4no8kSSB9D4HPYPkSlhfmUs5ee4xCdY9a6aBFsAzo0BwFVRiTuqCutx0HHlWYAeNQIAg4dEdAt8nbDMr5G09RrNb/A4ZR3APrxhG179PCYvJZ25zijhvC9EQu5eLAEIrbvUCPWnIZZc+Wwxki2vopj54QAWnLXSCjCttUYedUSv+tl3mFptFGq9UiHcOithhdigiWpsmJkhMvabYevcHs7UWcE5ARiOfKnpDSf3sS5VoTLi2iY1hoGyaE7H0q/5pIToMkpQQpbEGz5RTTuXLpznOs/PiOenUD26U17JD2KoXcF1e/obS2gvL6z9zvltdR3y6hVi2S38T+TgkHahmH6hZqW/SvWsAfWKxuSGcoOn4AAAAASUVORK5CYII=&#x27;);background-size:cover;display:block\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Banana Cake Pop\" title=\"Banana Cake Pop\" src=\"https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/7842b/banana.png\" srcSet=\"https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/f8f3a/banana.png 200w,https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/6a8a8/banana.png 400w,https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/7842b/banana.png 800w,https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/5ece7/banana.png 1200w,https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/0d4f8/banana.png 1600w,https://chillicream.com/static/12ed3d237223a3b0e5fd5a466c1722ee/a0718/banana.png 2830w\" sizes=\"(max-width: 800px) 100vw, 800px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0\" loading=\"lazy\"/>\n  </a>\n    </span></p><p><em>Banana Cake Pop</em> is <strong>NOT</strong> built on top of GraphiQL like all the other tools but built from the ground up with <strong>Monaco</strong> at its heart.</p><p>We plan to invest a lot more effort into <em>Banana Cake Pop</em> going forward. Our plan is to build this ultimate GraphQL developer tool that provides advanced schema browsing, querying GraphQL endpoints, creating runbooks and many more things.</p><p>We will provide a plugin model so that you can add your own extensions.</p><p>Moreover, as we are introducing our new schema registry with version 10 you will be able to configure your GraphQL gateway via drag&amp;drop, see how each GraphQL server in your network performs, how long each resolver takes and how much memory a resolver uses.</p><p>We will start very soon with a private preview and as the version matures, we will release a public preview probably together with version 9.1. If you want to participate in our private preview head over to our slack channel and send a message to <code>@rafael</code>.</p><h2>Roadmap</h2><p>With every release we are giving a little roadmap what we are working on and what is coming next.</p><p>As you might have noticed we have not delivered all the announced version 9 features yet. The reason for that is that we have decided to split version 9 into three releases. Version 9.0.0 focused mainly on the GraphQL core and brings all the new schema goodness with it.</p><h3>Version 9.1</h3><p>With version 9.1 we will now focus mainly on the server implementation, server performance and the new GraphQL filters.</p><h4>GraphQL Filters</h4><p>GraphQL filters or as we called them before Prisma filters will allow you to configure filter objects that are executed on <code>IQueryable</code> with just a view lines of code. This will make it very easy to expose databases through GraphQL.</p><pre><code class=\"language-csharp\">public class PersonFilterType\n    : FilterType&lt;Person&gt;\n{\n    protected override void Configure(IFilterDescriptor&lt;Person&gt; descriptor)\n    {\n        descriptor.Filter(t =&gt; t.Name).AllowGreaterThan() ...\n    }\n}\n</code></pre><p>As with all our types we will have an approach to infer possible filters and apply them to your API. You can declare that you want to define all filters explicitly or decide to override/limit specific filters. I myself are really keen on this one since it will safe you so much code. You will be able to pipeline filters with sorting and paging which makes this super powerful.</p><blockquote><p>Follow our work on filters <a href=\"https://github.com/ChilliCream/hotchocolate/pull/711\">here</a>.</p></blockquote><h4>Subscriptions</h4><p>We are supporting subscriptions for a long time now, but we were never really happy with the implementation.</p><p>The implementation was rushed and is not as we would have liked to implement it. With version 9.1 we are now swapping the implementation out with one built on top of the pipeline API of .Net Core.</p><p>This will create a very nice and clean API that will perform better with less memory usage. We pushed back subscription stitching in order to first get the backend sorted out and use a lot of the new code to build the subscription client we need for the stitching layer.</p><blockquote><p>Follow our work on subscriptions <a href=\"https://github.com/ChilliCream/hotchocolate/pull/807\">here</a>.</p></blockquote><h4>Execution Plans</h4><p>The execution plan feature is our biggest endeavor in version 9.1 and will fundamentally change how we execute queries. As of now we are executing resolvers level by level.</p><p>With execution plans we will pre-analyze the query and create a plan that defines which part of the query should be executed in parallel, which parts of the query could be inlined and so on.</p><p>Think about <code>@defer</code>.</p><p>With <code>@defer</code> you will be able to defer the execution of parts of your query. In order to understand this let’s look at an example query:</p><pre><code class=\"language-graphql\">{\n  blogpost {\n    title\n    text\n    comments {\n      user\n      message\n    }\n  }\n}\n</code></pre><p>The above query for instance represents a query to fetch a blog post with its comments. The query engine will return this query only after the blog and the comments are resolved. This means that the blog might have long loading times if it has many comments.</p><p>What if we could send this query like it is and get the blog data immediately and the comments once they have been resolved? This would let us specify a query once and profit from <strong>DataLoader</strong> usage and at the same time give us the most important data quickly.</p><p>This is what <code>@defer</code> is basically for. <code>@defer</code> lets me tell the query engine that some data can be delivered later so that the query engine can prioritize on the other parts of the query.</p><pre><code class=\"language-graphql\">{\n  blogpost {\n    title\n    text\n    comments @defer {\n      user\n      message\n    }\n  }\n}\n</code></pre><p>The execution engine can now branch this comment off and resolve it independently from the original query.</p><p>Also, execution plans will help make our stitching layer more powerful by being able to map out a plan what to get first and how to fold in data.</p><p>Execution plans can be created ahead of time and can be persisted so that consecutive calls will profit.</p><p>We will have a lot more to say about execution plans as we progress with this feature.</p><h4>Batching</h4><p>We are working to introduce batching and <code>@export</code> support. Batching lets me send a couple of queries at once to the server. The queries can produce variables and consecutive queries can use those. This is super powerful when you have mutations where you need the output of one mutation to execute another mutation.</p><p>With batching you can do that without having to manage that flow on the client-side.</p><pre><code class=\"language-js\">[\n  {\n    query: `\n      mutation ($input: TokenizeCreditCardInput!) {\n        tokenizeCreditCard(input: $input) {\n          paymentMethod {\n            id @export(as: &quot;id&quot;)\n          }\n        }\n      }\n    `,\n    variables: { input: &quot;...&quot; },\n  },\n  {\n    query: `\n      mutation ($id: ID, $transaction: TransactionInput!) {\n        chargePaymentMethod(input: { id: $id, transaction: $transaction }) {\n          transaction {\n            id\n            status\n          }\n        }\n      }\n    `,\n    variables: { transaction: &quot;...&quot; },\n  },\n];\n</code></pre><h4>APQ and PQ</h4><p>Another feature that is aimed at performance and bandwidth usage is automatic persisted queries and persisted queries.</p><p>Persisted queries are queries that you have stored with the hot chocolate service before deploying your application. With relay for instance you could export all your used APIs and export those to Hot Chocolate. The Hot Chocolate server could then validate and compile those once.</p><p>The frontend on the other hand has no longer to send the query to the server that it wants to execute but could just send a hash of that query.</p><p>Each execution then would fetch the prepared and optimized query from the cache or if not already on the cache from the query storage.</p><p>This saves time and bandwidth.</p><p>While persisted queries require you to setup some build scripts that extract the queries from your frontend and store them with the Hot Chocolate server, automatic persisted queries is a flow that you could use to add queries to the storage from the deployed frontend at runtime.</p><p>The automatic persisted queries work like the following:</p><p>The frontend will always assume that the query is already persisted with the server. So, by default we will just send in the hash instead of the query itself. This means that we basically do the same thing like with persisted queries.</p><p>If the server returns an error that it has no query stored with the specified has the client will send the request again, but this time with the hash and the full query.</p><p>So, while this will cause a slower execution for the first user of a query all consequtive users will profit.</p><p>We will have an abstraction for the query storage and a default implementation that will use redis.</p><h4>Performance</h4><p>The performance focus for 9.1 will be to make the server implementation faster and use less memory.</p><p>Moreover, we want to optimize startup performance and will introduce lazy resolver compilation. This will compile resolvers on first use. You will be able to choose if you want resolvers to be compiled at startup or at first usage.</p><p>We also will add support for custom resolver compiles. This will allow you to write nice extensions and simplifications on top of the schema builder.</p><p>The main focus for performance will be our visitor implementation which is not really optimized at the moment.</p><h4>Spec Features</h4><p>Specwise we will start implementing a new draft feature allowing interfaces to implement other interfaces.</p><p><a href=\"https://github.com/graphql/graphql-spec/pull/373\">https://github.com/graphql/graphql-spec/pull/373</a></p><p>I just looked again, it is not yet draft, but we hope that this will be sorted out at the next GraphQL workgroup meeting.</p><h3>Version 9.2</h3><p>Version 9.2 will mainly focus on the stitching layer and will integrate the new execution plan feature. Also, we will finally do it and integrate subscription stitching.</p><p>On the experimental side, we will deliver our new GraphQL C# client. We have already started on this one but want to have a first release ready with version 9.2. We also want to have it compatible with Blazor and show case this with the that release.</p><h3>Version 10</h3><p>Version 10 will be a huge release. It will take about three to four months to complete and we might decide to split it like version 9.</p><p>Version 10 will finally introduce our long-promised schema registry and allow to stitch together schemas without needing to code. Also, we will not need your microservices to have any knowledge about the registry or that they are rewritten into a larger schema.</p><p>With version 10 we will also release a production ready version of our C# client.</p><p>Last but not least as another new addition we will support automatic database mapping. This means that you can come with your database and we will make a GraphQL server from it.</p><p>We will support two things with that, building a database with GraphQL just like Prisma does. Moreover, we will support generating a GraphQL schema from your database. So, this will be pretty interesting stuff.</p>",
            "url": "https://chillicream.com/blog/2019/06/05/hot-chocolate-9.0.0",
            "title": "GraphQL - Hot Chocolate 9.0.0",
            "summary": "Today we have released version 9 of Hot Chocolate. This release was mainly focused on the schema APIs and performance. Furthermore, we…",
            "date_modified": "2019-06-05T00:00:00.000Z",
            "date_published": "2019-06-05T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/05/08/performance",
            "content_html": "<p>Today we release preview 27 of version 9 and we are heading toward RC status which we are planning to hit next week.</p><p>This post will describe what we have done since preview 9 and where we are heading.</p><p>One of the main focuses on the second part of this release was performance. Performance will stay one big focus point for us going forward. This means that every new release should be faster then the previous.</p><p>Lets have a look at what we did with version 9 and what we are planing to do in this area in the next releases.</p><h2>Parser</h2><p>The version 8 parser that we have built and maintained since version 1 was a very close port of the nodejs parser of <code>graphql-js</code>. <code>graphql-js</code> is the reference implementation of <em>GraphQL</em> and also is basically the core of <em>Apollo</em> and <em>relayjs</em>.</p><p>The problem that we had with the approach of the parser was that it parsed a string. Basically, the parser tokenized the string which meant that there was a lot of substrings creating new strings and so on.</p><p>Each time we use the V8 parser to parse a <em>GraphQL</em> request we basically created a lot of objects. Instead of just producing our parsed <em>GraphQL</em> document we have created a lot of garbage for the runtime to clean up.</p><p>With version 9 we wrote the parser from scratch to be allocation free. This means that we only use memory to create our GraphQL document tree but not for the actual parsing.</p><p>In order to do that we are no longer parsing using a string but a <code>ReadOnlySpan&lt;byte&gt;</code>. With spans on byte we can basically read the query from a binary stream and produce the GraphQL document without producing string objects. Also, the span allows us to slice the incoming data and create new windows on the underlying memory. So, each time we slice the data, we no longer create new string objects that the GC has to get rid of. All of the GraphQL keywords in a GraphQL document that is being parsed are never transformed to a string representation, but will only be represented to the parser as one byte on which the parser makes a decision on what the parsed token means. Also, comments and descriptions will only become strings if they are consumed saving us from unescaping those and more. On a production GraphQL server we do not have the need to consume comment tokens for instance, so we can just skip over them.</p><p>Furthermore, unescaping strings is now much more efficient since we create the string representation just once, all the escape logic is done on the span. We still have to get a second array on which we insert the escaped data but this second byte array can be rented if to large or in the best of cases be allocated on the stack with stackaloc.</p><p>But again the parser will only escape a string sequence and create an actual string object if needed.</p><p>Moreover, our new parser is now a <code>ref struct</code> meaning that all the memory we allocate for the parser state is allocated on the stack.</p><p>We still will keep our old parser around and will update both parsers going forward.</p><p>But we did not stop here. Actually, the GraphQL HTTP request is really bad to be processed efficiently. So, with version 9 we are actually still parsing from a string with our new parser.</p><p><strong>GraphQL Request Example</strong>:</p><pre><code class=\"language-json\">{\n  &quot;query&quot;: &quot;...&quot;,\n  &quot;operationName&quot;: &quot;...&quot;,\n  &quot;variables&quot;: { &quot;myVariable&quot;: &quot;someValue&quot;, ... }\n}\n</code></pre><p>The issue here is that we first have to parse the server request which is JSON and then can use the GraphQL query stored as string in the JSON structure to parse the actual GraphQL query document.</p><p>This means that with version 9 we are around 2 to 3 times faster than any .Net parser implementation.</p><p>But as I said we are <strong>NOT</strong> stopping here, we are working on a new specialized request parser that will integrate the JSON parser with the GraphQL parser. That means that we are able to read the GraphQL request directly from the network stream and parse it without any manifestation to a string object.</p><p>Version 9 will bring the new <code>Utf8GraphQLParser</code> and we will follow that up with the <code>Utf8GraphQLRequestParser</code> in version 9.1.</p><p>In our experiments we see that this new request parser is about 10 times faster then the GraphQL-DotNet parser combined with Json.Net.</p><p>Also, as a side note the version 9 parser now supports all the GraphQL draft features and represents the most GraphQL spec compliant implementation on the .Net platform.</p><h2>Resolver Compiler</h2><p>With version 9 we have removed the Roslyn compiler and are now using the expression compiler to compile our resolvers. This change was done since Roslyn caused the server to consume a lot of memory. Most of the memory was consumed by native metadata references and we were not able to solve that memory consumption issue. At Microsoft Build I talked to David Fowler about that and he knew about the issue and recommended that we move to expressions. The downside here is that the resolvers produced by the expression compiler are actually a little bit slower than resolvers compiled with roslyn. This has many reasons I do not want to go in here.</p><p>With version 9.1 we will further optimize the resolver compilation by allowing lazy compilation, this will improve startup performance and memory usage.</p><h2>Execution Engine</h2><p>We have updated our execution engine to use less memory and execute faster. The new execution engine is at least 2.3 times faster and uses half of the memory GraphQL-DotNet does to execute a query. If you are using schema first we are actually seeing 8.9 times faster executon of queries with Hot Chocolate compared to GraphQL-DotNet.</p><p>GraphQL-DotNet is still faster when validating queries, but this is offset since we are caching validation results. Validation will be one of the things we will work on for version 9.1. So, expect improvements here.</p><p>Also, we are putting a lot of work in our new execution plan feature. With execution plans we are seeing 3 times faster query executions compared to the current Hot Chocolate version 9 preview bits.</p><p>The execution plan feature allows us to pre-analyze the query graph and in many cases optimize the execution of resolvers significantly. We will talk about this in more detail after we have shipped version 9.</p><h2>Serialization</h2><p>The serialization of query results is one of the areas we want to improve. Microsoft did a lot of work in this area and we are waiting here for the new UTF8 APIs that will ship with .Net Core 3. We are completely removing Json.Net over the next releases in order to improve performance further.</p><h2>Summary</h2><p>We are investing heavily in performance and stability and see perfomance as feature. One other area we are working on is the subscription implementation. We will replace the current implementation with one built on top of the Microsoft pipeline API, this is why we are moving again subscription stitching to the next version.</p><p>Stitching is also one area we will start to improve performance-wise once we have the execution plan feature implemented.</p><p>The bottom line here is that if you go with Hot Chocolate you will get the most spec compliant and most performant GraphQL server on the .Net platform.</p><p>Each time a GraphQL spec element hits draft status we will go ahead and implement it with Hot Chocolate, this means that with Hot Chocolate you will always get the latest GraphQL features.</p><p>Also, we are working to have all the benchmarkings ready with GraphQL-Bench. This will make it more transparant what we are testing and will let us more easily assess where we are heading performance wise.</p>",
            "url": "https://chillicream.com/blog/2019/05/08/performance",
            "title": "GraphQL - Hot Chocolate 9.0.0 - Performance Improvements",
            "summary": "Today we release preview 27 of version 9 and we are heading toward RC status which we are planning to hit next week. This post will describe…",
            "date_modified": "2019-05-08T00:00:00.000Z",
            "date_published": "2019-05-08T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/04/12/type-system",
            "content_html": "<p>Originally, I wanted to write a little post about what we are currently working on in version 9 and how those things are coming along, but every time I started writing on this post it got longer and longer and it felt a bit too messy.</p><p>Starting with this post we will start talking about version 9 in more detail. We will split this into several blog posts that will cover different parts of the new version. This post will focus on the type system improvements.</p><p>We started with version 9.0.0-preview.9 to deliver more and more parts of the new type system. With version 9.0.0-preview.11 we are delivering a ton of bug fixes and many more new features.</p><h2>Schema Builder</h2><p>The most prominent API that we are introducing is the new <code>SchemaBuilder</code>. The <code>SchemaBuilder</code> provides us with a new way to define schemas. Do not worry the current <code>ISchemaConfiguration</code> API is still supported and will not go away. In fact, <code>ISchemaConfiguration</code> now is just an interface over <code>SchemaBuilder</code> and we will evolve both APIs over time so that you can pick the one that you like more.</p><pre><code class=\"language-csharp\">ISchema schema = SchemaBuilder.New()\n    .AddQueryType&lt;FooType&gt;()\n    .Create();\n</code></pre><p><strong>So, why did we introduce a new API to define a schema?</strong></p><p>First, we wanted the builder API to be decoupled from the actual schema, we wanted to be able to start adding schema types and other parts to a schema builder without being forced to create the schema.</p><p>With the schema builder we are now more flexible in scenarios like schema stitching.</p><pre><code class=\"language-csharp\">ISchema schema = SchemaBuilder.New()\n    .AddQueryType&lt;FooType&gt;()\n    .AddDirectiveType&lt;BarType&gt;()\n    .AddSchemaFromFile(&quot;./Schema.graphql&quot;)\n    .AddContextData(&quot;foo&quot;, &quot;bar&quot;)\n    .ModifyOptions(options =&gt; {  })\n    .AddServices(services_a)\n    .AddServices(services_b)\n    .Create();\n</code></pre><h2>Conventions</h2><p>With our new schema builder, we did a lot of work underneath and introduced the ability to use services during type construction.</p><p><strong>For what is that useful?</strong></p><p>For one you can now register our new <code>INamingConverions</code> with the dependency injection and then the new <code>SchemaBuilder</code> will use your naming conventions instead of the built-in naming conventions.</p><p>Also, you can register our new <code>ITypeInspector</code> and override how we infer schema types from POCOs. This will allow you for instance to add support for custom attributes, so no need to pollute your API with our attributes anymore.</p><p>But fear not, you do not have to implement the whole <code>INamingConverions</code> interface for instance since you can override each part of our default implementation.</p><p>Since, in many cases we just want to tune existing naming conventions we can inherit from the default implementation <code>DefaultNamingConventions</code> and overwrite just what we want to change.</p><p>So, if we wanted to add to all the input type names the prefix <code>super</code> we could do this like the following:</p><pre><code class=\"language-csharp\">public class MyNamingConventions\n{\n    public override NameString GetTypeName(Type type, TypeKind kind)\n    {\n        if (type == null)\n        {\n            throw new ArgumentNullException(nameof(type));\n        }\n\n        if (kind == TypeKind.InputObject)\n        {\n            if (!name.EndsWith(&quot;Super&quot;, StringComparison.Ordinal))\n            {\n                name = name + &quot;Super&quot;;\n            }\n        }\n\n        return base.GetTypeName(type, kind);\n    }\n}\n</code></pre><p>Like with the naming conventions we provide a default implementation to <code>ITypeInspector</code> where we can replace or extend parts that we want to modify.</p><p>In order to register our conventions with the schema builder we can do the following:</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton&lt;INamingConverions, MyNamingConventions&gt;();\n    services.AddGraphQL(sp =&gt; Schema.Create(c =&gt;\n    {\n        c.RegisterServiceProvider(sp);\n        c.RegisterQuerType&lt;Foo&gt;();\n    }));\n\n}\n</code></pre><p>Or we could do it like the following with the new schema builder:</p><pre><code class=\"language-csharp\">public void ConfigureServices(IServiceCollection services)\n{\n    services.AddSingleton&lt;INamingConverions, MyNamingConventions&gt;();\n    services.AddGraphQL(sp =&gt; SchemaBuilder.New()\n        .AddQueryType&lt;Foo&gt;()\n        .AddServices(sp));\n}\n</code></pre><h2>Extending Types</h2><p>One other major reason to rethink our type system was that many of you wanted to extend on types. One common thing that people wanted to do is to introduce generic types. We did something like this with our relay types. GraphQL does not really have generic types but the idea here is that you could have a type like the following:</p><pre><code class=\"language-csharp\">public class EdgeType&lt;TSchemaType&gt;\n    : ObjectType&lt;IEdge&gt;\n    where TSchemaType : IOutputType\n{\n}\n</code></pre><p>If we for instance put in the <code>StringType</code> as TSchemaType then the edge type would become <code>StringEdge</code> in the schema. While this is not so difficult if our <code>StringType</code> has a fixed name, it becomes more difficult if <code>StringType</code> would create its name also depending on another type.</p><p>With version 9 we redesigned the schema initialization process so, that you can register dependencies for a type with the <code>SchemaBuilder</code>. This way the <code>SchemaBuilder</code> knows which type has to be initialized in which order.</p><p>So, let us have a look at how we would create our edge type with version 9:</p><pre><code class=\"language-csharp\">public class EdgeType&lt;TSchemaType&gt;\n    : ObjectType&lt;IEdge&gt;\n    where T : IOutputType\n{\n    protected override void Configure(\n        IObjectTypeDescriptor&lt;IEdge&gt; descriptor)\n    {\n        descriptor.Name(dependency =&gt; dependency.Name + &quot;Edge&quot;)\n            .DependsOn&lt;TSchemaType&gt;();\n    }\n}\n</code></pre><p>With the new <code>Name</code> extension on the type descriptors we are now able to define a delegate that represents the naming algorithm for that type. Moreover, we can now express on which type this algorithm depends.</p><p>This new <code>Name</code> descriptor extension is built upon our new descriptor extension API that provides a new way to extend our descriptors without needing to create a new base class.</p><h3>Extending Descriptors</h3><p>Each descriptor now provides a new method called <code>Extend</code>. <code>Extend</code> returns an extension descriptor that allows us to integrate some logic with the type initialization pipeline.</p><p>Types are created in three phases:</p><ul><li><p>Create Instance\nThe initializer creates the type instance and the type definition.\nThe type definition contains all information to create and initialize a type.\nAfter this step the type instance exists and is associated with a native .net type.\nThe native .net type can be object but can also be something more specific.\nIn this phase the type will also report all of its dependencies to the schema builder.</p></li><li><p>Complete Name\nAfter all types are created the names of the types will be completed.</p></li><li><p>Complete Type\nIn the last step the types will be completed, this means that for instance the fields are assigned, or the directives are retrieved and associated with a type etc.\nAfter this the type is completed and becomes immutable.</p></li></ul><p>The extension descriptor provides extension points to these three phases:</p><ul><li><p>OnBeforeCreate\nOnBeforeCreate will allow you to customize the type definition.\nIt is important to know that this step is not allowed to be dependent on another type object. Also, at this point you will not have access to the type completion context.</p></li><li><p>OnBeforeNaming\nOnBeforeNaming allows to provide logic to generate the name of a type.\nYou can declare two kinds of dependencies in this step, either the dependency has to be named first or the dependency is allowed to be in any state.</p></li><li><p>OnBeforeCompletion\nOnBeforeCompletion allows to provide further logic that modifies the type definition. For instance, we could be dependent on another type in order to generate fields based on the fields of that other type.\nYou can declare two kinds of dependencies in this step, either the dependency has to be completed first or the dependency is allowed to be in any state.</p></li></ul><p>Let us have a look at how we implemented our own <code>Name</code> extension method in order to understand what <code>Extend</code> is useful for:</p><pre><code class=\"language-csharp\">descriptor\n  .Extend()\n  .OnBeforeNaming((ctx, definition) =&gt;\n  {\n      INamedType type = ctx.GetType&lt;INamedType&gt;(\n          ClrTypeReference.FromSchemaType(typeInfo.ClrType));\n      definition.Name = createName(type);\n  })\n  .DependsOn(dependency, mustBeNamed:true);\n</code></pre><p>Let us pic that example apart in order to understand what we did here. First, we called <code>Extend</code>, <code>Extend</code> returns the <code>IDescriptorExtension&lt;T&gt;</code> which allows us to register some code with the descriptor events that I have described earlier.</p><p>Each event will provide us with the type definition and the completion context. The <code>ICompletionContext</code> is the API to request information from the schema builder. In the case of our <code>Name</code> extension we are requesting the type instance for our <code>TSchemaType</code>. After that we call the naming algorithm with the resolved schema type.</p><p>Also, we added a dependency with <code>DependsOn</code>. The Boolean argument on <code>DependsOn</code> declares that the type has to be named before our delegate can be executed. We can declare as many dependencies as we want, so we are not bound to have just one.</p><p>Let me sum that up. The new <code>Extend</code> method on the descriptors allow us to extend the type descriptors without the need to create a new type base class. This is nice because you can now create extension methods that work across multiple solutions without forcing the user of that extension to opt into a new type base class. This makes it easy to consume those extensions. It is important to know here that <code>Extend</code> is available on all descriptors, so it is available on field descriptors, argument descriptors, or type descriptors.</p><h3>Replacing Descriptors</h3><p>Though <code>Extend</code> is very capable, in some cases we might want to limit what is available through our descriptor. This basically means we want to remove functionality or replace the descriptor entirely. Let us assume we want to introduce an input type that describes the filter capabilities that can be applied to an output type. Basically, we want to introduce a filter input type like Prisma does.</p><p>So, if we had a type like the following:</p><pre><code class=\"language-graphql\">type Foo {\n  bar: String!\n}\n</code></pre><p>We would want to be able to describe the filter capabilities that are available to the user of our API. This could look something like the following:</p><pre><code class=\"language-csharp\">public class FooFilterType\n    : FilterType&lt;Foo&gt;\n{\n    public void Configure(IFilterDescriptor descriptor)\n    {\n        descriptor.Filter(t =&gt; t.Bar).AllowSmallerThan();\n    }\n}\n</code></pre><p>The <code>FilterType&lt;Foo&gt;</code> inherits from <code>InputObjectType</code> and can with version 9 add its own descriptor. In order to replace the descriptor on our input type we would have to replace the configure method and introduce our new filter descriptor:</p><pre><code class=\"language-csharp\">public class FilterType&lt;T&gt;\n    : InputObjectType\n{\n    private readonly Action&lt;IFilterTypeDescriptor&lt;T&gt;&gt; _configure;\n\n    public FilterType()\n    {\n        _configure = Configure;\n    }\n\n    public FilterType(Action&lt;IFilterTypeDescriptor&lt;T&gt;&gt; configure)\n    {\n        _configure = configure\n            ?? throw new ArgumentNullException(nameof(configure));\n    }\n\n    #region Configuration\n\n    protected override InputObjectTypeDefinition CreateDefinition(\n        IInitializationContext context)\n    {\n        var descriptor =\n            FilterTypeDescriptor.New&lt;T&gt;(\n                DescriptorContext.Create(context.Services));\n        _configure(descriptor);\n        return descriptor.CreateDefinition();\n    }\n\n    protected virtual void Configure(\n        IFilterTypeDescriptor&lt;T&gt; descriptor)\n    {\n    }\n\n    protected sealed override void Configure(\n        IInputObjectTypeDescriptor descriptor)\n    {\n        throw new NotSupportedException();\n    }\n\n    #endregion\n}\n</code></pre><p>Like the descriptor extend logic we basically can override those three type initialization events.</p><p>In order to replace the old descriptor, we sealed of the old <code>Configure</code> method. Also, we introduced our new <code>Configure</code> method with the new descriptor.</p><pre><code class=\"language-csharp\">protected virtual void Configure(\n    IFilterTypeDescriptor&lt;T&gt; descriptor)\n{\n}\n\nprotected sealed override void Configure(\n    IInputObjectTypeDescriptor descriptor)\n{\n    throw new NotSupportedException();\n}\n</code></pre><p>In order to initialize our new descriptor, we overrode the <code>CreateDefinition</code> method. Our descriptor has to produce a <code>InputObjectTypeDefinition</code> in order to abide to the <code>InputType</code> interface. If you want your descriptor extendable like our descriptors, all you have to do is inherit from our descriptor base. With version 9 all descriptor and type definition classes are now public, and we strongly recommend basing your descriptors on our base classes.</p><h2>Context Data Support on Types</h2><p>Also, with the new version we added the context data dictionary to all types, fields and arguments. You can use this to add custom metadata to objects of the type system. Context data can be declared on the type definition and will be copied to the corresponding type object.</p><pre><code class=\"language-csharp\">descriptor\n  .Extend()\n  .OnBeforeCreate(definition =&gt;\n  {\n      definition.ContextData[&quot;Foo&quot;] = &quot;Bar&quot;;\n  });\n</code></pre><p>You can access the context data on a type object like the following:</p><pre><code class=\"language-csharp\">schema.GetType&lt;ObjectType&gt;(&quot;Query&quot;).ContextData.ContainsKey(&quot;Foo&quot;);\n</code></pre><h2>Improved Relay Support</h2><p>With version 9 we are making creating relay compliant schemas a breeze. Lets have a look at the relay server spec parts and see how those translate to Hot Chocolate:</p><p>In order to activate relayjs support you can do now the following:</p><pre><code class=\"language-csharp\">SchemaBuilder.New()\n    .EnableRelaySupport()\n    .AddQueryType&lt;Foo&gt;()\n    .Create()\n</code></pre><p><code>EnableRelaySupport</code> will add the node field to your query type and setup the general logic of how your nodes will be resolved using an id value. Moreover, this activates the id value serialization and deserialization. The schema will now have opaque identifiers, but you will not have to deal with those in your API.</p><p>In <code>ObjectType</code>s you can now declare a type as node type. That means this type will implement the node interface and can be resolved through the node field:</p><pre><code class=\"language-csharp\">public class FooType\n    : ObjectType&lt;Foo&gt;\n{\n    protected override void Configure(IObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.AsNode&lt;Foo,int&gt;((ctx, id) =&gt;\n            ctx.Service&lt;IMyRepository&gt;().GetById(id));\n    }\n}\n</code></pre><p>Ok, this is basically all you have to do to fulfill spec item <code>A mechanism for refetching an object.</code>.</p><p>The other spec items for the relay spec were already quite good with version 8. It felt always odd to expose so much logic about those node resolvers to the developers that we refined our current APIs. We used the new <code>Extend</code> mechanism to provide extensions that help you along the way without forcing you to use a special base class.</p><h2>Code-First Type Extensions</h2><p>The last thing I want to talk about in this post are code-first type extensions. We already supported the <code>extend</code> keyword in the stitching layer but had no real code-first API for this. Also, we only supported this in the stitching layer. With version 9 you can now extend code-first and schema-first. Moreover, type extensions are not bound to the stitching layer and work also on a standard schema.</p><p>Let us say we have the type <code>FooType</code> that has one field <code>description</code>.</p><pre><code class=\"language-csharp\">public class FooType\n    : ObjectType&lt;Foo&gt;\n{\n    protected override void Configure(\n        IObjectTypeDescriptor&lt;Foo&gt; descriptor)\n    {\n        descriptor.Field(t =&gt; t.Description);\n    }\n}\n</code></pre><p>We can now introduce a type extension for our <code>FooType</code> that adds for instance a new field <code>test</code>.</p><pre><code class=\"language-csharp\">public class FooTypeExtension\n    : ObjectTypeExtension\n{\n    protected override void Configure(\n        IObjectTypeDescriptor descriptor)\n    {\n        descriptor.Name(&quot;Foo&quot;);\n        descriptor.Field(&quot;test&quot;)\n            .Resolver(() =&gt; new List&lt;string&gt;())\n            .Type&lt;ListType&lt;StringType&gt;&gt;();\n    }\n}\n</code></pre><p>The code-first extension types can do much more then, the schema-first variant. For instance, with code-first you can add middleware parts to a field replace or update a field, replace the resolver, add or replace directives on fields, arguments and so on. Also, you have all the extension functionality that you have on normal types. In fact, since the type extension and the type are using the same descriptor you can apply the same extensions to both.</p><p>Also, you can define multiple type extensions for a single type.</p><p>So, let us have a look of how we add type extensions to our schema:</p><pre><code class=\"language-csharp\">ISchema schema = SchemaBuilder.New()\n  .AddQueryType&lt;FooType&gt;()\n  .AddType&lt;FooTypeExtension&gt;();\n  .Create()\n</code></pre><p>The schema builder basically treats them as types, so there is nothing special that you have to do in order to register them.</p><p>As we go forward, we will also introduce generic variants of the extension types. This will be quite nice in the stitching layer since you can provide a .Net type that we will use to deserialize the object. This means that you can write your resolvers against strong types instead of the generic types that we use per default in the stitching layer.</p><h2>Wrapping it up</h2><p>This is just the first bunch of features that are included with version 9. The best thing, all of what I have showed you today is already included in version 9.0.0-preview.11 which we have released alongside this blog post.</p><p>The next few posts will focus on execution plan support in our query engine. Execution plans can be cached and persisted and will make stitching so much faster. Also, we need the new execution plan feature to introduce support for <code>@defer</code>.</p><p>Furthermore, we will give a peek at our new high-performance parser.</p><p>Also, we will have a look at subscription stitching and our reworked subscription implementation that is now based on the pipeline API of .Net Core.</p><p>Last but not least, we hope we are be able to squeeze in our new <code>FilterType</code> feature with version 9.</p><p>As you can see version 9 will bring quite a few improvements, so stay tuned for our next post on V9 and try out our previews. Also, join our slack channel and give us your take on GraphQL, tell us what you would like to see next in Hot Chocolate.</p><p>With Hot Chocolate we are building a GraphQL server for the community, so join and help us along.</p><p>We value any kind of contribution, whether you give us a star, a feedback, find a bug, a typo, or whether you contribute code. Every bit matters and makes our project better.</p>",
            "url": "https://chillicream.com/blog/2019/04/12/type-system",
            "title": "GraphQL - Hot Chocolate 9.0.0 - Type System",
            "summary": "Originally, I wanted to write a little post about what we are currently working on in version 9 and how those things are coming along, but…",
            "date_modified": "2019-04-12T00:00:00.000Z",
            "date_published": "2019-04-12T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/04/11/integration-tests",
            "content_html": "<p>Today I was asked in our slack channel how one could write an integration test against Hot Chocolate without setting up an ASP.Net Core <em>TestServer</em>.\nThough the ASP.Net Core <em>TestServer</em> API is quite nice, it is much more cumbersome to test a schema this way.</p><p>For full integration tests through all the layers we could in fact setup a test GraphQL endpoint with the complete ASP.net core pipeline by using the ASP.Net core <em>TestServer</em> API.</p><p>With this approach we could ensure that the GraphQL endpoint is correctly configured and works well within our service. In many cases this seems too much since we only want to test parts of the schema.</p><blockquote><p>If you want to read more about the ASP.Net Core <em>TestServer</em> API there is a nice article on the <a href=\"https://visualstudiomagazine.com/articles/2017/07/01/testserver.aspx\">Visual Studio Magazine</a>.</p></blockquote><h2>Setup</h2><p>Before we get started, assume we have a simple query class representing our GraphQL <code>Query</code> type:</p><pre><code class=\"language-csharp\">public class Query\n{\n    public string SayHello() =&gt; &quot;Hello&quot;;\n}\n</code></pre><p>In order to create a schema from that simple type we could just do the following:</p><pre><code class=\"language-csharp\">ISchema schema = Schema.Create(c =&gt; c.RegisterQueryType&lt;Query&gt;());\n</code></pre><p>OK, now we have a schema against which we can write our tests.</p><p>Let`s take a step back and let us think about what we want to actually test before we go into the how.</p><p>Most of the times we want to write tests that ensure that our internal services are correctly hooked up with the GraphQL layer. Basically, we want to test that our business logic works well in the context of GraphQL and that all data is passed correctly. This means that we want to write queries and assert the results of our query.</p><p>The second thing that might be worth to ensure is that our schema is correctly expressed, so that all the default values are ,correct and no unexpected field is exposed.</p><p>Last but not least we might want to test a query- or field-middleware in various situations.</p><h2>Integration Tests</h2><p>All right, let us get started with the integration tests first. In order to write queries against our schema we need to create a query executor:</p><pre><code class=\"language-csharp\">IQueryExecutor executor = schema.MakeExecutable();\n</code></pre><p>The next thing that is important when testing the query engine in isolation is dependency injection.</p><p>Dependency injection is provided through <code>IServiceProvider</code>, this makes it really easy to provide the services to the execution engine that we might need like our data layer or so on.</p><p>The easiest way ist to create a service collection and setup whatever we need.</p><pre><code class=\"language-csharp\">IServiceProvider serviceProvider =\n    new ServiceCollection()\n        .AddSingleton&lt;Foo, Bar&gt;()\n        .BuildServiceProvider();\n</code></pre><p>The second thing we have to ensure is that we did not use <code>HttpContext</code> in our resolver- or middleware-logic.</p><p><strong>Wait a minute, but how are we able to access properties from <code>HttpContext</code> when we are not allowed to access it?</strong></p><p>Agreed, in some cases we really need to have access to properties on the <code>HttpContext</code> like the current <code>HttpContext.User</code> or some header value. In these cases, we need to access some parts of the <code>HttpContext</code> and copy those parts we need to our context data. The context data dictionary is thread-safe and can be accessed in query-, field-middleware and the field-resolver. This makes it easy to abstract the user context from ASP.Net Core dependencies like <code>HttpContext</code>. By doing this we will make our schema more testable and less dependant on the service layer.</p><p>We can do this by writing a query middleware that copies these properties to our context or by using our <code>OnCreateRequestAsync</code> hook. I will show how this can be done at the end of this post.</p><p>For now, let us assume we have done that already, then the only thing that we would need to do is to set the context data when we create our request. So, lets put a simple test together to see how we can write a test:</p><pre><code class=\"language-csharp\">[Fact]\npublic async Task SayHello_HelloIsReturned()\n{\n    // arrange\n    IServiceProvider serviceProvider =\n        new ServiceCollection()\n            .AddSingleton&lt;IDataLayer, MyDataLayer&gt;()\n            .BuildServiceProvider();\n\n    IQueryExecutor executor = Schema.Create(c =&gt;\n    {\n        c.RegisterQueryType&lt;Query&gt;();\n    })\n    .MakeExecutable();\n\n    IReadOnlyQueryRequest request =\n        QueryRequestBuilder.New()\n            .SetQuery(&quot;{ sayHello }&quot;)\n            .SetServices(serviceProvider)\n            .AddProperty(&quot;Key&quot;, &quot;value&quot;)\n            .Create();\n\n    // act\n    IExecutionResult result = await executor.ExecuteAsync(request);\n\n    // assert\n    // so how do we assert this thing???\n}\n</code></pre><p>That does look good already, but how do we assert the result and what is the result.</p><p>The query executor will return an execution result, depending on the type of operation it could be a <code>IResponseStream</code> or a <code>IReadOnlyQueryResult</code>.</p><p>An <code>IReadOnlyQueryResult</code> contains basically the result graph of the query, but asserting this could be very tiresome.</p><p>My good friend <a href=\"https://github.com/nscheibe\">Normen</a> who works at Swiss Life created a snapshot testing library that basically works like <a href=\"https://jestjs.io\">jestjs</a>. We use <em>Snapshooter</em> internally to test the Hot Chocolate core.</p><p><a href=\"https://github.com/SwissLife-OSS/snapshooter\">Snapshooter</a> will create a snapshot at the first execution of the test. The snapshots are saved in a folder <code>__snapshot__</code> that is co-located with our test class. Every consecutive test run will be validated against that first snapshot. If the snapshots do not match the test will fail and tell us what part did not match.</p><p>So, let us have a look how our test would look like with this assertion in place.</p><pre><code class=\"language-csharp\">[Fact]\npublic async Task SayHello_HelloIsReturned()\n{\n    // arrange\n    IServiceProvider serviceProvider =\n        new ServiceCollection()\n            .AddSingleton&lt;IDataLayer, MyDataLayer&gt;()\n            .BuildServiceProvider();\n\n    IQueryExecutor executor = Schema.Create(c =&gt;\n    {\n        c.RegisterQueryType&lt;Query&gt;();\n    })\n    .MakeExecutable();\n\n    IReadOnlyQueryRequest request =\n        QueryRequestBuilder.New()\n            .SetQuery(&quot;{ sayHello }&quot;)\n            .SetServices(serviceProvider)\n            .AddProperty(&quot;Key&quot;, &quot;value&quot;)\n            .Create();\n\n    // act\n    IExecutionResult result = await executor.ExecuteAsync(request);\n\n    // assert\n    result.MatchSnapshot();\n}\n</code></pre><p>This test looks very clean now, the snapshots are serializing to json which makes them easy to read.</p><pre><code class=\"language-json\">{\n  &quot;Data&quot;: {\n    &quot;sayHello&quot;: &quot;hello&quot;\n  },\n  &quot;Extensions&quot;: {},\n  &quot;Errors&quot;: []\n}\n</code></pre><p>The awesome thing with snapshooter is that we can ignore parts of our result-graph or validate one property of the result-graph in a special way.</p><pre><code class=\"language-csharp\">result.MatchSnapshot(o =&gt;\n    o.IgnoreField(&quot;Extensions.SomeProperty&quot;));\n</code></pre><p>For more information about how snapshooter works head over to their repository:</p><p><a href=\"https://github.com/SwissLife-OSS/snapshooter\">https://github.com/SwissLife-OSS/snapshooter</a></p><h2>Schema Tests</h2><p>Ok, lets have a look at our second category. This I think is the simplest test we will write and probably we will just have one or two of those tests.</p><p>Hot Chocolate lets us print our schema as GraphQL SDL, this means that we can create a simple SDL representation like the following:</p><pre><code class=\"language-graphql\">type Query {\n  sayHello: String\n}\n</code></pre><p>In order to get this representation we just have to do the following:</p><pre><code class=\"language-csharp\">Schema.Create(c =&gt; c.RegisterQueryType&lt;Query&gt;()).ToString();\n</code></pre><p>That`s quite simple, just calling <code>ToString()</code> on the schema will return the schema SDL representation.</p><p>The good thing with <em>Snapshooter</em> is that we also can create snapshots of scalar values like a string. <em>Snapshooter</em> will than just save the raw scalar as snapshot, so our SDL will <strong>NOT</strong> be polluted with JSON escape characters.</p><p>Our test could look like the following:</p><pre><code class=\"language-csharp\">[Fact]\npublic async Task Ensure_Schema_IsCorrect()\n{\n    // arrange\n    ISchema schema = Schema.Create(c =&gt;\n    {\n        c.RegisterQueryType&lt;Query&gt;();\n    });\n\n    // act\n    string schemaSDL = schema.ToString();\n\n    // assert\n    schemaSDL.MatchSnapshot();\n}\n</code></pre><h2>Middleware/Resolver Tests</h2><p>The last category concerns our middleware logic. I would strongly suggest testing a middleware with a unit test and not by firing a query against the query engine. You can use <a href=\"https://github.com/Moq/moq4/wiki/Quickstart\">Moq</a> to create a <code>IResolverContext</code> mock.</p><p>In cases that you want to test a resolver or middleware pipeline of a field you can retrieve those from that type like the following:</p><pre><code class=\"language-csharp\">[Fact]\npublic async Task SayHello_HelloIsReturned()\n{\n    // arrange\n    IServiceProvider serviceProvider =\n        new ServiceCollection()\n            .AddSingleton&lt;IDataLayer, MyDataLayer&gt;()\n            .BuildServiceProvider();\n\n    ISchema schema = Schema.Create(c =&gt;\n    {\n        c.RegisterQueryType&lt;Query&gt;();\n    });\n\n    ObjectType type = schema.GetType&lt;ObjectType&gt;(&quot;Query&quot;);\n    ObjectField field = type.Fields[&quot;sayHello&quot;];\n\n    Mock&lt;IResolverContext&gt; contextMock = new Mock&lt;IResolverContext&gt;();\n    // note that depending on what you are using in your resolver you will\n    // have to setup properties for your mock.\n\n    // act\n    object result = await field.Resolver(contextMock.Object)\n\n    // assert\n    result.MatchSnapshot();\n}\n</code></pre><p>The resolver-property will just have the isolated resolver logic. In order to access the middleware pipeline, use the <code>Middleware</code> property on the field. The middleware represents the compiled middleware pipeline including the resolver.</p><h2>HttpContext Abstraction</h2><p>So, lets come back the question about the <code>HttpContext</code>. In order to copy properties from the <code>HttpContext</code> to your GraphQL request I said that we can use <code>OnCreateRequestAsync</code>. This is actually the simplest way to do it.</p><p>Let us grab the user from the <code>HttpContext</code> and copy it to our context data dictionary as an example.</p><pre><code class=\"language-csharp\">app.UseGraphQL(new QueryMiddlewareOptions\n{\n    OnCreateRequest = (context, builder, ct) =&gt;\n    {\n        builder.SetProperty(&quot;user&quot;, context.User);\n        return Task.CompletedTask;\n    }\n})\n</code></pre><p>The second way is a little bit more complicated but easier to test and feels cleaner.</p><p>We could write a little query middleware. The middleware could be provided as delegate like the upper example or we could take the extra effort to make a class.</p><pre><code class=\"language-csharp\">public class CopyUserMiddleware\n{\n    private readonly QueryDelegate _next;\n\n    public CopyVariablesToResolverContextMiddleware(QueryDelegate next)\n    {\n        _next = next ?? throw new ArgumentNullException(nameof(next));\n    }\n\n    public Task InvokeAsync(IQueryContext context)\n    {\n        IHttpContextAccessor accessor = context.Services.GetService&lt;IHttpContextAccessor&gt;();\n        context.ContextData[&quot;user&quot;] = accessor.HttpContext.User;\n        return _next.Invoke(context);\n    }\n}\n</code></pre><p>So, this code does the same as our first example but is now easily testable and can be integrated like the following to our GraphQL execution pipeline:</p><pre><code class=\"language-csharp\">services.AddGraphQL(Schema.Create(c =&gt;\n    {\n        c.RegisterQueryType&lt;Query&gt;();\n    })\n    .MakeExecutable(b =&gt; b.Use&lt;CopyUserMiddleware&gt;().UseDefaultPipeline()));\n</code></pre><p>I hope this little post will help when you start writing tests for your schema. If you run into any issues or if you have further questions/suggestions head over to our slack channel and we will be happy to help you.</p>",
            "url": "https://chillicream.com/blog/2019/04/11/integration-tests",
            "title": "GraphQL - How to write integration tests against Hot Chocolate",
            "summary": "Today I was asked in our slack channel how one could write an integration test against Hot Chocolate without setting up an ASP.Net Core…",
            "date_modified": "2019-04-11T00:00:00.000Z",
            "date_published": "2019-04-11T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/03/31/hot-chocolate-0.8.1",
            "content_html": "<p>Today we release version 8.1 (0.8.1) of Hot Chocolate. This release brings improvements and bug fixes to the current version 8 release.</p><h2>Instrumentation</h2><p>One focus of this release was to open up our diagnostic events to be used by developers. When we started thinking about how Hot Chocolate should provide information about its inner workings to users of the library, we opted against using one specific logging framework.</p><p>Instead we have looked at what Microsoft was doing in ASP.Net core and other components with diagnostic sources. Diagnostic sources let us create events that have non-serializable payloads.</p><p>This means that we can provide an event that gives full access to our context objects like the <code>IQueryContext</code> or the <code>IResolverContext</code>.</p><p>This enables you to add your own logger to your GraphQL server and grab exactly the information from the Hot Chocolate diagnostic events that you need to make your tracing solution work.</p><p>In order to read more on this subject checkout our blog: <a href=\"2019-03-19-logging-with-hotchocolate.md\">Tracing with Hot Chocolate</a> or head over to our <a href=\"https://hotchocolate.io/docs/instrumentation\">documentation</a>.</p><h2>Stitching Refinements</h2><p>One new feature that is now available in the stitching layer is support of error filters. This means that you can now write error filters like on a local schema and transform or enrich query errors that were extracted from remote queries.</p><p>In order to make it easier to use error filters we have changed the error structure of remote errors and provide the original error object as an extension property:</p><pre><code class=\"language-csharp\">serviceCollection.AddStitchedSchema(builder =&gt;\n    builder.AddSchemaFromHttp(&quot;messages&quot;)\n        .AddSchemaFromHttp(&quot;users&quot;)\n        .AddSchemaFromHttp(&quot;analytics&quot;))\n        .AddExecutionConfiguration(b =&gt;\n        {\n            b.AddErrorFilter(error =&gt;\n            {\n                if(error.Extensions.TryGetValue(&quot;remote&quot;, out object o)\n                  &amp;&amp; o is IError originalError)\n                {\n                    return error.AddExtension(\n                      &quot;remote_code&quot;,\n                      originalError.Code);\n                }\n                return error;\n            });\n        }));\n</code></pre><p>We also refined the default rewrite logic so that errors in most cases will now be correctly associated with the causing field.</p><h2>Bug Fixes</h2><p><code>DateTime</code> scalars are now correctly handled in the stitching layer, with version 8 we had some issues when <code>DateTime</code> scalars were provided through variables.</p><p>For more information on what other bugs we fixed head over to our <a href=\"https://github.com/ChilliCream/hotchocolate/blob/master/CHANGELOG.md\">changelog</a>.</p><h2>Version 9 Development</h2><p>We have made a lot of headway with the new type system that is coming with version 9. Also, we are working on the <code>@defer</code> directive at the moment. We will give a more detailed update on the next major version in a sperate blog post. Version 9 is really shaping up to become our biggest release so far.</p>",
            "url": "https://chillicream.com/blog/2019/03/31/hot-chocolate-0.8.1",
            "title": "GraphQL - Hot Chocolate 0.8.1",
            "summary": "Today we release version 8.1 (0.8.1) of Hot Chocolate. This release brings improvements and bug fixes to the current version 8 release…",
            "date_modified": "2019-03-31T00:00:00.000Z",
            "date_published": "2019-03-31T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/03/19/logging-with-hotchocolate",
            "content_html": "<p>One common question that comes up on our slack channel is if Hot Chocolate supports some kind of logging infrastructure. My personal opinion here is that logging/tracing is often very project specific and an API should not force one specific logging solution onto its users.</p><p>Instead we have opted to provide diagnostic events through Microsoft`s diagnostic source which does not force us to serialize any payloads. This in turn gives you the ability to pick and choose the information that best fits your need for your tracing/logging solution.</p><p>This post will walk you through on how to add a logger of your choice to Hot Chocolate and get exactly the right amount of information for your project.</p><p>In this blog we will use the ASP.Net core logging API to show how a logger can be attached to our diagnostic events.</p><h2>Setup</h2><p>But before we can get started let us first setup a web project with Hot Chocolate:</p><pre><code class=\"language-bash\">mkdir logging\ncd logging\ndotnet new web\ndotnet add package HotChocolate.AspNetCore:9.0.0-preview.5\ndotnet add package HotChocolate.AspNetCore.Playground:9.0.0-preview.5\n</code></pre><h2>Configure the Logger</h2><p>After our project is setup let us start with setting up the ASP.net core logging infrastructure. This is fairly easy with ASP.net core. Head over to the <code>Program.cs</code> and replace the builder configuration with the following one.</p><pre><code class=\"language-csharp\">public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&gt;\n    WebHost.CreateDefaultBuilder(args)\n        .ConfigureLogging((hostingContext, logging) =&gt;\n        {\n            logging.ClearProviders();\n            logging.AddConsole();\n        })\n        .UseStartup&lt;Startup&gt;();\n</code></pre><p><code>ConfigureLogging</code> configures the various logging providers that are then available throughout our <code>WebHost</code>. In our simple example we clear all the providers and then add only the console logger.</p><p>Next head over to the <code>Startup.cs</code> and register the logger with the dependency injection by adding the following line to <code>ConfigureServices</code>.</p><pre><code class=\"language-csharp\">services.AddLogging();\n</code></pre><p>Perfect, now we have setup all the basics and can get started.</p><h2>Diagnostic Observer</h2><p>The Hot Chocolate server provides diagnostic events through a diagnostic source. We can subscribe to these events by providing a diagnostic observer. A diagnostic observer is basically any class that implements our marker interface <code>IDiagnosticObserver</code>.</p><p>Into this class we can add public methods that are subscribed to the actual diagnostic listener. The methods that shall subscribe to an event have to be annotated to with the <code>DiagnosticNameAttribute</code>.</p><p>We have listed the various available events and their payloads in our documentation that can be found <a href=\"https://hotchocolate.io/docs/next/instrumentation\">here</a>.</p><p>Let us say that in our case we want to write a message to the console whenever a request begins. Moreover, if the request is a query or mutation then we also want to write the result to the console.</p><p>Before we add the actual event methods, let us create a class called <code>DiagnosticObserver</code>. In order to write events to the logger we need to inject a concrete logger to our class. So, our class could look like the following:</p><pre><code class=\"language-csharp\">public class DiagnosticObserver\n    : IDiagnosticObserver\n{\n    private readonly ILogger _logger;\n\n    public DiagnosticObserver(ILogger&lt;DiagnosticObserver&gt; logger)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n}\n</code></pre><p>Next, let us add our two event methods.</p><pre><code class=\"language-csharp\">public class DiagnosticObserver\n        : IDiagnosticObserver\n{\n    private readonly ILogger _logger;\n\n    public DiagnosticObserver(ILogger&lt;DiagnosticObserver&gt; logger)\n    {\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\n    }\n\n    [DiagnosticName(&quot;HotChocolate.Execution.Query&quot;)]\n    public void OnQuery(IQueryContext context)\n    {\n        // This method is used as marker to enable begin and end events\n        // in the case that you want to explicitly track the start and the\n        // end of this event.\n    }\n\n    [DiagnosticName(&quot;HotChocolate.Execution.Query.Start&quot;)]\n    public void BeginQueryExecute(IQueryContext context)\n    {\n        _logger.LogInformation(context.Request.Query);\n    }\n\n    [DiagnosticName(&quot;HotChocolate.Execution.Query.Stop&quot;)]\n    public void EndQueryExecute(IQueryContext context)\n    {\n        if(context.Result is IReadOnlyQueryResult result)\n        {\n            using (var stream = new MemoryStream())\n            {\n                var resultSerializer = new JsonQueryResultSerializer();\n                resultSerializer.SerializeAsync(\n                    result, stream).Wait();\n                _logger.LogInformation(\n                    Encoding.UTF8.GetString(stream.ToArray()));\n            }\n        }\n    }\n}\n</code></pre><p>In order to enable start/stop events we have to add a third method that represents the subscription to the event.</p><p>This is only needed when subscribing to activities that consist of a start event and a stop event. These start and stop events allow for measuring performance.</p><p>Apart from our standard payloads that are described in our documentation we can also inject the <code>Activity</code> instance to your start/stop event and use the high precision time measurement that the diagnostics APIs provide.</p><p>The events always provide you with the full context objects that are available in the query and field middleware pipeline. You basically have full access to all the data that you would have access to in a middleware and by this you are able to pick the information you need for your tracing/logging solution and create the logging messages in a structure that fits your needs.</p><p>Moreover, you also can use the <code>ContextData</code> dictionary on the context objects to share information between your subscription events like a request identifier.</p><p>After we have implemented our observer, we have to register it as a service.</p><p>Add the following line to the <code>ConfigureServices</code> method in our <code>Startup.cs</code>.</p><pre><code class=\"language-csharp\">services.AddDiagnosticObserver&lt;DiagnosticObserver&gt;();\n</code></pre><p>With that our logger is ready to receive events. We now just need a GraphQL API that produces events.</p><p>For this we add a simple query type:</p><pre><code class=\"language-csharp\">public class Query\n{\n    public string Hello() =&gt; &quot;world&quot;;\n}\n</code></pre><p>Next we register the query type with our schema by adding the following line to the <code>ConfigureServices</code> method in our <code>Startup.cs</code>.</p><pre><code class=\"language-csharp\">services.AddGraphQL(c =&gt;\n{\n    c.RegisterQueryType&lt;Query&gt;();\n});\n</code></pre><p>Last but not least we have to add our <code>GraphQL</code> middleware and in order to write some queries our <code>Playground</code> middleware.</p><p>Replace the <code>Configure</code> method in our <code>Startup.cs</code> with the following:</p><pre><code class=\"language-csharp\">public void Configure(IApplicationBuilder app, IHostingEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseGraphQL();\n    app.UsePlayground();\n\n    app.Run(async (context) =&gt;\n    {\n        await context.Response.WriteAsync(&quot;Hello World!&quot;);\n    });\n}\n</code></pre><p>You should now be able to start the GraphQL server.</p><pre><code class=\"language-bash\">dotnet run\n</code></pre><p>The server should be accessible through plaground under the following URL <code>http://127.0.0.1:5000/playground</code>.</p><p>Add the following query and execute it:</p><pre><code class=\"language-graphql\">{\n  hello\n}\n</code></pre><p>The query and the result should now be printed to your console.</p><p>This is just a simple example of how to subscribe to our diagnostic events. Checkout our documentation for a list of all of the events available <a href=\"https://hotchocolate.io/docs/next/instrumentation\">here</a>.</p><p>We have added this example project to our example repo <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/Instrumentation\">here</a>.</p><p>Also, we have a more complex implementation of a Hot Chocolate ETW event source <a href=\"https://github.com/ChilliCream/thor-client/tree/master/src/Clients/HotChocolate\">here</a>.</p><p>Another example is our <a href=\"https://github.com/ChilliCream/hotchocolate/blob/master/src/Core/Core/Execution/Instrumentation/ApolloTracingDiagnosticObserver.cs\">Apollo Tracing implementation</a> that is also based on our instrumentation API.</p><p>I hope this little field trip into our instrumentation API gives a little outlook of an often-overlooked feature that is coming with version 9. All of what I showed in this blog is available with preview 5 (9.0.0-preview.5) that we released today.</p><p>We will add stitching related events with the next view preview builds.</p>",
            "url": "https://chillicream.com/blog/2019/03/19/logging-with-hotchocolate",
            "title": "GraphQL - Tracing with Hot Chocolate",
            "summary": "One common question that comes up on our slack channel is if Hot Chocolate supports some kind of logging infrastructure. My personal opinion…",
            "date_modified": "2019-03-19T00:00:00.000Z",
            "date_published": "2019-03-19T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/03/04/hot-chocolate-0.8.0",
            "content_html": "<p>Today we are releasing Hot Chocolate version 8 (0.8.0) which mainly focused on schema stitching and brings our stitching layer to a whole new level.</p><h2>Schema Stitching</h2><p>Since, my last blog post we were heavily at work ironing out bugs and making schema stitching easier.</p><p>Now, with the release finished, schema stitching with ASP.Net core has become super easy and feels quite nice to use.</p><p>Head over to our new documentation for <a href=\"https://hotchocolate.io/docs/stitching\">schema stitching</a>.</p><h2>Voyager</h2><p>With version 8 we now provide a GraphQL Voyager middleware. GraphQL Voyager is a nice schema explorer that can be useful during development time. If you want to know more about GraphQL Voyager head over to their <a href=\"https://github.com/APIs-guru/graphql-voyager\">GitHub repo</a>.</p><h2>Authorization</h2><p>Also, with version 8 we have invested some time to smooth out the <code>@authorize</code>-directive.</p><p>The <code>@authorize</code>-directive does now mirror almost the behavior of the authorize directive.</p><p>In contrast to the ASP.Net attribute we can specify the directive on field definitions and thereby have a fine-grained control over what data we want to give access to.</p><p>If you are using ASP.Net core then you can use authorization-policies with your <code>@authorize</code>-directive giving you even more control over your data.</p><p>Head over to our <a href=\"https://hotchocolate.io/docs/authorization\">authorization documentation</a> to learn more.</p><h2>Version 9</h2><p>We have already started on quite a few areas for our next release. I can tell you already that, version 9 will be big.</p><h3>Type System</h3><p>The most requested features from users of our API at the moment is to open up the type system. In the beginning we did keep a lot of extension points internal in order to give us some more time to figure out how to make certain areas extendable.</p><p>With version 9 we will reinvent the type system. Do not fret, there will be no breaking changes to the public APIs since the APIs that we are changing and making public are currently internal.</p><p>With version 9 you will be able to create your own base classes that expose your own descriptors to the users. This will allow for instance to introduce prisma-like filter APIs, or dynamic types that generate members on the base of other schema types.</p><h3>Prisma-like Filtering for IQueryable</h3><p>On top of the new type system we will add new filter types that will allow you to configure filter and sorting inputs that can be used with the paging middleware. If you never heard of Prisma then head over to their web page and checkout their approach to filtering and sorting:</p><p><a href=\"https://www.prisma.io/docs/prisma-graphql-api/reference/queries-qwe1/\">Prisma</a></p><h3>Advanced Relay Support</h3><p>With version 9 creating relay compliant schemas will be as easy as eating pie. You will no longer be bothered handling schema unique identifiers, since Hot Chocolate will do all of that for you. Also, the node field on the <code>Query</code> type will be automatically integrated. So, what we are doing here is removing boilerplate code for you so that you can focus on implementing a great API without having to worry about the relay server spec details.</p><h3>Subscription Stitching</h3><p>We originally envisioned this feature for version 8 but moved this one into version 9 due to the fact that we needed some changes in the type system to handle it. This will make the schema stitching even more complete.</p><h3>Relay Schema Stitching</h3><p>With the schema stitching version 8 you have to handle the node field on your own when you stitch multiple relay compliant schemas together. With version 9 we will keep track which id belongs to which remote schema and from which remote schema we have to fetch the data.</p><h3>Hot Chocolate UI</h3><p>GraphQL is really awesome, but we are really not happy with the tooling situation. As of now we support GraphiQL, Playground and Voyager for Hot Chocolate, but none of these is a complete solution.</p><p>We have started some time ago to create a new developer tool for GraphQL that will replace all of these. We did not base our new UI on GraphiQL since we want to achieve more and create something unique. Look for instance at the tooling around rest, with <em>Postman</em> developers have quite a good tool that enables them to do a lot.</p><p>The <em>Hot Chocolate UI</em> will be a developer focused tool that will be able to replace all the GraphQL UIs out there. It already is my favorite tool and we cannot wait to show you the first preview versions of it.</p><p>By the way, we are still looking for a cool new chillicream compliant name like Hot Chocolate or Green Donut. So, if you have any cool or funny ideas head over to our slack channel</p><h3>GraphQL Compatibility Acceptance Tests</h3><p>With version 8 we have started to invest in the GraphQL Compatibility Acceptance Tests and plan to have them fully implemented and integrated with version 11. This does not mean that we wait until version 11 to use them. Already now we are able to generate some of the test cases. Hopefully, we will have all the parser tests integrated with version 9. This subject is an ongoing effort and we will keep you posted on this one.</p><p>For more information on GraphQL Cats visit their <a href=\"https://github.com/graphql-cats/graphql-cats\">GitHub repository</a>.</p><h3>Versioning</h3><p>With version 9 we will change our versioning and follow the example of react in swapping the leading zero with the nine. So, the version number of version 9 will actually be 9.0.0.</p><h2>Version 10</h2><p>With version 10 is in the early planning stages, we will build on the new type system and introduce two new services that will turn Hot Chocolate from a simple server into a GraphQL platform.</p><h3>Schema Registry</h3><p>The schema registry will keep track of the schemas in your company. Moreover, with version 10 of our new <code>Hot Chocolate UI</code> you will be able to configure your GraphQL gateways with drag&amp;drop. This means you will be able to stitch schemas together with an awesome UI and deploy new stitched schemas in seconds.</p><h3>Performance and Schema Warehouse</h3><p>The second service will collect performance data from all your schemas. You will be able to analyze with the <code>Hot Chocolate UI</code> how good or bad you GraphQL servers are performing, which queries are the most used or which queries use the most resources. Furthermore, you will be able to drill into the query tracing results and see which resolvers are performing well or which resolvers are causing issues.</p><h2>Wrapping things up</h2><p>We are planning around four to six weeks for version 9 with the first previews coming out in around two weeks.</p><p>We will really start hammering out the details on version 9 in the next three weeks.</p><p>If you have ideas or suggestions pleas head over to our slack channel and join the discussion.</p>",
            "url": "https://chillicream.com/blog/2019/03/04/hot-chocolate-0.8.0",
            "title": "GraphQL - Hot Chocolate 0.8.0",
            "summary": "Today we are releasing Hot Chocolate version 8 (0.8.0) which mainly focused on schema stitching and brings our stitching layer to a whole…",
            "date_modified": "2019-03-04T00:00:00.000Z",
            "date_published": "2019-03-04T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/02/20/schema-stitching",
            "content_html": "<p>With version 8 of Hot Chocolate we have mainly focused on schema stitching. One of the most requested features in this area was auto-stitching. Auto-stitching will enable us to automatically pull in schemas from other GraphQL servers and merge those into one schema.</p><p><strong>What is schema stitching actually?</strong></p><p>Schema stitching is the capability to merge multiple GraphQL schemas into one schema that can be queried.</p><h2>Introduction</h2><p><strong>So, for what is that useful?</strong></p><p>In our case we have lots of specialized services that serve data for specific problem domains. Some of these services are GraphQL services, some of them are REST services and yes sadly a little portion of those are still SOAP services.</p><p>With Hot Chocolate schema stitching we are able to create a gateway that bundles all those services into one GraphQL schema.</p><p><strong>Is schema stitching basically just putting two schemas together?</strong></p><p>Just putting two schemas into one and avoid name collisions is simple. But what we want to achieve with schema stitching is one consistent schema.</p><p>Hot Chocolate schema stitching allows us to really integrate services into one schema by folding types into one another and even renaming or removing parts.</p><p>With this we can create a consistent GraphQL schema that hides the implementation details of our backend services and provides the consumer of our endpoint with the capability to fetch the data they need with one call, no under- or over-fetching and most importantly no repeated fetching because we first needed to fetch that special id with which we now can fetch this other thingy.</p><h2>Getting Started</h2><p>In order to showcase how schema stitching works and what the problems are let us assume we have a service like twitter, where a user can post messages.</p><p>Moreover, let us assume we have three teams working on internal micro-/domain-services that handle certain aspects of that service.</p><p>The first service is handling the message stream and has the following schema:</p><pre><code class=\"language-graphql\">type Query {\n  messages(userId: ID!): [Message!]\n  message(messageId: ID!): Message\n}\n\ntype Mutation {\n  newMessage(input: NewMessageInput!): NewMessagePayload!\n}\n\ntype Message {\n  id: ID!\n  text: String!\n  createdBy: ID!\n  createdAt: DateTime!\n  tags: [String!]\n}\n\ntype NewMessageInput {\n  text: String!\n  tags: [String!]\n}\n\ntype NewMessagePayload {\n  message: Message\n}\n</code></pre><p>The second service is handling the users of the services and has the following schema:</p><pre><code class=\"language-graphql\">type Query {\n  user(userId: ID!): User!\n  users: [User!]\n}\n\ntype Mutation {\n  newUser(input: NewUserInput!): NewUserPayload!\n  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!\n}\n\ntype NewUserInput {\n  username: String!\n  password: String!\n}\n\ntype ResetPasswordInput {\n  username: String!\n  password: String!\n}\n\ntype NewUserPayload {\n  user: User\n}\n\ntype ResetPasswordPayload {\n  user: User\n}\n\ntype User {\n  id: ID!\n  username: String!\n}\n</code></pre><p>Last but not least we have a third service handling the message analytics. In our example case we keep it simple and our analytics service just tracks three different counters per message. The schema for this service looks like the following:</p><pre><code class=\"language-graphql\">type Query {\n  analytics(messageId: ID!, type: CounterType!): MessageAnalytics\n}\n\ntype MessageAnalytics {\n  id: ID!\n  messageId: ID!\n  count: Int!\n  type: CounterType!\n}\n\nenum CounterType {\n  VIEWS\n  LIKES\n  REPLIES\n}\n</code></pre><p>With those three separate schemas our UI team would have to fetch from multiple endpoints.</p><p>Even worse for our UI team, in order to build a stream view that shows the message text and the name of the user who posted the message, they would have to first fetch all the messages and could only then fetch the names of the users.</p><p>This is actually one of the very things GraphQL tries to solve.</p><h2>Setting up our server</h2><p>Before we start with stitching itself let`s get into how to setup our server.</p><p>Every Hot Chocolate server can be a stitching server. This means in order to get started we can just use the Hot Chocolate GraphQL server template and modify it a little bit to make the server a stitching server.</p><p>If you do not have the Hot Chocolate GraphQL server template installed execute first the following command.</p><pre><code class=\"language-bash\">dotnet new -i HotChocolate.Templates.Server\n</code></pre><p>After that we will create a new folder and add a new server to that folder.</p><pre><code class=\"language-bash\">mkdir stitching-demo\ncd stitching-demo\ndotnet new graphql-server\n</code></pre><p>With this we have now a functioning GraphQL server with a simple hello world example.</p><p>In order to make this server a stitching server we now have to add the Hot Chocolate stitching engine.</p><pre><code class=\"language-bash\">dotnet add package HotChocolate.Stitching\n</code></pre><p>Now that our GraphQL server is ready we can start to configure the endpoints of our remote schemas.</p><blockquote><p>Remote schemas are what we call the GraphQL schemas that we want to include into our merged schema. Remote schemas can be any GraphQL Spec compliant server (Apollo, Sangria, Hot Chocolate etc.) that serves its schema over HTTP. Also we can include local schemas that are created with the Hot Chocolate .net API.</p></blockquote><p>The endpoints are declared by using a named <code>HttpClient</code> via the HttpClient factory that is included with ASP.net core.</p><pre><code class=\"language-csharp\">services.AddHttpClient(&quot;messages&quot;, (sp, client) =&gt;\n{\n  client.BaseAddress = new Uri(&quot;http://127.0.0.1:5050&quot;);\n});\nservices.AddHttpClient(&quot;users&quot;, (sp, client) =&gt;\n{\n  client.BaseAddress = new Uri(&quot;http://127.0.0.1:5051&quot;);\n});\nservices.AddHttpClient(&quot;analytics&quot;, (sp, client) =&gt;\n{\n  client.BaseAddress = new Uri(&quot;http://127.0.0.1:5052&quot;);\n});\n</code></pre><p>Now let`s remove the parts from the server template that we don&#x27;t need.</p><blockquote><p>We will show some strategies of how to handle authenticated services later on.</p></blockquote><pre><code class=\"language-csharp\">services.AddDataLoaderRegistry();\n\nservices.AddGraphQL(sp =&gt; Schema.Create(c =&gt;\n{\n    c.RegisterQueryType&lt;Query&gt;();\n}));\n</code></pre><h2>Stitching Builder</h2><p>The stitching builder is the main API to configure a stitched GraphQL schema (GraphQL gateway). In order to have a simple auto-merge we have just to provide all the necessary schema names and the stitching layer will fetch the remote schemas via introspection on the first call to the stitched schema.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;));\n</code></pre><p>Since a stitched schema is essentially no different to any other GraphQL schema, we can configure custom types, add custom middleware or do any other thing that we could do with a Hot Chocolate GraphQL schema.</p><p>In our example we are stitching together schemas that come with non-spec scalar types like <code>DateTime</code>. So, the stitching layer would report a schema error when stitching the above three schemas together since the <code>DateTime</code> scalar is unknown.</p><p>In order to declare this custom scalar we can register the extended scalar set like with a regular Hot Chocolate GraphQL schema through the <code>AddSchemaConfiguration</code>-method on the stitching builder.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;))\n  .AddSchemaConfiguration(c =&gt;\n  {\n    c.RegisterExtendedScalarTypes();\n  })\n</code></pre><blockquote><p>More information about our scalars can be found <a href=\"https://hotchocolate.io/docs/custom-scalar-types\">here</a>.</p></blockquote><p>With this in place our stitched schema now looks like the following:</p><pre><code class=\"language-graphql\">type Query {\n  messages(userId: ID!): [Message!]\n  message(messageId: ID!): Message\n  user(userId: ID!): User!\n  users: [User!]\n  analytics(messageId: ID!, type: CounterType!): MessageAnalytics\n}\n\ntype Mutation {\n  newMessage(input: NewMessageInput!): NewMessagePayload!\n  newUser(input: NewUserInput!): NewUserPayload!\n  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!\n}\n\ntype Message {\n  id: ID!\n  text: String!\n  createdBy: ID!\n  createdAt: DateTime!\n  tags: [String!]\n}\n\ntype NewMessageInput {\n  text: String!\n  tags: [String!]\n}\n\ntype NewMessagePayload {\n  message: Message\n}\n\ntype NewUserInput {\n  username: String!\n  password: String!\n}\n\ntype ResetPasswordInput {\n  username: String!\n  password: String!\n}\n\ntype NewUserPayload {\n  user: User\n}\n\ntype ResetPasswordPayload {\n  user: User\n}\n\ntype User {\n  id: ID!\n  username: String!\n}\n\ntype MessageAnalytics {\n  id: ID!\n  messageId: ID!\n  count: Int!\n  type: CounterType!\n}\n\nenum CounterType {\n  VIEWS\n  LIKES\n  REPLIES\n}\n</code></pre><p>We have just achieved a simple schema merge without doing a lot of work. But honestly we would like to change some of the types. While the stitching result is nice, we would like to integrate the types with each other.</p><h3>Extending Types</h3><p>So, the first thing that we would like to have is a new field on the query that is called <code>me</code>. The <code>me</code> field shall represent the currently signed in user of our service.</p><p>Further, the user type should expose the message stream of the user, this way we could fetch the messages of the signed in user like the following:</p><pre><code class=\"language-graphql\">{\n  me {\n    messages {\n      text\n      tags\n    }\n  }\n}\n</code></pre><p>In order to extend types in a stitched schema we can use the new GraphQL extend syntax that was introduced with the 2018 spec.</p><pre><code class=\"language-graphql\">extend type Query {\n  me: User! @delegate(schema: &quot;users&quot;, path: &quot;user(id: $contextData:UserId)&quot;)\n}\n\nextend type User {\n  messages: [Message!]\n    @delegate(schema: &quot;messages&quot;, path: &quot;messages(userId: $fields:Id)&quot;)\n}\n</code></pre><p>With just that and no further code needed we have specified how the GraphQL stitching engine shall rewrite our schema.</p><p>Let us dissect the above GraphQL SDL in order to understand what it does.</p><p>First, let us have a look at the <code>Query</code> extension. We declared a field like we would do with the schema-first approach. After that we annotated the field with the <code>delegate</code> directive. The <code>delegate</code> directive basically works like a middleware that delegates calls to to a remote schema.</p><p>The <code>path</code>-argument on the <code>delegate</code> directive specifies how to fetch the data from the remote schema. The selection path can have multiple levels. So, if we wanted to fetch just the username we could do that like the following:</p><pre><code class=\"language-graphql\">user(id: $contextData:UserId).username\n</code></pre><p>Moreover, we are using a special variable that can access the resolver context.</p><p>Currently this variable has four scopes:</p><ul><li><p>Arguments</p><p>Access arguments of the annotated field field: <code>$arguments:ArgumentName</code></p></li><li><p>Fields</p><p>Access fields of the declaring type: <code>$fields:FieldName</code></p></li><li><p>ContextData</p><p>Access properties of the request context data map: <code>$contextData:Key</code></p></li><li><p>ScopedContextData</p><p>Access properties of the scoped field context data map: <code>$contextData:Key</code></p></li></ul><p>The context data can be used to map custom properties into our GraphQL resolvers. In our case we will use it to map the internal user ID from the user claims into our context data map. This allows us to have some kind of abstraction between the actual HttpRequest and the data that is needed to process a GraphQL request.</p><blockquote><p>Documentation on how to add custom context data from a http request can be found <a href=\"https://hotchocolate.io/docs/custom-context\">here</a></p></blockquote><p>OK, let`s sum this up, with the <code>delegate</code> directive we are able to create powerful stitching resolvers without writing one line of c# code. Furthermore, we are able to create new types that make the API richer without those types having any representation in any of the remote schemas.</p><p>In order to get our extensions integrated we need to add the extensions to our stitching builder. Like with the schema we have multiple extension methods to load the GraphQL SDL from a file or a string and so on.</p><p>In our case let`s say we are loading it from a file called <code>Extensions.graphql</code>.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;))\n  .AddExtensionsFromFile(&quot;./graphql/Extensions.graphql&quot;)\n  .AddSchemaConfiguration(c =&gt;\n  {\n    c.RegisterExtendedScalarTypes();\n  })\n</code></pre><p>Now with all of this in place our schema looks like the following:</p><pre><code class=\"language-graphql\">type Query {\n  me: User!\n  messages(userId: ID!): [Message!]\n  message(messageId: ID!): Message\n  user(userId: ID!): User!\n  users: [User!]\n  analytics(messageId: ID!, type: CounterType!): MessageAnalytics\n}\n\ntype Mutation {\n  newMessage(input: NewMessageInput!): NewMessagePayload!\n  newUser(input: NewUserInput!): NewUserPayload!\n  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!\n}\n\ntype Message {\n  id: ID!\n  text: String!\n  createdBy: ID!\n  createdAt: DateTime!\n  tags: [String!]\n}\n\ntype NewMessageInput {\n  text: String!\n  tags: [String!]\n}\n\ntype NewMessagePayload {\n  message: Message\n}\n\ntype NewUserInput {\n  username: String!\n  password: String!\n}\n\ntype ResetPasswordInput {\n  username: String!\n  password: String!\n}\n\ntype NewUserPayload {\n  user: User\n}\n\ntype ResetPasswordPayload {\n  user: User\n}\n\ntype User {\n  id: ID!\n  username: String!\n  messages: [Message!]\n}\n\ntype MessageAnalytics {\n  id: ID!\n  messageId: ID!\n  count: Int!\n  type: CounterType!\n}\n\nenum CounterType {\n  VIEWS\n  LIKES\n  REPLIES\n}\n</code></pre><h3>Renaming and Removing Types</h3><p>Though this is nice, we would like to go even further and enhance our <code>Message</code> type like the following:</p><pre><code class=\"language-graphql\">type Message {\n  id: ID!\n  text: String!\n  createdBy: User\n  createdById: ID!\n  createdAt: DateTime!\n  tags: [String!]\n  views: Int!\n  likes: Int!\n  replies: Int!\n}\n</code></pre><p>Moreover, we would like to remove the <code>analytics</code> field from our query type since we have integrated the analytics data directly into our <code>Message</code> type.</p><p>Since with the root field gone we have no way of accessing <code>MessageAnalytics</code> and <code>CounterType</code>, let`s also get rid of these types.</p><p>The stitching builder has powerful refactoring functions that even can be extended by writing custom document- and type-rewriters.</p><p>In order to remove a field or a type we can tell the stitching builder to ignore them by calling one of the ignore extension methods.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;))\n  .AddExtensionsFromFile(&quot;./graphql/Extensions.graphql&quot;)\n  .IgnoreField(&quot;analytics&quot;, &quot;Query&quot;, &quot;analytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;MessageAnalytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;CounterType&quot;)\n  .AddSchemaConfiguration(c =&gt;\n  {\n    c.RegisterExtendedScalarTypes();\n  })\n</code></pre><blockquote><p>There are also methods for renaming types and fields where the stitching engine will take care that the schema is consitently rewritten so that all the type references will refer to the corrent new type/field name.</p></blockquote><p>With that we have removed the types from our stitched schema. Now, let us move on to extend our message type.</p><pre><code class=\"language-graphql\">extend type Message {\n  createdBy: User!\n    @delegate(schema: &quot;users&quot;, path: &quot;user(id: $fields:createdById)&quot;)\n  views: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  likes: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  replies: Int!\n    @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n}\n</code></pre><p>Since we introduced a new field <code>createdBy</code> that basically overwrites the field that we have already declared on our original <code>Message</code> type, we need to rename the original field <code>createdBy</code> to <code>createdById</code> so that we are still able to use it.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;))\n  .AddExtensionsFromFile(&quot;./graphql/Extensions.graphql&quot;)\n  .IgnoreField(&quot;analytics&quot;, &quot;Query&quot;, &quot;analytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;MessageAnalytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;CounterType&quot;)\n  .RenameField(&quot;messages&quot;, &quot;Message&quot;, &quot;createdBy&quot;, &quot;createdById&quot;)\n  .AddSchemaConfiguration(c =&gt;\n  {\n    c.RegisterExtendedScalarTypes();\n  })\n</code></pre><blockquote><p>It is important to now that the document- and type-rewriters are executed before the schemas are merged and the extensions integrated.</p></blockquote><p>Our new schema now looks like the following:</p><pre><code class=\"language-graphql\">type Query {\n  me: User!\n  messages(userId: ID!): [Message!]\n  message(messageId: ID!): Message\n  user(userId: ID!): User!\n  users: [User!]\n}\n\ntype Mutation {\n  newMessage(input: NewMessageInput!): NewMessagePayload!\n  newUser(input: NewUserInput!): NewUserPayload!\n  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!\n}\n\ntype Message {\n  id: ID!\n  text: String!\n  createdBy: User\n  createdById: ID!\n  createdAt: DateTime!\n  tags: [String!]\n  views: Int!\n  likes: Int!\n  replies: Int!\n}\n\ntype NewMessageInput {\n  text: String!\n  tags: [String!]\n}\n\ntype NewMessagePayload {\n  message: Message\n}\n\ntype NewUserInput {\n  username: String!\n  password: String!\n}\n\ntype ResetPasswordInput {\n  username: String!\n  password: String!\n}\n\ntype NewUserPayload {\n  user: User\n}\n\ntype ResetPasswordPayload {\n  user: User\n}\n\ntype User {\n  id: ID!\n  username: String!\n  messages: [Message!]\n}\n</code></pre><h3>Query Rewriter</h3><p>As can be seen, it is quite simple to stitch multiple schemas together and enhance them with the stitching builder.</p><p><strong>But how can we go further and hook into the query rewriter of the stitching engine?</strong></p><p>Let us for instance try to get rid of the <code>createdById</code> field of the <code>Message</code> type as we actually do not want to expose this field to the consumer of the stitched schema.</p><p>Since our resolver for the newly introduced <code>createdBy</code> field is dependent on the <code>createdById</code> field in order to fetch the <code>User</code> from the remote schema, we would need to be able to request it as some kind of a hidden field whenever a <code>Message</code> object is resolved.</p><p>We could then write a little field middleware that copies us the hidden field data into our scoped context data, so that we are consequently able to use the id in our <code>delegate</code> directive by accessing the <code>createdById</code> via the scoped context data instead of referring to a field of the <code>Message</code> type.</p><p>The stitching engine allows us to hook into the the query rewrite process and add our own rewrite logic that could add fields or even large sub-queries.</p><p>The first thing we need to do here is to create a new class that inherits from <code>QueryDelegationRewriterBase</code>.</p><p>The base class exposes two virtual methods <code>OnRewriteField</code> and <code>OnRewriteSelectionSet</code>.</p><p>A selection set describes a selection of fields and fragments on a certain type.</p><p>So, in order to fetch a hidden field every time a certain type is requested we would want to overwrite <code>OnRewriteSelectionSet</code>.</p><pre><code class=\"language-csharp\">private class AddCreatedByIdQueryRewriter\n    : QueryDelegationRewriterBase\n{\n    public override SelectionSetNode OnRewriteSelectionSet(\n        NameString targetSchemaName,\n        IOutputType outputType,\n        IOutputField outputField,\n        SelectionSetNode selectionSet)\n    {\n        if(outputType.NamedType() is ObjectType objectType\n          &amp;&amp; objectType.Name.Equals(&quot;Message&quot;))\n        {\n            return selectionSet.AddSelection(\n                new FieldNode\n                (\n                    null,\n                    new NameNode(&quot;createdBy&quot;),\n                    new NameNode(&quot;createdById&quot;),\n                    Array.Empty&lt;DirectiveNode&gt;(),\n                    Array.Empty&lt;ArgumentNode&gt;(),\n                    null\n                ));\n        }\n\n        return selectionSet;\n    }\n}\n</code></pre><p>The syntax nodes have a lot of little rewrite helpers like <code>AddSelection</code>. These helper methods basically branch of the syntax tree and return a new version that contains the applied change.</p><p>In our case we get a new <code>SelectionSetNode</code> that now also contains a field <code>createdBy</code> with an alias <code>createdById</code>. In a real-world implementation we should use a more complex alias name like <code>___internal_field_createdById</code> in order to avoid collisions with field selections of the query.</p><p>Query delegation rewriters are registered with the dependency injection and not with our stitching builder.</p><pre><code class=\"language-csharp\">services.AddQueryDelegationRewriter&lt;AddCreatedByIdQueryRewriter&gt;();\n</code></pre><blockquote><p>Query delegation rewriters are hosted as scoped services and can be injected with <code>IStitchingContext</code> and <code>ISchema</code> in order to access the remote schemas or the stitched schema for advanced type information.</p></blockquote><p>With that in place, the stitching engine will always fetch the requested field for us whenever a <code>Message</code> object is requested.</p><p>So, now let us move on to write a little middleware that copies this data into our scoped resolver context data map. The data in this map will only be available to the resolvers in the subtree of the message type.</p><p>A field middleware has to be declared via the stitching builder.</p><pre><code class=\"language-csharp\">services.AddStitchedSchema(builder =&gt; builder\n  .AddSchemaFromHttp(&quot;messages&quot;)\n  .AddSchemaFromHttp(&quot;users&quot;)\n  .AddSchemaFromHttp(&quot;analytics&quot;))\n  .AddExtensionsFromFile(&quot;./graphql/Extensions.graphql&quot;)\n  .IgnoreField(&quot;analytics&quot;, &quot;Query&quot;, &quot;analytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;MessageAnalytics&quot;)\n  .IgnoreType(&quot;analytics&quot;, &quot;CounterType&quot;)\n  .IgnoreField(&quot;messages&quot;, &quot;Message&quot;, &quot;createdBy&quot;)\n  .AddSchemaConfiguration(c =&gt;\n  {\n    c.RegisterExtendedScalarTypes();\n\n    c.Use(next =&gt; async context =&gt;\n    {\n        await next.Invoke(context);\n\n        if(context.Field.Type.NamedType() is ObjectType objectType\n          &amp;&amp; objectType.Name.Equals(&quot;Message&quot;)\n          &amp;&amp; context.Result is IDictionary&lt;string, object&gt; data\n          &amp;&amp; data.TryGetValue(&quot;createdById&quot;, out object value))\n        {\n            context.ScopedContextData =\n                context.ScopedContextData.SetItem(&quot;createdById&quot;, value);\n        }\n    })\n  })\n</code></pre><blockquote><p>We could also declare a field middleware as class. More about what can be done with a field middleware can be found <a href=\"https://hotchocolate.io/docs/middleware\">here</a>.</p></blockquote><p>With all of this in place we can now rewrite our <code>Message</code> type extension and access the <code>createdById</code> from the scoped context data:</p><pre><code class=\"language-graphql\">extend type Message {\n  createdBy: User!\n    @delegate(schema: &quot;users&quot;, path: &quot;user(id: $scopedContextData:createdById)&quot;)\n  views: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  likes: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  replies: Int!\n    @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n}\n</code></pre><h3>Customizing Stitching Builder</h3><p>The stitching builder can be extended on multiple levels by writing different kinds of schema syntax rewriter.</p><h4>Source Schema Rewriter</h4><p>The refactoring methods that we provide like <code>IgnoreField</code> or <code>RenameType</code> and so on rewrite the source schemas before they are merged.</p><p>In order to rewrite the source schema we can opt to create a <code>IDocumentRewriter</code> that is able to rewrite the whole schema document, or a <code>ITypeRewriter</code> that only can rewrite parts of a type definition.</p><p>If we wanted to delete a type or write a rewriter that also refactors the impacted types of a change then the <code>IDocumentRewriter</code> would be the way to go.</p><p>If we wanted to rewrite just parts of a type like adding some documentation or adding new fields to a type, basically things that do not impact other types, we could opt for the <code>ITypeRewriter</code>.</p><p>In both types we could opt to use the rewriter and visitor base classes that are included in our parser package.</p><blockquote><p>Information about our parser can be found <a href=\"https://hotchocolate.io/docs/parser\">here</a>.</p></blockquote><h4>Merged Schema Rewriter</h4><p>Apart from the source schema rewriters we can also rewrite the schema document after it has been merged:</p><pre><code class=\"language-csharp\">IStitchingBuilder AddMergedDocumentRewriter(Func&lt;DocumentNode, DocumentNode&gt; rewrite);\n</code></pre><p>This can be very useful if we want to first let all source schema rewriters do their work and annotate the types. With the annotations in place we could write complex rewriters that further enhance our stitched schema.</p><p>Also, if we just wanted to validate the schema for merge errors or collect information on the rewritten schema we are able to add schema visitors that run after all schema modifications are done.</p><pre><code class=\"language-csharp\">IStitchingBuilder AddMergedDocumentVisitor(Action&lt;DocumentNode&gt; visit);\n</code></pre><h4>Merge Rules</h4><p>In most cases the default merge rules should be enough. But with more domain knowledge about the source schemas one could write more aggressive merge rules.</p><p>The merge rules are chained and pass along what they cannot handle. The types of the various schemas are bucketed by name and passed to the merge rule chain.</p><h2>Authentication</h2><p>In many cases schemas will be protected by some sort of authentication. In most cases http requests are authenticated with bearer tokens that are passed along as <code>Authorization</code> header.</p><p>Moreover, the most common case that we have seen so far is that people want to pass the tokens along to the remote schema.</p><p>The stitching engine creates a lazy query executor that will only start merging the schemas on the first call to the GraphQL gateway. This allows us to use the token of an incoming call to execute the introspection queries on the remote schemas. This also safes us from having to store some kind of service token with the GraphQL gateway.</p><p>In order to pass on the incoming <code>Authorization</code> header to our registered HttpClients we need to first register the HttpContext accessor from ASP.net core.</p><pre><code class=\"language-csharp\">services.AddHttpContextAccessor();\n</code></pre><p>Next, we need to update our HttpClient factory declaration:</p><pre><code class=\"language-csharp\">services.AddHttpClient(&quot;messages&quot;, (sp, client) =&gt;\n{\n    HttpContext context = sp.GetRequiredService&lt;IHttpContextAccessor&gt;().HttpContext;\n\n    if (context.Request.Headers.ContainsKey(&quot;Authorization&quot;))\n    {\n        client.DefaultRequestHeaders.Authorization =\n            AuthenticationHeaderValue.Parse(\n                context.Request.Headers[&quot;Authorization&quot;]\n                    .ToString());\n    }\n\n    client.BaseAddress = new Uri(&quot;http://127.0.0.1:5050&quot;);\n});\n</code></pre><p>Another variant can also be to store service tokens for the remote schemas with our GraphQL gateway.</p><p>How you want to implement authentication strongly depends on your needs. With the reliance on the HttpClient factory from the ASP.net core foundation we are very flexible and can handle multiple scenarios.</p><h2>Batching</h2><p>The stitching layer transparently batches queries to the remote schemas. So, if you extend types like the following:</p><pre><code class=\"language-graphql\">extend type Message {\n  views: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  likes: Int! @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n  replies: Int!\n    @delegate(schema: &quot;analytics&quot;, path: &quot;analytics(id: $fields:id)&quot;)\n}\n</code></pre><p>We do send only a single request to your remote schema instead of three. The batching mechanism works not only within one type but extends to all requests that are executed in a resolver batch.</p><p>Furthermore, we are also including calls that are done through direct calls on the <code>IStitchingContext</code>.</p><p>Batching works very similar to <em>DataLoader</em> where the stitching engine sends requests through the <code>IRemoteQueryClient</code> which consequently only fetches the data once the query engine signals that all resolvers have been enqueued and have registered their calls against the remote schemas. This reduces the calls to the remote-schemas significantly and improves the overall performance.</p><p>So, if we had two query calls:</p><p>Query 1:</p><pre><code class=\"language-graphql\">{\n  customer(id: &quot;abc&quot;) {\n    name\n    contracts {\n      id\n    }\n  }\n}\n</code></pre><p>Query 2:</p><pre><code class=\"language-graphql\">{\n  customer(id: &quot;def&quot;) {\n    name\n    contracts {\n      id\n    }\n  }\n}\n</code></pre><p>We would merge those two queries into one:</p><pre><code class=\"language-graphql\">{\n  __1: customer(id: &quot;abc&quot;) {\n    name\n    contracts {\n      id\n    }\n  }\n  __2: customer(id: &quot;def&quot;) {\n    name\n    contracts {\n      id\n    }\n  }\n}\n</code></pre><p>This lets the remote schema optimize the calls much better since now the remote schema could take advantage of things like <em>DataLoader</em> etc.</p><h2>Root Types</h2><p>We are currently supporting stitching <code>Query</code> and <code>Mutation</code>.</p><p>With Version 9 we will introduce stitching the <code>Subscription</code> type.</p><p>Stitching queries is straight forward and works like described earlier. Mutations are also quite straight forward, but it is often overlooked that mutations are executed with a different execution strategy.</p><p>Query resolvers are executed in parallel when possible. All fields of a query have to be side-effect free.</p><p><a href=\"https://facebook.github.io/graphql/June2018/#sec-Normal-and-Serial-Execution\">https://facebook.github.io/graphql/June2018/#sec-Normal-and-Serial-Execution</a></p><blockquote><p>Normally the executor can execute the entries in a grouped field set in whatever order it chooses (normally in parallel). Because the resolution of fields other than top‐level mutation fields must always be side effect‐free and idempotent, the execution order must not affect the result, and hence the server has the freedom to execute the field entries in whatever order it deems optimal.</p></blockquote><p>The top‐level mutation fields are executed serially which guarantees that the top-level fields are executed one after the other.</p><pre><code class=\"language-graphql\">mutation {\n  createUser(userName: &quot;foo&quot;) {\n    someFields\n  }\n  addUserToGroup(userName: &quot;foo&quot;, groupName: &quot;bar&quot;) {\n    someFields\n  }\n}\n</code></pre><p>The above example first creates a user and then adds the created user to a group. This means that mutations can only be stitched on the top level. Everything, that you stitch in the lower levels is delegating the request to a <code>Query</code> type.</p><p>Or, even simpler put, only fields that are declared on the mutation type can delegate to a mutation field on a remote query.</p><p>Let&#x27;s put that in a context.</p><pre><code class=\"language-graphql\">type Mutation {\n  newUser(input: NewUserInput!): NewUserPayload! @delegate(schema: &quot;users&quot;)\n}\n\ntype NewUserInput {\n  username: String!\n  password: String!\n}\n\ntype NewUserPayload {\n  user: User\n}\n\ntype User {\n  id: ID!\n  username: String!\n  messages: [Message!]\n    @delegate(schema: &quot;messages&quot;, path: &quot;messages(userId: $fields:Id)&quot;)\n}\n</code></pre><p>In the above example we have a mutation that delegates the <code>newUser</code> field to the <code>newUser</code> mutation of the <code>users</code> schema. The mutation returns the <code>NewUserPayload</code> which has a field <code>user</code> that returns the newly created user. The <code>User</code> object delegates the <code>messages</code> field to the message schema. Since this field is resolved in the third level it will delegated to the query type of the <code>messages</code> schema.</p><p>This also means that we cannot group mutations like we could group queries. So, something like the following would not work since it is not spec-compliant:</p><pre><code class=\"language-graphql\">type Mutation {\n  userMutations: UserMutations\n}\n\ntype UserMutations {\n  newUser(input: NewUserInput): NewUserPayload\n}\n</code></pre><h2>Stitching Context</h2><p>The stitching engine provides a lot of extension points, but if we wanted to write the stitching for one specific resolver by ourselves then we could do that by using the <code>IStitchingContext</code> which is a scoped service and can be resolved through the resolver context.</p><pre><code class=\"language-csharp\">IStitchingContext stitchingContext = context.Service&lt;IStichingContext&gt;();\nIRemoteQueryClient remoteQueryClient = stitchingContext.GetRemoteQueryClient(&quot;messages&quot;);\nIExecutionResult result = remoteQueryClient.ExecuteAsync(&quot;{ foo { bar } }&quot;)\n</code></pre><h2>Example</h2><p>We have a simple stitching example <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/Stitching\">here</a>.</p><h2>Version 9</h2><p>We originally wanted to include subscription stitching with version 8, but are now moving this feature to next version.</p><p>Apart from that, Version 9 will mainly focus on schema improvements.</p><p>If you have feedback or feature requests for our schema stitching we love to talk to you about it. Head over to our slack channel.</p>",
            "url": "https://chillicream.com/blog/2019/02/20/schema-stitching",
            "title": "GraphQL - Schema Stitching with Version 8",
            "summary": "With version 8 of Hot Chocolate we have mainly focused on schema stitching. One of the most requested features in this area was auto…",
            "date_modified": "2019-02-20T00:00:00.000Z",
            "date_published": "2019-02-20T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/02/04/hot-chocolate-0.7.0",
            "content_html": "<p>Today we have released Hot Chocolate version 0.7.0 which brings a lot of new features, improvements and bug fixes. With this post I walk you through the major changes.</p><p>The main focus of this release was to make the execution engine more extendable.</p><p>The execution engine in version 0.6.0 was closed and as a user of Hot Chocolate you didn&#x27;t really have any chance to change it&#x27;s behavior.</p><p>The only way to write field middleware components was through directives. With our new release this will fundamentally change.</p><h2>QueryExecutionBuilder</h2><p>With version 0.7.0 we opened up the field middleware pipeline to be extended.</p><p>Moreover, we broke the query execution pipeline into query middleware components that can be swapped out or extended by writing a query middleware.</p><p>This all can be done with the new <code>QueryExecutionBuilder</code> that provides a simple to use API to customize how the query executor works.</p><pre><code class=\"language-csharp\">  IQueryExecutor executor = QueryExecutionBuilder.New()\n    .Use(next =&gt; context =&gt;\n    {\n      // ...\n    })\n    .UseDefaultPipeline()\n    .Build(schema);\n</code></pre><p>Instead of using the default pipeline we can also add the included middleware components one by one and swap out the ones that we do want to replace.</p><pre><code class=\"language-csharp\">  IQueryExecutor executor = QueryExecutionBuilder.New()\n    .AddOptions(options)\n    .AddErrorHandler()\n    .AddQueryValidation()\n    .AddDefaultValidationRules()\n    .AddQueryCache(options.QueryCacheSize)\n    .AddExecutionStrategyResolver()\n    .AddDefaultParser()\n    .Use(next =&gt; context =&gt;\n    {\n      // ...\n    })\n    .UseInstrumentation(options.TracingPreference)\n    .UseRequestTimeout()\n    .UseExceptionHandling()\n    .UseQueryParser()\n    .UseValidation()\n    .UseOperationResolver()\n    .UseMaxComplexity()\n    .UseOperationExecutor();\n    .Build(schema);\n</code></pre><p>On top of the new execution pipeline we build features like:</p><ul><li>Apollo Tracing</li><li>Schema Stitching</li><li>Pagination Support</li></ul><p>More about this can be read <a href=\"https://hotchocolate.io/docs/middleware\">here</a>.</p><h2>Syntax Rewriter</h2><p>We also invested in our parser and added a lot of visitor and rewriter base classes that make working with the syntax tree less effort.</p><p><strong>What are visitors and rewriter good for?</strong></p><p>We started really thinking about this feature when we conceived the new schema stitching. We wanted to branch of parts of the query and rewrite them to become a query for another schema that is located somewhere else.</p><p>Rewriters are basically visitors that walk the graph and as they do that create a new query. Basically you pass in a syntax node and the rewriter returns a new syntax node that represents the rewritten node.</p><pre><code class=\"language-csharp\">FieldNode newField = rewriter.Rewrite(originalField);\n</code></pre><p>This can be very useful if we want to map a graph to a database or create something like a schema stitching layer etc.</p><p>More about this can be read <a href=\"https://hotchocolate.io/docs/parser\">here</a>.</p><h2>GraphQL Spec State</h2><p>With version 0.7.0 we have added support for repeatable directives. This feature is slated for the next GraphQL spec version and allows to pipeline directives like the following:</p><p>{\na @fetch @replace(&#x27;a&#x27; &#x27;b&#x27;) @replace(&#x27;b&#x27; &#x27;c&#x27;)\n}</p><p>This behavior feels really awesome when you use executable directives, since with this you can build the field resolver pipeline by stacking directives together.</p><p><em>Directives are per default non-repeatable.</em></p><h2>Error Filter</h2><p>One of the regular questions users had was about how to handle custom exceptions with Hot Chocolate.</p><p>With exception filters we now provide you with a simple way to do just this.</p><p>The execution engine will transform any exception thrown into a generic GraphQL error.</p><p>With exception filters you can then rewrite those errors for certain exceptions in order to provide more useful information.</p><p>More about this can be read <a href=\"https://hotchocolate.io/docs/errors\">here</a>.</p><h2>Schema Stitching</h2><p>On top of the execution improvements we built our new schema stitching capabilities. With those you are able to easily fuse service endpoints together.</p><p>More about this can be read <a href=\"2019-01-24-schema-stitching.md\">here</a>.</p><h2>Apollo Tracing</h2><p>With version 0.7.0 we have introduced diagnostic sources that can be used to add custom tracing and diagnostic solutions.</p><p>Furthermore, we now support <a href=\"https://github.com/apollographql/apollo-tracing\">Apollo Tracing</a>. Apollo Tracing can be opted in by setting the tracing preference on the execution options. We recommend to switch it to on-demand, which allows you to send a header when ever you want to get performance performance information about a call.</p><h2>Relay and Paging</h2><p>We made creating relay compliant schemas a lot easier with this release. We introduced the paging structures as well as the node interface.</p><p>Relay compliant paging can be done with one line of code if your data is provided by <code>IQueryable&lt;T&gt;</code>.</p><pre><code class=\"language-csharp\">descriptor\n  .Field(t =&gt; t.GetCustomers)\n  .UsePaging&lt;CustomerType&gt;();\n</code></pre><p>Moreover, we have introduced a middleware that makes your IDs schema unique like required by the relay server specs without you having to implement any of that.</p><p>We will follow up this post with a post on how to best build schemas for relay.</p><p>More about paging can be found <a href=\"https://hotchocolate.io/docs/pagination\">here</a>.</p><h2>Type Conversion</h2><p>Until now the type conversion logic of Hot Chocolate was not accessible by the developer. This caused a lot of frustration since we were not able to add custom type conversions in a transparent way. So, basically the user had to add this code into his/her resolver logic. This felt like clutter that should not be there.</p><p>We have now introduced a new type conversion API.</p><p>Let us say you are working with mongo and you want to add an <code>ObjectId</code> conversion that basically converts <code>string</code> to <code>ObjectId</code> and <code>ObjectId</code> to <code>string</code>.</p><pre><code class=\"language-csharp\">TypeConversion.Default.Register&lt;string, ObjectId&gt;(from =&gt; ObjectId.Parse(from));\nTypeConversion.Default.Register&lt;ObjectId, string&gt;(from =&gt; from.ToString());\n</code></pre><p>So, that basically settles it. Two lines of code an you are done. You can also implement <code>ITypeConverter</code> in order to accommodate more complex code or just because you want to have your converters in class form.</p><p>Furthermore, we can create a new <code>TypeConversion</code> instance that only contains our specified conversion logic and none of our default converters in order to have tight control over them.</p><p>In this case we add the <code>TypeConversion</code> instance to our dependency injection and the execution engine will prefer the one provided via dependency injection over <code>TypeConversion.Default</code>.</p><h2>DataLoader</h2><p>We already provided an API for writing <em>DataLoader</em> but due to feedback from the community we rewrote our implementation to make it easier to use. You can now write <em>DataLoader</em> with a single line of code by providing us with a delegate that fetches your data.</p><p>An example project that shows the new <em>DataLoader</em> can be found <a href=\"https://github.com/ChilliCream/hotchocolate-examples/tree/master/DataLoader\">here</a>.</p><p>Or head over to our documentation <a href=\"https://hotchocolate.io/docs/dataloaders\">here</a>.</p><h2>Scalar Types</h2><p>We removed our extended scalars from the base setup. This means that you now have to tell your schema to use these.</p><pre><code class=\"language-csharp\">Schema.Create(c =&gt;\n{\n    c.RegisterExtendedScalarTypes();\n});\n</code></pre><p>This gives you more control about your type system and allows you to implement your own version of long etc.</p><p>More about scalar types can be found <a href=\"https://hotchocolate.io/docs/custom-scalar-types\">here</a>.</p><h2>Generic InterfaceType and UnionType</h2><p>The generic <code>InterfaceType</code> allows you to assign a .Net interface to a GraphQL interface. All object types that then have a .Net type associated will automatically implement this interface if the .Net type implements the .Net interface. Confused :)</p><p>Let`s see some code:</p><pre><code class=\"language-csharp\">public class FooType : InterfaceType&lt;IFoo&gt;\n{\n\n}\n</code></pre><p>If we would do nothing else we will infer the fields from the interface.</p><p>If we now had the following type:</p><pre><code class=\"language-csharp\">public class Bar : IFoo { }\n\npublic class BarType : ObjectType&lt;Bar&gt;\n{\n\n}\n</code></pre><p>Then we do not explicitly need to point to the interface anymore since we can infer the usage of the interface.</p><p>The same works for generic union types where you now can use marker interfaces to assign types to a set. For our purists that only want to you .Net types the following works now to:</p><pre><code class=\"language-csharp\">Schema.Create(c =&gt;\n{\n    c.RegisterType&lt;IFoo&gt;();\n    c.RegisterType&lt;Bar&gt;();\n});\n</code></pre><h2>Source Code Link</h2><p>We now support NuGet source code link. This means that you can debug into the Hot Chocolate source. This is often a great help when you are struggling with a bug or do want to check whats happening.</p><h2>What`s comming next</h2><p>Version 7 was a big release with a lot of new features that make it very easy to setup a GraphQL schema in .Net. With this release out we now focus on Version 8 which will focus on schema stitching. We will introduce capabilities like auto-stitching and auto-mocking. We already started working on the new schema stitching stories and if you think you would like to contribute ideas or code or documentation just feel free to talk to us. We are quite happy for any help.</p><p>After the schema stitching enhancements we will focus on the new schema builder with Version 9. The schema builder will bring in completely new capabilities that let you extend the schema building process. We are basically opening up the schema building process like we did with the execution engine.</p>",
            "url": "https://chillicream.com/blog/2019/02/04/hot-chocolate-0.7.0",
            "title": "GraphQL - Hot Chocolate 0.7.0",
            "summary": "Today we have released Hot Chocolate version 0.7.0 which brings a lot of new features, improvements and bug fixes. With this post I walk you…",
            "date_modified": "2019-02-04T00:00:00.000Z",
            "date_published": "2019-02-04T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2019/02/04/instrumentation-and-apollo-tracing",
            "content_html": "<p>Today we have released Hot Chocolate <code>0.7.0</code>, containing one cool new feature,\nwe wanne talk about here, namely <em>Apollo Tracing</em> which is extremely powerful in\nidentifing things like performance bottlenecks in our <em>GraphQL</em> <em>APIs</em> for\nexample. As a result, we had to enhance our general instrumentation layer, which\nwe all benefit from. For instance, now it&#x27;s way easier to register a\n<em>DiagnosticObserver</em> and bring in your own tracing framework, respectively. In\nthis blog article we will focus on these two topics.</p><h2>Apollo Tracing</h2><p><em>Apollo Tracing</em> is a <a href=\"https://github.com/apollographql/apollo-tracing\">performance tracing specification</a> for <em>GraphQL</em> servers.\nIt&#x27;s not part of the actual <em>GraphQL</em> <a href=\"https://facebook.github.io/graphql\">specification</a> itself, but there is a\ncommon agreement in the <em>GraphQL</em> community that this should be supported by\nall <em>GraphQL</em> servers.</p><p>So, we decided to introduce built-in <em>Apollo Tracing</em> support with this version.\nIn order to enable <em>Apollo Tracing</em> we just need to provide our own instance of\n<code>QueryExecutionOptions</code> to the <code>AddGraphQL</code> extension method and set the\n<code>TracingPreference</code> option to either <code>TracingPreference.Always</code> or\n<code>TracingPreference.OnDemand</code>. The difference between these two options is\nwhether tracing should be enabled always which means for each request or on\ndemand which means per request. But for now, enough words, let&#x27;s see how this\nwould look like in code.</p><pre><code class=\"language-csharp\">services.AddGraphQL(sp =&gt; Schema.Create(c =&gt;\n{\n    // Here goes the schema definition which is omitted for brevity purpose\n}),\nnew QueryExecutionOptions\n{\n    TracingPreference = TracingPreference.Always\n});\n</code></pre><p>There it is. Very simple and straightforward, right? For more information head\nover <a href=\"https://hotchocolate.io/docs/apollo-tracing\">here</a>. Now, let&#x27;s jump over to\nthe next topic.</p><h2>Instrumentation API</h2><p>In this version we did some heavy lifting in form of refactorings regarding the\nquery execution pipeline. This really helped us enhancing the\n<em>Instrumentation</em> <em>API</em> which has been evolved in two ways. First, we increased\nthe amount of available diagnostic events for more fine-grained tracing\nscenarios. Second, we simplified the registering of <em>DiagnosticObservers</em> by\nusing <em>Dependancy Injection</em> infrastructure. In the next example we can see how\nto register a custom <em>DiagnosticObservers</em>.</p><pre><code class=\"language-csharp\">services.AddGraphQL(sp =&gt; Schema.Create(c =&gt;\n{\n    // Here goes the schema definition which is omitted for brevity purpose\n}),\nbuilder =&gt;\n{\n    return builder\n        .UseDefaultPipeline()\n        .AddDiagnosticObserver&lt;CustomDiagnosticObserver&gt;();\n});\n</code></pre><p>So far so good. Writing a custom <em>DiagnosticObservers</em> is not difficult. Let&#x27;s\nsee how we could achieve this.</p><pre><code class=\"language-csharp\">using HotChocolate.Execution;\nusing Microsoft.Extensions.DiagnosticAdapter;\n\nnamespace CustomNamespace\n{\n    internal class CustomDiagnosticObserver\n        : IDiagnosticObserver\n    {\n        [DiagnosticName(&quot;HotChocolate.Execution.Query&quot;)]\n        public void QueryExecute()\n        {\n            // This method is required to enable recording &quot;Query.Start&quot; and\n            // &quot;Query.Stop&quot; diagnostic events. Do not write code in here.\n        }\n\n        [DiagnosticName(&quot;HotChocolate.Execution.Query.Start&quot;)]\n        public void BeginQueryExecute(IQueryContext context)\n        {\n            // Here goes your code to trace begin query execution events.\n        }\n\n        [DiagnosticName(&quot;HotChocolate.Execution.Query.Stop&quot;)]\n        public void EndQueryExecute(\n            IQueryContext context,\n            IExecutionResult result)\n        {\n            // Here goes your code to trace end query execution events.\n        }\n    }\n}\n</code></pre><p>In the above example we showed you just a few diagnostic events. Head over\n<a href=\"https://hotchocolate.io/docs/instrumentation\">here</a> for a complete list of\ndiagnostic events.</p><p>We hope you enjoyed reading and be welcome to let us know what you think about\nit in the comments section. Thank you!</p>",
            "url": "https://chillicream.com/blog/2019/02/04/instrumentation-and-apollo-tracing",
            "title": "GraphQL .NET Instrumentation API and Apollo Tracing",
            "summary": "Today we have released Hot Chocolate  0.7.0 , containing one cool new feature,\nwe wanne talk about here, namely  Apollo Tracing  which is…",
            "date_modified": "2019-02-04T00:00:00.000Z",
            "date_published": "2019-02-04T00:00:00.000Z",
            "author": {
                "name": "Rafael Staib",
                "url": "https://github.com/rstaib"
            }
        },
        {
            "id": "/blog/2019/01/24/schema-stitching",
            "content_html": "<p>What is schema stitching actually? Schema stitching is the capability to merge multiple GraphQL schemas into one schema on which queries can be queried.</p><h2>Introduction</h2><p>So, for what is that useful? In our case we have lots of specialized services that serve data for a specific problem domain. Some of these services are GraphQL services, some of them are REST services and yes sadly a little portion of those are still SOAP services.</p><p>Also, think about this, you cannot always start fresh and with schema stitching you can now create the schema of your <strong>dreams</strong> and merge all those other services into that new glorified schema.</p><p>Apart from that UI teams tend to <strong>NOT</strong> want to know about all those domain services and their specifics. They want to be able to fetch the data they need with one call, no under- or over-fetching and most importantly no repeated fetching because you first needed to fetch that special id with which you now can fetch this other thing. No, what we really want here is to have one source of truth and one call to get exactly what we want. That&#x27;s what GraphQL is all about.</p><p>Furthermore, we believe the schemas should be consistent and provide a way that is easily to consume.</p><p>With the preview version 0.7.0-preview.35 we are now introducing schema stitching capabilities to <a href=\"https://hotchocolate.io/\">Hot Chocolate</a>.</p><p>In this post I will walk you through how you can use schema stitching, what will be available with version 0.7.0 and what features come with the next releases.</p><h2>Getting Started</h2><p>Assume we have two schemas one dealing with the customer data, basically the data that would be located in a CRM system of a company, the other representing insurance data about the customer, basically the technical domain specific data that gives you all the insights into the customers insurance contracts.</p><p>The stitching layer is not limited to two schemas, you can actually stitch together how many schemas you want. But for our example we use those two mentioned schemas about customers and their contracts.</p><p>So, let&#x27;s say our customer schema looks something like the following:</p><pre><code class=\"language-graphql\">type Query {\n  customer(id: ID!): Customer\n  consultant(id: ID!): Consultant\n}\n\ntype Customer {\n  id: ID!\n  name: String!\n  consultant: Consultant\n}\n\ntype Consultant {\n  id: ID!\n  name: String!\n}\n</code></pre><p>In real life this schema would boast a lot more information about our customer but this will surfice for our little demo.</p><p>And our second schema dealing with the insurance contracts looks like the following:</p><pre><code class=\"language-graphql\">type Query {\n  contract(contractId: ID!): Contract\n  contracts(customerId: ID!): [Contract!]\n}\n\ninterface Contract {\n  id: ID!\n}\n\ntype LifeInsuranceContract implements Contract {\n  id: ID!\n  premium: Float\n}\n\ntype SomeOtherContract implements Contract {\n  id: ID!\n  expiryDate: DateTime\n}\n</code></pre><p>Imagine we have two servers serving up those schemas. The schema that we actually want for our UI team should look like the following:</p><pre><code class=\"language-graphql\">type Query {\n  customer(id: ID!): Customer\n}\n\ntype Customer {\n  id: ID!\n  name: String!\n  consultant: Consultant\n  contracts: [Contract!]\n}\n\ntype Consultant {\n  id: ID!\n  name: String!\n}\n\ninterface Contract {\n  id: ID!\n}\n\ntype LifeInsuranceContract implements Contract {\n  id: ID!\n  premium: Float\n}\n\ntype SomeOtherContract implements Contract {\n  id: ID!\n  expiryDate: DateTime\n}\n</code></pre><p>In order to make that happen you do not have to write actual code, we have create some directives that will tell the stitching layer what to do.</p><p>Before we start, we have to give our schemas some names, these names will be used to direct remote queries to the right endpoint.</p><p>Let&#x27;s name the customer schema <code>customers</code> and the contract schema <code>contracts</code>. With that let&#x27;s decorate our desired schema.</p><pre><code class=\"language-graphql\">type Query {\n  customer(id: ID!): Customer @schema(name: &quot;customer&quot;) @delegate\n}\n\ntype Customer {\n  id: ID!\n  name: String!\n  consultant: Consultant\n  contracts: [Contract!]\n    @schema(name: &quot;contract&quot;)\n    @delegate(path: &quot;contracts(customerId:$fields:id)&quot;)\n}\n\ntype Consultant {\n  id: ID!\n  name: String!\n}\n\ninterface Contract {\n  id: ID!\n}\n\ntype LifeInsuranceContract implements Contract {\n  id: ID!\n  premium: Float\n}\n\ntype SomeOtherContract implements Contract {\n  id: ID!\n  expiryDate: DateTime\n}\n</code></pre><p><code>@schema</code> basically points to the source schema, so the stitching middleware will redirect calls to a schema with the name that is specified by this directive.</p><p><code>@delegate</code> specifies how the data is fetched. If <code>@delegate</code> does not have any path specified than the middleware expects that the field on the target schema has the same specification.</p><p>If we look at the <code>customer</code> field then the middleware will assume that the source schema has the same customer field as root field as our stitched schema.</p><p>The <code>contracts</code> field on the other hand specifies a delegation path <code>contracts(customerId:$fields:id)</code>. The delegation path specifies the field that is called and where the arguments get their input from.</p><p>Let us assume you have a deeper field from which you want to fetch data like the following.</p><pre><code class=\"language-graphql\">foo(id:123) {\n  bar {\n    baz(top:1) {\n      qux\n    }\n  }\n}\n</code></pre><p>Since, we did not want to cram a query like this into one string we allow this to be done with a flat path.</p><pre><code class=\"language-text\">foo(id:$arguments:arg1).bar.baz(top:1)\n</code></pre><p>The argument assignment in the path can be done with GraphQL literals or with scope variables. The scope variables basically can refer to the fields of the declaring type (in case of our contracts field the declaring type is customer) and to the arguments of the field, in our case contracts has no arguments in the stitched schema.</p><h2>Server Configuration</h2><p>Now that we have configured our schema let&#x27;s create our server. The fastest way to do that is to use our server template.</p><p>Install the server template to your dotnet CLI:</p><pre><code class=\"language-bash\">dotnet new -i HotChocolate.Templates.Server\n</code></pre><p>Now let&#x27;s create our server:</p><pre><code class=\"language-bash\">mkdir stitching\ndotnet new graphql-server\n</code></pre><p>Open the server in the editor of your choice and upgrade the packages to 0.7.0-preview.35.</p><p>Go to the Startup.cs and add the HTTP clients that shall access the remote schema endpoints like the following:</p><pre><code class=\"language-csharp\">services.AddHttpClient(&quot;customer&quot;, client =&gt;\n{\n    client.BaseAddress = new Uri(&quot;http://127.0.0.1:5050&quot;);\n});\n\nservices.AddHttpClient(&quot;contract&quot;, client =&gt;\n{\n    client.BaseAddress = new Uri(&quot;http://127.0.0.1:5051&quot;);\n});\n</code></pre><p>Note that this is also the place where you would add authentication and header properties in order to access your remote schema endpoint.</p><p>The clients must be named clients and have to use the schema name that we used in our schema directive earlier.</p><p>Next let&#x27;s setup our remote schemas. Remote schemas are actually local schemas representing the remote schemas and allowing us to treat the remote schema as if it were a usual schema written with Hot Chocolate.</p><p>This also allows us to create middleware components and other things on such a schema althogh the schema does not actually live in our process.</p><p>So let us start with the customer schema, the customer schema does only use scalars defined in the spec. This means we do not have to declare any extra scalars to our stitching layer.</p><pre><code class=\"language-csharp\">serviceCollection.AddRemoteQueryExecutor(b =&gt; b\n    .SetSchemaName(&quot;customer&quot;)\n    .SetSchema(File.ReadAllText(&quot;Customer.graphql&quot;)));\n</code></pre><p>Again we use our schema name that we used earlier and we are loading a schema file describing the remote schema into the remote executor. We are basically building with that a schema the way you would with the schema-first approach.</p><p>Next, let&#x27;s setup our contracts schema. The contracts schema uses a <code>DateTime</code> scalar, this one is not specified in the spec so we have to tell our schema to use this one. Since Hot Chocolate specified a bunch of extended scalars we can import one of those. If we do not have a scalar matching the one of the remote schema we would need to implement this one by extending the class <code>ScalarType</code>.</p><pre><code class=\"language-csharp\">serviceCollection.AddRemoteQueryExecutor(b =&gt; b\n    .SetSchemaName(&quot;contract&quot;)\n    .SetSchema(FileResource.Open(&quot;Contract.graphql&quot;))\n    .AddScalarType&lt;DateTimeType&gt;());\n</code></pre><p>Now that we have setup our remote schema let&#x27;s stitch everything together by providing our prepared stitched schema file:</p><pre><code class=\"language-csharp\">serviceCollection.AddStitchedSchema(\n    FileResource.Open(&quot;Stitching.graphql&quot;),\n    c =&gt; c.RegisterType&lt;DateTimeType&gt;());\n</code></pre><p>Again like before we have to provide the extended scalar type that we used for the contracts schema.</p><p>Now, we are basically done and can fire up our server.</p><h2>Further Thoughts</h2><p>Since, remote schemas have a local schema representation in our process and the stitching layer is working on those local schemas we can also use native Hot Chocolate schemas to further extend a stitched schema.</p><p>So, all what I have described so far is included in the current preview release. We are still not done and are heavy at work getting our schema stitching even better.</p><p>With the next view preview builds we will introduce a batching layer to the schema stitching.</p><p>Think <em>DataLoader</em>. We will basically batch all request to a schema in one go. Imagine we had two delegated query for one remote schema:</p><p>Query A:</p><pre><code class=\"language-graphql\">{\n  a {\n    b\n  }\n}\n</code></pre><p>Query B:</p><pre><code class=\"language-graphql\">{\n  c {\n    d\n  }\n}\n</code></pre><p>The batching layer will rewrite those queries into one and send just one request to your remote endpoint:</p><pre><code class=\"language-graphql\">{\n  __1: a {\n    b\n  }\n\n  __2: c {\n    d\n  }\n}\n</code></pre><p>This way we have just one call and your remote endpoint can better optimize the data fetching with <em>DataLoader</em> and so on.</p><h2>Comming with 0.8.0</h2><p>Furthermore, we will introduce the ability to rename types. This is useful when you either want to make names more clear or if you have naming collisions. So, with the next releases we will introduce &#x27;@name&#x27; as a way to rename types and fields.</p><p>Also, the ability to auto-stitch schemas and auto-fetch the a remote schema via introspection is on our todo list.</p><p>In the beginning of this post I talked about stitching SOAP and REST, we are currently working on a feature that is called HTTP directives.</p><p>HTTP directives let you decorate a schema SDL and thus let you map REST services onto a GraphQL schema. This schema can also be included into a stitched schema. We will tell you more about that once we have a stable version ready to go.</p><p>Moreover, we will introduce a cast feature to our delegation path. This will basically allow you to use fragments without having to write the code.</p><pre><code class=\"language-text\">foo.bar&lt;baz&gt;(a:1).qux(b:1)\n</code></pre><p>This transalates basically to:</p><pre><code class=\"language-graphql\">{\n  foo {\n    bar(a: 1) {\n      ... on baz {\n        qux(b: 1)\n      }\n    }\n  }\n}\n</code></pre><h2>Wrapping things up</h2><p>We have uploaded the above example to the following GitHub repo so you can see a working example of the schema stitching.</p><p><a href=\"https://github.com/ChilliCream/hotchocolate-examples\">Stitching Example</a></p><p>If you are using the example start the two remote schemas by switching to their respective directory and call <code>dotnet run</code>.</p><p>After both schemas are running start the stitching layer. The stitching layer has <code>Apollo Tracing</code> enabled. Start the stitching layer also with <code>dotnet run</code> since the debugger slows the performance significantly down.</p><p>The first call on the stitched schema takes a little longer (maybe 300 ~ 500 ms) since we are compiling the resolvers into a in-memory assembly. All further calls are fast (4 ~ 8 ms) in our example. The real life performance depends on how fast your connection to the stitched remote schemas is and how many data you are fetching. With the new batching layer that is coming soon the performance of the schema stitching should further improve.</p><p>Open playground on http://localhost:5000/playground in order to fire up some requests agains our stitched schema and checkout the tracing tab for performance insights.</p><p>The following query might be a good starting point since it will expose the ids of our objects.</p><pre><code class=\"language-graphql\">{\n  customers {\n    id\n    contracts {\n      id\n    }\n  }\n}\n</code></pre><p>If you have further questions or need help you join our slack channel.</p>",
            "url": "https://chillicream.com/blog/2019/01/24/schema-stitching",
            "title": "GraphQL - Schema Stitching",
            "summary": "What is schema stitching actually? Schema stitching is the capability to merge multiple GraphQL schemas into one schema on which queries can…",
            "date_modified": "2019-01-24T00:00:00.000Z",
            "date_published": "2019-01-24T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2018/11/07/docusaurus-docs-redirect",
            "content_html": "<p>I recently run into an HTTP 404 error when calling /docs on my <em>Docusaurus</em> websites. This isn&#x27;t\nactually nice, because I expected to land on my documentation entry page e.g. introduction. First I\nthought, perhaps this is an issue with my setup. But I found out that even the <em>Docusaurus</em> website\nitself is suffering from this issue as well. So I tried to find a solution on the internet. But\nI couldn&#x27;t find anything except an issue on github describing the same behavior. So, with this article\nI try to help everyone saving their time and making the experience with <em>Docusaurus</em> even better.</p><p>So here is my solution.</p><ol><li>Go to your <code>website\\siteConfig.js</code> file and update the entry doc link in the <code>headerLinks</code>\nsection by adding <code>href: &quot;/docs&quot;</code> to it.</li></ol><p><strong>Before</strong></p><pre><code class=\"language-javascript\">{\n  // code omitted for brevity\n  headerLinks: [\n    {\n      doc: &quot;your-entry-doc&quot;,\n      label: &quot;Docs&quot;,\n    },\n  ];\n}\n</code></pre><p><strong>After</strong></p><pre><code class=\"language-javascript\">{\n  // code omitted for brevity\n  headerLinks: [\n    {\n      doc: &quot;your-entry-doc&quot;,\n      href: &quot;/docs&quot;,\n      label: &quot;Docs&quot;,\n    },\n  ];\n}\n</code></pre><ol start=\"2\"><li>Create a new file called <code>docs.js</code> under the <code>website\\pages\\en</code> path and insert the following\ncode.</li></ol><pre><code class=\"language-javascript\">/**\n * Copyright (c) 2017-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst React = require(&quot;react&quot;);\nconst Redirect = require(&quot;../../core/Redirect.js&quot;);\n\nconst siteConfig = require(process.cwd() + &quot;/siteConfig.js&quot;);\n\nfunction docUrl(doc, language) {\n  return (\n    siteConfig.baseUrl +\n    &quot;docs/&quot; +\n    (language ? language + &quot;/&quot; : &quot;&quot;) +\n    doc +\n    &quot;.html&quot;\n  );\n}\n\nclass Docs extends React.Component {\n  render() {\n    return (\n      &lt;Redirect\n        redirect={docUrl(&quot;your-entry-doc&quot;, this.props.language)}\n        config={siteConfig}\n      /&gt;\n    );\n  }\n}\n\nmodule.exports = Docs;\n</code></pre><p>This code is just doing a redirect to <code>/docs/your-entry-doc</code>. Don&#x27;t forget to replace\n<code>your-entry-doc</code> with your own value.</p><p>Perfect! With this little change, our <em>Docusaurus</em> website is now able to handle requests to the\n<code>/docs</code> root path.</p><p>One little thing: I have tested it with <em>Docusaurus</em> version <code>1.5.1</code>. However, just try it!</p>",
            "url": "https://chillicream.com/blog/2018/11/07/docusaurus-docs-redirect",
            "title": "Docusaurus - How to redirect requests to /docs to a default url instead of getting a 404 error",
            "summary": "I recently run into an HTTP 404 error when calling /docs on my  Docusaurus  websites. This isn't\nactually nice, because I expected to land…",
            "date_modified": "2018-11-07T00:00:00.000Z",
            "date_published": "2018-11-07T00:00:00.000Z",
            "author": {
                "name": "Rafael Staib",
                "url": "https://github.com/rstaib"
            }
        },
        {
            "id": "/blog/2018/09/02/hot-chocolate-0.4.5",
            "content_html": "<p>With version 0.4.5 we closed a lot of spec gaps and refined the schema configuration API.</p><p>We now are finished with implementing the query validation rules. The following rules were added since version 0.4.0:</p><ul><li>Argument Names <a href=\"https://github.com/ChilliCream/hotchocolate/issues/111\">111</a></li><li>Fragments Must Be Used <a href=\"https://github.com/ChilliCream/hotchocolate/issues/116\">116</a></li><li>Fragment Name Uniqueness <a href=\"https://github.com/ChilliCream/hotchocolate/issues/113\">113</a></li><li>Leaf Field Selections <a href=\"https://github.com/ChilliCream/hotchocolate/issues/110\">110</a></li><li>Fragments On Composite Types <a href=\"https://github.com/ChilliCream/hotchocolate/issues/115\">115</a></li><li>Fragment spreads must not form cycles <a href=\"https://github.com/ChilliCream/hotchocolate/issues/118\">118</a></li><li>Fragment spread target defined <a href=\"https://github.com/ChilliCream/hotchocolate/issues/117\">117</a></li><li>Fragment spread is possible <a href=\"https://github.com/ChilliCream/hotchocolate/issues/119\">119</a></li><li>Fragment Spread Type Existence <a href=\"https://github.com/ChilliCream/hotchocolate/issues/114\">114</a></li><li>Input Object Field Names <a href=\"https://github.com/ChilliCream/hotchocolate/issues/121\">121</a></li><li>Input Object Required Fields <a href=\"https://github.com/ChilliCream/hotchocolate/issues/123\">123</a></li><li>Input Object Field Uniqueness <a href=\"https://github.com/ChilliCream/hotchocolate/issues/122\">122</a></li><li>Directives Are Defined <a href=\"https://github.com/ChilliCream/hotchocolate/issues/124\">124</a></li><li>Values of Correct Type <a href=\"https://github.com/ChilliCream/hotchocolate/issues/120\">120</a></li></ul><p>We now also support the <code>@deprectaed</code> directive when using schema-first.</p><p>Furthermore, we fixed a lot of bugs around schema-first. So, at the moment code-first is still the most viable way to create a schema,but we are working hard to get both flavours on par.</p><p>Apart from that we now allow for non-terminating errors within a field-resolver.</p><pre><code class=\"language-csharp\">public IEnumerable&lt;ICharacter&gt; GetCharacter(string[] characterIds, IResolverContext context)\n{\n    foreach (string characterId in characterIds)\n    {\n        ICharacter character = _repository.GetCharacter(characterId);\n        if (character == null)\n        {\n            context.ReportError(\n                &quot;Could not resolve a character for the &quot; +\n                $&quot;character-id {characterId}.&quot;);\n        }\n        else\n        {\n            yield return character;\n        }\n    }\n}\n</code></pre><p>If you want to share resolver logic between types in your schema you can now do that with shared resolvers which can be bound to fields:</p><pre><code class=\"language-csharp\">public class PersonResolvers\n{\n    public Task&lt;IEnumerable&lt;Person&gt;&gt; GetFriends(Person person, [Service]IPersonRepository repository)\n    {\n        return repository.GetFriendsAsync(person.FriendIds);\n    }\n}\n\npublic class PersonType : ObjectType&lt;Person&gt;\n{\n    protected override void Configure(IObjectDescriptor&lt;Person&gt; desc)\n    {\n        desc.Field(t =&gt; t.FriendIds).Ignore();\n        desc.Field&lt;PersonResolver&gt;(t =&gt; t.GetFriends(default, default));\n    }\n}\n</code></pre><h2>What Comes Next</h2><p>With version 0.5 we will focus on subscriptions and custom directives.</p><p>Custom will allow for writing field resolver middlewares that alter or replace the default execution behaviour.</p><p>Subscriptions is one of our last spec gaps.</p>",
            "url": "https://chillicream.com/blog/2018/09/02/hot-chocolate-0.4.5",
            "title": "GraphQL - Hot Chocolate 0.4.5",
            "summary": "With version 0.4.5 we closed a lot of spec gaps and refined the schema configuration API. We now are finished with implementing the query…",
            "date_modified": "2018-09-02T00:00:00.000Z",
            "date_published": "2018-09-02T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2018/07/31/hot-chocolate-0.4.0",
            "content_html": "<p>With this version we introduce support for <em>DataLoaders</em> and custom context objects.</p><h2>Data Loaders</h2><p>Here is a short introduction to <em>DataLoaders</em>.</p><blockquote><p>A DataLoader is a generic utility to be used as part of your application&#x27;s data fetching layer to\nprovide a consistent API over various backends and reduce requests to those backends via batching\nand caching. -- facebook</p></blockquote><p>If you want to read more about <em>DataLoaders</em> in general, you can head over to Facebook&#x27;s <a href=\"https://github.com/facebook/dataloader\">GitHub repository</a>.</p><p>GraphQL is very flexible in the way you can request data. This flexibility also introduces new classes of problems called <em>n+1</em> issues for the GraphQL server developer.</p><p>In order to depict the issue that DataLoaders solve in this context, let me introduce a little GraphQL schema:</p><pre><code class=\"language-graphql\">type Query {\n  person(id: ID): Person\n}\n\ntype Person {\n  id: ID\n  name: String\n  friends: [Person]\n}\n</code></pre><p>The above schema allows to fetch a person by its internal identifier and each person has a list of friends that is represented by a list of persons.</p><p>Since GraphQL requests are not fixed requests like REST requests, the developer really defines what data he/she wants. This avoids overfetching data that you do not need and also saves you unecessary roundtrips to the GraphQL backend.</p><p>So, a query against the above schema could look like the following:</p><pre><code class=\"language-graphql\">{\n  a: person(id: &quot;a&quot;) {\n    name\n  }\n\n  b: person(id: &quot;b&quot;) {\n    name\n  }\n}\n</code></pre><p>The above request fetches two persons in one go without the need to call the backend twice. The problem for the GraphQL backend is that field resolvers are atomic and do not have any knoledge about the query as a whole. So, a field resolver does not know that it will be called multiple times in parallel to fetch similar or equal data from the same data source.</p><p>This basically represents the first case where <em>DataLoaders</em> help us by batching requests against our database or backend service. Currently, we allow <em>DataLoaders</em> per request and globally.</p><p>So, let&#x27;s look at some code in order to understand what they are doing. First, let&#x27;s have a look at how we would write our field resolver without <em>DataLoaders</em>:</p><pre><code class=\"language-csharp\">public async Task&lt;Person&gt; GetPerson(string id, [Service]IPersonRepository repository)\n{\n    return await repository.GetPersonById(id);\n}\n</code></pre><p>The above example would result in two calls to the person repository that would than fetch the persons one by one from our data source.</p><p>If you think that through you can see that each GraphQL request would cause multiple requests to our data source resulting in slugish performance and uneccessary roundtrips to our data source.</p><p>This, means that we reduced the roundtrips from our client to our server with GraphQL but multiplied the roundtrips between the data sources and the service layer.</p><p>With <em>DataLoaders</em> we can now centralise our person fetching and reduce the number of round trips to our data source.</p><p>First, we have to create a <em>DataLoader</em> that now acts as intermediary between a field resolver and the data source.</p><pre><code class=\"language-csharp\">public class PersonDataLoader\n    : DataLoaderBase&lt;string, Person&gt;\n{\n    private readonly IPersonRepository _repository;\n\n    public PersonDataLoader(IPersonRepository repository)\n        : base(new DataLoaderOptions&lt;string&gt;())\n    {\n        _repository = repository;\n    }\n\n    protected override Task&lt;IReadOnlyList&lt;Result&lt;string&gt;&gt;&gt; Fetch(\n        IReadOnlyList&lt;string&gt; keys)\n    {\n        return _repository.GetPersonBatch(keys);\n    }\n}\n</code></pre><p>The <em>DataLoader</em> is now injected by the execution engine as a field resolver argument.</p><p><em>DataLoaders</em> have to be injected at field resolver argument level and <strong>NOT</strong> as constructor arguments since the lifetime of a <em>DataLoader</em> is in many cases shorter than the class containing the field resolvers.</p><pre><code class=\"language-csharp\">public Task&lt;Person&gt; GetPerson(string id, [DataLoader]PersonDataLoader personLoader)\n{\n    return personLoader.LoadAsync(id);\n}\n</code></pre><p>Next, we have to register our <em>DataLoader</em> with the schema. By default, <em>DataLoaders</em> are registerd as per-request meaning that the execution engine will create one instance of each <em>DataLoader</em> per-request <strong>if</strong> a field resolver has requested a <em>DataLoader</em>. This ensures that, <em>DataLoaders</em> that are not beeing requested are not instantiated unnecessarily.</p><pre><code class=\"language-csharp\">Schema.Create(c =&gt;\n{\n    // your other code...\n\n    c.RegisterDataLoader&lt;PersonDataLoader&gt;();\n});\n</code></pre><p>Now, person requests in a single execution batch will be batched to the data source.</p><p>But there are still some more issues ahead that <em>DataLoaders</em> will help us with. For that we should amend our query a little bit.</p><pre><code class=\"language-graphql\">{\n  a: person(id: &quot;a&quot;) {\n    name\n    friends {\n      name\n    }\n  }\n\n  b: person(id: &quot;b&quot;) {\n    name\n    friends {\n      name\n    }\n  }\n}\n</code></pre><p>The above query now drills down into the friends property, which again yields persons.</p><p>Let&#x27;s, say our person object is located in a mongo database and the document would look something like the following:</p><pre><code class=\"language-json\">{\n  &quot;id&quot;:&quot;a&quot;\n  &quot;name&quot;:&quot;Foo&quot;\n  &quot;friends&quot;: [\n    &quot;b&quot;,\n    &quot;c&quot;,\n    &quot;d&quot;\n  ]\n}\n\n{\n  &quot;id&quot;:&quot;b&quot;\n  &quot;name&quot;:&quot;Bar&quot;\n  &quot;friends&quot;: [\n    &quot;a&quot;,\n    &quot;c&quot;,\n    &quot;e&quot;\n  ]\n}\n</code></pre><p>The person with ID <code>a</code> is also friends with person <code>b</code>. Moreover, <code>a</code> is also friends with <code>c</code> and <code>d</code>. Furthermore, <code>b</code> is friends with <code>a</code> and also friends with <code>c</code> and <code>e</code>.\nThe best case now would be that we only fetch <code>c</code>, <code>d</code> and <code>e</code> since we have already fetched <code>a</code> and <code>b</code>.</p><p>This is the second problem class the <em>DataLoader</em> utility helps us with since the <em>DataLoader</em> contains a cache and holds the resolved instances by default for the duration of your request.</p><p>For more information about our <em>DataLoader</em> implementation head over to our <em>DataLoader</em> <a href=\"https://github.com/ChilliCream/greendonut\">GitHub repository</a>.</p><p>As a side note, you are not bound to our <em>DataLoader</em> implementation. If you want to create your own implementation of <em>DataLoaders</em> or if you already have a <em>DataLoader</em> implementation then you can hook this up to our execution engine as well. I will explain this in the <em>DataLoader</em> documentation once I have finalised it.</p><h2>Custom Context Objects</h2><p>Custom context objects are basically custom .net objects that you can declare with the GraphQL engine and access throughout your request execution. Custom context objects can use dependency injection and have the same scoping as the <em>DataLoaders</em>.</p><p>For example you could declare a class that handles authorithation for your service like an IPrincipal and access this in each resolver.</p><pre><code class=\"language-csharp\">public Task&lt;ResolverResult&lt;Person&gt;&gt; GetPerson(string id, [State]MyPrincipal principal)\n{\n    if(principal.IsInRole(&quot;foo&quot;))\n    {\n      return new ResolverResult&lt;Person&gt;(personLoader.LoadAsync(id));\n    }\n    return new ResolverResult&lt;Person&gt;(\n      &quot;You do not have the access role to access this person.&quot;);\n}\n</code></pre><p>Moreover, you can use this custom context to store states in or caches during execution time. This will become especially usefull with our next version when we allow the writing of custom schema directives and field resolver middlewares.</p><p>Custom context objects are registerd like <em>DataLoaders</em>:</p><pre><code class=\"language-csharp\">Schema.Create(c =&gt;\n{\n    // your other code...\n\n    c.RegisterCustomContext&lt;MyPrincipal&gt;();\n});\n</code></pre><p>Like with <em>DataLoaders</em> we have muliple <code>RegisterCustomContext</code> overloads that allow for more control over how the object is created.</p><h2>Query Validation</h2><p>With this release we have also implemented the following query validation rules:</p><ul><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-All-Variables-Used\">All Variables Used</a></li><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-All-Variable-Uses-Defined\">All Variable Uses Defined</a></li><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-Directives-Are-In-Valid-Locations\">Directives Are In Valid Locations</a></li><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-Directives-Are-Unique-Per-Location\">Directives Are Unique Per Location</a></li><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-Variables-Are-Input-Types\">Variables Are Input Types</a></li><li><a href=\"http://facebook.github.io/graphql/June2018/#sec-Field-Selection-Merging\">Field Selection Merging</a></li></ul><p>You can follow our progress on which rule is implemented <a href=\"https://github.com/ChilliCream/hotchocolate/projects/3\">here</a>.</p><p>We plan for full compliance with the June 2018 spec version with version 0.6.0.</p><h2>Dependency Injection</h2><p>We reworked out dependency injection approach and have now integreaded the request services during request execution. Meaning you are now able to access HttpContext directly as a field resolver argument.</p><p>This was already possible with the old version through the accessor as a constructor injection.</p><p>Generally speaking, you can now let the execution engine inject any service as a field resolver argument.</p><pre><code class=\"language-csharp\">public async Task&lt;Person&gt; Example1(string id, [Service]IPersonRepository repository)\n{\n    return await repository.GetPersonById(id);\n}\n\n\npublic async Task&lt;Person&gt; Example2(string id, [Service]HttpContext context)\n{\n    return await repository.GetPersonById(id);\n}\n</code></pre><p>It is important to know that http related services are only available if the execution engine runs integrated into ASP.net core. So, basically if you are using our middleware.</p><p>From a design standpoint you should avoid accessing this directly and think about a custom context object which would provide some abstraction.</p><p>I will write some more on dependency injection sometime later this week.</p>",
            "url": "https://chillicream.com/blog/2018/07/31/hot-chocolate-0.4.0",
            "title": "GraphQL - Hot Chocolate 0.4.0",
            "summary": "With this version we introduce support for  DataLoaders  and custom context objects. Data Loaders Here is a short introduction to…",
            "date_modified": "2018-07-31T00:00:00.000Z",
            "date_published": "2018-07-31T00:00:00.000Z",
            "author": {
                "name": "Michael Staib",
                "url": "https://github.com/michaelstaib"
            }
        },
        {
            "id": "/blog/2018/07/30/green-donut-0.2.0",
            "content_html": "<p>Today we proudly released the first version of <em>Green Donut</em> -- a <em>DataLoader</em> implementation for <em>.net core</em> and <em>classic</em>.</p><p><strong>Additional Features</strong></p><ul><li><em>Sliding Expiration</em> for caching (default is set to zero which means that the entries in the cache will never expire)</li><li><em>Manual Dispatching</em> for dispatching programmatically</li></ul>",
            "url": "https://chillicream.com/blog/2018/07/30/green-donut-0.2.0",
            "title": "Green Donut 0.2.0",
            "summary": "Today we proudly released the first version of  Green Donut  -- a  DataLoader  implementation for  .net core  and  classic . Additional…",
            "date_modified": "2018-07-30T00:00:00.000Z",
            "date_published": "2018-07-30T00:00:00.000Z",
            "author": {
                "name": "Rafael Staib",
                "url": "https://github.com/rstaib"
            }
        },
        {
            "id": "/blog/2018/05/03/react-rasta-1.0.0",
            "content_html": "<p>Today we proudly released the first version of <em>React Rasta</em>.</p><p><em>React Rasta</em> is a responsive 12 column grid system which offers a lot of features and flexibility.\nIts <em>API</em> is clean and simple to ease development. <em>React Rasta</em> is also well tested to guarantee\nhigh quality. We hope <em>React Rasta</em> will support you by creating great application. Have fun!</p>",
            "url": "https://chillicream.com/blog/2018/05/03/react-rasta-1.0.0",
            "title": "React Rasta 1.0.0",
            "summary": "Today we proudly released the first version of  React Rasta . React Rasta  is a responsive 12 column grid system which offers a lot of…",
            "date_modified": "2018-05-03T00:00:00.000Z",
            "date_published": "2018-05-03T00:00:00.000Z",
            "author": {
                "name": "Rafael Staib",
                "url": "https://github.com/rstaib"
            }
        },
        {
            "id": "/blog/2013/09/12/jquery-steps-form-wizard",
            "content_html": "<p>This blog article was previously published on <a href=\"http://www.rafaelstaib.com/post/How-to-create-a-Form-Wizard-using-jQuery-Steps\">http://www.rafaelstaib.com/post/How-to-create-a-Form-Wizard-using-jQuery-Steps</a>.</p><h2>Motivation</h2><p>Sometimes it&#x27;s better to separate a large or complex form into different sections. It’s because your form looks much cleaner and less difficult. Despite that fact people want to be guided through complex processes without understanding those deeply.</p><h2>Situation</h2><p>There are many options to realize such a form wizard. You could use for example just static HTML files for each step one and link them together. But this, actually, could be really frustrating for you and the people visiting your site. Think of maintaining an existing wizard (e.g. adding a new step or changing links) then you have to touch in worst case all the existing steps that are involved. On the other hand your visitors get frustrated because of the many page requests and their accompanying latency time. However, all this isn’t probably new for you. Therefore, let’s step over!</p><h2>Solution</h2><p>Let me explain you how I usually solve this problem. I prefer using <strong>jQuery Steps</strong> a jQuery UI plugin because of its simplicity and feature-richness. And most important it’s free (open source). Just grab and use it!</p><p>But for now enough words - let’s get our hands dirty!</p><p>First of all, we will download <strong>jQuery Steps</strong> from <a href=\"http://www.jquery-steps.com\">here</a> and take the basic example markup from <a href=\"http://www.jquery-steps.com/GettingStarted#basic\">there</a> – done. Not really but it isn’t far away from being done.</p><pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Demo&lt;/title&gt;\n    &lt;meta charset=&quot;utf-8&quot; /&gt;\n    &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;jquery.steps.js&quot;&gt;&lt;/script&gt;\n    &lt;link href=&quot;jquery.steps.css&quot; rel=&quot;stylesheet&quot; /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script&gt;\n      $(&quot;#wizard&quot;).steps();\n    &lt;/script&gt;\n    &lt;div id=&quot;wizard&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>What else? We have to replace this <code>&lt;div id=&quot;wizard&quot;&gt;&lt;/div&gt;</code> part by our own form markup and override the bodyTag property on initialization.</p><pre><code class=\"language-html\">&lt;form id=&quot;form-3&quot; action=&quot;#&quot;&gt;\n  &lt;h1&gt;Account&lt;/h1&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;Account Information&lt;/legend&gt;\n\n    &lt;label for=&quot;userName&quot;&gt;User name *&lt;/label&gt;\n    &lt;input id=&quot;userName&quot; name=&quot;userName&quot; type=&quot;text&quot; class=&quot;required&quot; /&gt;\n    &lt;label for=&quot;password&quot;&gt;Password *&lt;/label&gt;\n    &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;text&quot; class=&quot;required&quot; /&gt;\n    &lt;label for=&quot;confirm&quot;&gt;Confirm Password *&lt;/label&gt;\n    &lt;input id=&quot;confirm&quot; name=&quot;confirm&quot; type=&quot;text&quot; class=&quot;required&quot; /&gt;\n    &lt;p&gt;(*) Mandatory&lt;/p&gt;\n  &lt;/fieldset&gt;\n\n  &lt;h1&gt;Profile&lt;/h1&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;Profile Information&lt;/legend&gt;\n\n    &lt;label for=&quot;name&quot;&gt;First name *&lt;/label&gt;\n    &lt;input id=&quot;name&quot; name=&quot;name&quot; type=&quot;text&quot; class=&quot;required&quot; /&gt;\n    &lt;label for=&quot;surname&quot;&gt;Last name *&lt;/label&gt;\n    &lt;input id=&quot;surname&quot; name=&quot;surname&quot; type=&quot;text&quot; class=&quot;required&quot; /&gt;\n    &lt;label for=&quot;email&quot;&gt;Email *&lt;/label&gt;\n    &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;text&quot; class=&quot;required email&quot; /&gt;\n    &lt;label for=&quot;address&quot;&gt;Address&lt;/label&gt;\n    &lt;input id=&quot;address&quot; name=&quot;address&quot; type=&quot;text&quot; /&gt;\n    &lt;label for=&quot;age&quot;\n      &gt;Age (The warning step will show up if age is less than 18) *&lt;/label\n    &gt;\n    &lt;input id=&quot;age&quot; name=&quot;age&quot; type=&quot;text&quot; class=&quot;required number&quot; /&gt;\n    &lt;p&gt;(*) Mandatory&lt;/p&gt;\n  &lt;/fieldset&gt;\n\n  &lt;h1&gt;Warning&lt;/h1&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;You are to young&lt;/legend&gt;\n\n    &lt;p&gt;Please go away ;-)&lt;/p&gt;\n  &lt;/fieldset&gt;\n\n  &lt;h1&gt;Finish&lt;/h1&gt;\n  &lt;fieldset&gt;\n    &lt;legend&gt;Terms and Conditions&lt;/legend&gt;\n\n    &lt;input\n      id=&quot;acceptTerms&quot;\n      name=&quot;acceptTerms&quot;\n      type=&quot;checkbox&quot;\n      class=&quot;required&quot;\n    /&gt;\n    &lt;label for=&quot;acceptTerms&quot;&gt;I agree with the Terms and Conditions.&lt;/label&gt;\n  &lt;/fieldset&gt;\n&lt;/form&gt;\n</code></pre><p>This is just a normal form which you should be familiar with. The small difference <a href=\"http://www.jquery-steps.com/Examples#advanced-form\">here</a> is that we use a h1 tag on top of each fieldset tag. <strong>jQuery Steps</strong> needs that to build the wizard navigation. I grabbed that from here and there you can also see how it works in action.</p><p>The following code shows how to override the bodyTag property in order to tell <strong>jQuery Steps</strong> to use the fieldset tag as body container instead of div.</p><pre><code class=\"language-javascript\">$(&quot;#wizard&quot;).steps({\n  bodyTag: &quot;fieldset&quot;,\n});\n</code></pre><p>Actually, we are done but to offer users a rich and intuitive experience we will add an additional jQuery plugin which all of you very probably already know; <strong>jQuery Validation</strong> (for more Information see <a href=\"http://jqueryvalidation.org/\">here</a>). It&#x27;s a plugin for doing form input validation. Furthermore, we will attach four event handler functions containing some extra magic. Finally, we will initialize <strong>jQuery Validation</strong>. Since both plugins are built on top of <strong>jQuery</strong>, we can make use of chaining (e.g. <code>$(&quot;#form&quot;).steps().validate()</code>). Okay, before we start adding more code take a brief look on the following table that explains the four events we will shortly add.</p><table><thead><tr><th>Event</th><th>Description</th></tr></thead><tbody><tr><td><code>onStepChanging</code></td><td>Fires before the step changes and can be used to prevent step changing by returning <code>false</code>. Very useful for form validation or checking preconditions.</td></tr><tr><td><code>onStepChanged</code></td><td>Fires after the step has change.</td></tr><tr><td><code>onFinishing</code></td><td>Fires before finishing and can be used to prevent completion by returning <code>false</code>. Very useful for form validation or checking preconditions.</td></tr><tr><td><code>onFinished</code></td><td>Fires after completion.</td></tr></tbody></table><p>These useful events will help us realizing pretty neat functionality. So the events ending on -ing will be invoked right after an user interaction but before any internal logic gets executed. Those events will be very helpful to prevent step changing and submission. The events ending with -ed will happen after everything is executed and let us execute custom logic (e.g. skipping a step and submitting a form via AJAX).</p><p>Internally, it&#x27;s implemented like this:</p><pre><code class=\"language-javascript\">if (wizard.triggerHandler(&quot;stepChanging&quot;, [state.currentIndex, index])) {\n  // Internal logic\n\n  wizard.triggerHandler(&quot;stepChanged&quot;, [index, oldIndex]);\n}\n</code></pre><p>With that in mind you know how it works. The first event function we are going to add to the settings is <code>onStepChanging</code>. This Implementation allows us to react before things are going to change.</p><pre><code class=\"language-javascript\">onStepChanging: function (event, currentIndex, newIndex)\n{\n    // Always allow going backward even if the current step contains invalid fields!\n    if (currentIndex &gt; newIndex)\n    {\n        return true;\n    }\n\n    // Forbid suppressing &quot;Warning&quot; step if the user is to young\n    if (newIndex === 3 &amp;&amp; Number($(&quot;#age&quot;).val()) &lt; 18)\n    {\n        return false;\n    }\n\n    var form = $(this);\n\n    // Clean up if user went backward before\n    if (currentIndex &lt; newIndex)\n    {\n        // To remove error styles\n        $(&quot;.body:eq(&quot; + newIndex + &quot;) label.error&quot;, form).remove();\n        $(&quot;.body:eq(&quot; + newIndex + &quot;) .error&quot;, form).removeClass(&quot;error&quot;);\n    }\n\n    // Disable validation on fields that are disabled or hidden.\n    form.validate().settings.ignore = &quot;:disabled,:hidden&quot;;\n\n    // Start validation; Prevent going forward if false\n    return form.valid();\n}\n</code></pre><p>The second event function contains some logic to skip the warning step we added before.</p><pre><code class=\"language-javascript\">onStepChanged: function (event, currentIndex, priorIndex)\n{\n    // Suppress (skip) &quot;Warning&quot; step if the user is old enough and wants to the previous step.\n    if (currentIndex === 2 &amp;&amp; priorIndex === 3)\n    {\n        $(this).steps(&quot;previous&quot;);\n        return;\n    }\n\n    // Suppress (skip) &quot;Warning&quot; step if the user is old enough.\n    if (currentIndex === 2 &amp;&amp; Number($(&quot;#age&quot;).val()) &gt;= 18)\n    {\n        $(this).steps(&quot;next&quot;);\n    }\n}\n</code></pre><p>The next two event functions allow us to handle submission and submission prevention.</p><pre><code class=\"language-javascript\">onFinishing: function (event, currentIndex)\n{\n    var form = $(this);\n\n    // Disable validation on fields that are disabled.\n    // At this point it&#x27;s recommended to do an overall check (mean ignoring only disabled fields)\n    form.validate().settings.ignore = &quot;:disabled&quot;;\n\n    // Start validation; Prevent form submission if false\n    return form.valid();\n}\n</code></pre><p>The latter event function is required for form submission.</p><pre><code class=\"language-javascript\">onFinished: function (event, currentIndex)\n{\n    var form = $(this);\n\n    // Submit form input\n    form.submit();\n}\n</code></pre><p>The final JavaScript code looks like this after we stick everything together.</p><pre><code class=\"language-javascript\">$(&quot;#form&quot;)\n  .steps({\n    bodyTag: &quot;fieldset&quot;,\n    onStepChanging: function (event, currentIndex, newIndex) {\n      // Always allow going backward even if the current step contains invalid fields!\n      if (currentIndex &gt; newIndex) {\n        return true;\n      }\n\n      // Forbid suppressing &quot;Warning&quot; step if the user is to young\n      if (newIndex === 3 &amp;&amp; Number($(&quot;#age&quot;).val()) &lt; 18) {\n        return false;\n      }\n\n      var form = $(this);\n\n      // Clean up if user went backward before\n      if (currentIndex &lt; newIndex) {\n        // To remove error styles\n        $(&quot;.body:eq(&quot; + newIndex + &quot;) label.error&quot;, form).remove();\n        $(&quot;.body:eq(&quot; + newIndex + &quot;) .error&quot;, form).removeClass(&quot;error&quot;);\n      }\n\n      // Disable validation on fields that are disabled or hidden.\n      form.validate().settings.ignore = &quot;:disabled,:hidden&quot;;\n\n      // Start validation; Prevent going forward if false\n      return form.valid();\n    },\n    onStepChanged: function (event, currentIndex, priorIndex) {\n      // Suppress (skip) &quot;Warning&quot; step if the user is old enough and wants to the previous step.\n      if (currentIndex === 2 &amp;&amp; priorIndex === 3) {\n        $(this).steps(&quot;previous&quot;);\n        return;\n      }\n\n      // Suppress (skip) &quot;Warning&quot; step if the user is old enough.\n      if (currentIndex === 2 &amp;&amp; Number($(&quot;#age&quot;).val()) &gt;= 18) {\n        $(this).steps(&quot;next&quot;);\n      }\n    },\n    onFinishing: function (event, currentIndex) {\n      var form = $(this);\n\n      // Disable validation on fields that are disabled.\n      // At this point it&#x27;s recommended to do an overall check (mean ignoring only disabled fields)\n      form.validate().settings.ignore = &quot;:disabled&quot;;\n\n      // Start validation; Prevent form submission if false\n      return form.valid();\n    },\n    onFinished: function (event, currentIndex) {\n      var form = $(this);\n\n      // Submit form input\n      form.submit();\n    },\n  })\n  .validate({\n    errorPlacement: function (error, element) {\n      element.before(error);\n    },\n    rules: {\n      confirm: {\n        equalTo: &quot;#password&quot;,\n      },\n    },\n  });\n</code></pre><p>Any questions or comments are very welcome!</p>",
            "url": "https://chillicream.com/blog/2013/09/12/jquery-steps-form-wizard",
            "title": "How to create a Form Wizard using jQuery Steps",
            "summary": "This blog article was previously published on  http://www.rafaelstaib.com/post/How-to-create-a-Form-Wizard-using-jQuery-Steps . Motivation…",
            "date_modified": "2013-09-12T00:00:00.000Z",
            "date_published": "2013-09-12T00:00:00.000Z",
            "author": {
                "name": "Rafael Staib",
                "url": "https://github.com/rstaib"
            }
        }
    ]
}