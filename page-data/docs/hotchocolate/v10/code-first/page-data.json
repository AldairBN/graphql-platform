{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/code-first","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/code-first/"},"frontmatter":{"title":"Code-First"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Code-First\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The code-first schema approach lets us build GraphQL schemas with .NET types and it gives us all the goodness of strong types and the confidence of using the C# compiler to validate our code. There is no need to switch to the GraphQL syntax in order to specify our schema, we can do everything in our favorite .NET language.\"), mdx(\"p\", null, \"Let us get started and have a look at the various approaches that we can use to build a schema. It is important to know that we can mix the various approaches with Hot Chocolate and use the best solution for a specific problem.\"), mdx(\"h1\", null, \"Pure Code-First\"), mdx(\"p\", null, \"We call the first approach pure code-first since we do not bother about GraphQL schema types, we will just write clean C# code that automatically translates to GraphQL types.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"In order to use this approach in the most effective way opt into C# nullable reference types.\")), mdx(\"p\", null, \"In GraphQL everything starts with one of the three root types (Query, Mutation or Subscriptions). Root types represent the operations that we can do on our schema.\"), mdx(\"p\", null, \"So, if we wanted to create the query root type we would simply write a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" class.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string Hello() => \\\"world\\\";\\n}\\n\")), mdx(\"p\", null, \"Now let us create a new schema with that root type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var schema = SchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"We now have registered an object type with our new schema that is based on our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \" class. The schema would look like the following (if nullable reference type are turned on):\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  hello: String!\\n}\\n\")), mdx(\"p\", null, \"We didn't even have to write resolvers due to the fact that the schema inferred those from the hello method. Our hello method is actually our resolver.\"), mdx(\"p\", null, \"This is just a simple class, with no real challenge to it. The schema builder is able to automatically infer interface usage, arguments, really everything just from our types.\"), mdx(\"p\", null, \"But what if we wanted to apply middleware to our types like paging, filtering or sorting?\"), mdx(\"p\", null, \"For this we have something called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"descriptor attributes\"), \" so applying filtering to a field would look like the following example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"This attribute would add all the necessary filter input types and apply the filter middleware to that field.\"), mdx(\"p\", null, \"If you want to read more about how to use or build these attributes head over \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/schema/descriptor-attributes\"\n  }), \"here\"), \".\"), mdx(\"h1\", null, \"Code-First\"), mdx(\"p\", null, \"The second and original approach to code-first is by using our schema types.\"), mdx(\"p\", null, \"Schema types allow us to keep the GraphQL type configuration separate from our .NET types. This can be the right approach when we do not want any Hot Chocolate attributes on our business objects.\"), mdx(\"p\", null, \"As I said earlier we can mix these approaches which can enable us to achieve awesome complex schemas with minimal boilerplate code.\"), mdx(\"p\", null, \"Schema types can be created either by using the schema builder and add the configuration where we add the type ...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var schema = SchemaBuilder.New()\\n    .AddQueryType<Query>(d => d\\n        .Field(f => f.Hello())\\n        .Type<NonNullType<StringType>>())\\n    .Create();\\n\")), mdx(\"p\", null, \".. or, since these fluent chains could get very long and unreadable we could also opt to declare a new class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryType\"), \" that extends \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType<Query>\"), \" and add it to our schema like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(f => f.Hello()).Type<NonNullType<StringType>>();\\n    }\\n}\\n\\nvar schema = SchemaBuilder.New()\\n    .AddQueryType<QueryType>()\\n    .Create();\\n\")), mdx(\"p\", null, \"Furthermore, we can add fields that are not based on our .NET type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Query\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(f => f.Hello()).Type<NonNullType<StringType>>();\\n        descriptor.Field(\\\"foo\\\").Type<StringType>().Resolver(() => \\\"bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"Our new resulting schema would now look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  hello: String!\\n  foo: String\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" field would use the specified delegate to resolve the field value. The fluent API offers us the same feature set as the GraphQL schema syntax.\"), mdx(\"p\", null, \"Next, let us have a look at resolver arguments. GraphQL fields let us define arguments, so they are more like methods in C# than properties.\"), mdx(\"p\", null, \"If we add a parameter to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Hello\"), \" method, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" will translate that into a GraphQL field argument.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string Hello(string name) => $\\\"Greetings {name}\\\";\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  hello(name: String!): String!\\n}\\n\")), mdx(\"p\", null, \"In order to get access to the resolver context in our resolver, we can just add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IResolverContext\"), \" as a method parameter and the query engine will automatically inject the context:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string Hello(IResolverContext context, string name) =>\\n        $\\\"Greetings {name} {context.Service<FooService>().GetBar()}\\\";\\n}\\n\")), mdx(\"p\", null, \"This was just a quick introduction - There is a lot more that we can do with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pure code-first\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"code-first\"), \". In order to learn more, head over to the following documentation articles:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you want to read more about the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" head over \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/schema\"\n  }), \"here\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you are interested about resolvers in more detail \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/schema/resolvers\"\n  }), \"this\"), \" might be the right place for you.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If you want to know how to split up types then \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/schema/splitting-types\"\n  }), \"this\"), \" might be what you are looking for.\"))), mdx(\"p\", null, \"You are all fired up and want to get started with a little tutorial walking you through an end-to-end example with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MongoDB\"), \" as your database? \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/tutorials\"\n  }), \"Follow me\"), \"!\"), mdx(\"p\", null, \"OK, OK, you already have an idea on what to do and you are just looking for a way to setup this whole thing with ASP.NET Core? \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/server\"\n  }), \"This\"), \" is where you find more on that.\"), mdx(\"p\", null, \"If you want to set Hot Chocolate up with AWS Lambda or Azure Functions head over to our slack channel, we do not yet have documentation on that but there are example projects showing how to do that. We are constantly adding to our documentation and will include documentation on that soon.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#pure-code-first","title":"Pure Code-First"},{"url":"#code-first","title":"Code-First"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"state-management","title":"State Management","items":null},{"path":"persisted-queries","title":"Persisted Queries","items":null},{"path":"configuration","title":"Configuration","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/code-first.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}