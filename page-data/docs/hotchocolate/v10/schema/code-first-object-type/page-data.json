{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/code-first-object-type","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/code-first-object-type/"},"frontmatter":{"title":"Object Type"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Object Type\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The object type is the most prominent type in GraphQL. There are currently two ways to describe an object type with the code-first approach.\"), mdx(\"h1\", null, \"ObjectType<T\", \">\"), mdx(\"p\", null, \"The first approach is by using the generic object type class which lets you specify an entity type that shall represent your schema type in .NET. The object type descriptor will then try to automatically infer the GraphQL schema type from your .NET type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n  public string GetHello() => \\\"World\\\";\\n}\\n\\npublic class QueryType\\n  : ObjectType<Query>\\n{\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  hello: String\\n}\\n\")), mdx(\"p\", null, \"In order to specify you intend more explicitly you can opt to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IObjectTypeDescriptor<Query>\"), \" that is accessible by overriding the configure method of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryType\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n  public string GetHello() => \\\"World\\\";\\n}\\n\\npublic class QueryType\\n  : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> desc)\\n    {\\n        desc.Field(t => t.GetHello()).Type<NonNullType<StringType>>();\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  hello: String!\\n}\\n\")), mdx(\"h1\", null, \"Object Type Descriptors\"), mdx(\"p\", null, \"The following table shows the object type descriptor options:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Name\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Name(string name)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Defines the name of the object type.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Description(string description)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Defines the description of the object type that will be accessible through the introspection.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Interface\\\\<T\\\\>()\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Specifies an interface type that is implemented by this object type.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"IsOfType(IsOfType isOfType)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Defines a function that specifies if a specific resolver type is of the specified object type.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"BindFields(BindingBehavior bindingBehavior)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Specifies the field binding behaviour.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Field\\\\<TValue\\\\>(Expression\\\\<Func\\\\<T, TValue\\\\>\\\\> propertyOrMethod)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Specifies field configuration of a method or property declared in T.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Field(string name)\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Specifies a field that does not exist in T.\")))), mdx(\"h2\", null, \"Name\"), mdx(\"p\", null, \"The object type descriptor will by default resolve the name of the schema type from the provided type argument. If the type is annotated with the GraphQLNameAttribute than the name attribute will take precedence over the type name. The explicitly specified name will take precedence over both.\"), mdx(\"p\", null, \"Example name from type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Foo { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Bar {\\n  foo: String\\n}\\n\")), mdx(\"p\", null, \"Example name from attribute:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[GraphQLName(\\\"Foo\\\")]\\npublic class Bar\\n{\\n  public string Foo { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Foo {\\n  foo: String\\n}\\n\")), mdx(\"p\", null, \"Example explicit name:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[GraphQLName(\\\"Foo\\\")]\\npublic class Bar\\n{\\n  public string Foo { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.Name(\\\"Foo123\\\");\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Foo123 {\\n  foo: String\\n}\\n\")), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The description of a type will provide an additional text that describes a type to the schema introspection. This is useful with tools like Banana Cake Pop, Playground or GraphiQL. GraphQL descriptions are defined using the Markdown syntax (as specified by \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://commonmark.org\"\n  }), \"CommonMark\"), \").\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Foo { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.Description(\\\"Lorem ipsum dolor sit amet, consectetur adipiscing elit...\\\");\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nLorem ipsum dolor sit amet, consectetur adipiscing elit...\\n\\\"\\\"\\\"\\ntype Bar {\\n  foo: String\\n}\\n\")), mdx(\"h2\", null, \"IsOfType\"), mdx(\"p\", null, \"The object type descriptor will by default use an instance of approach to figure out if a resolver result is of a certain object type. In some cases when you either have no explicit type binding or you use a .NET net type in multiple schema types it is necessary to specify a IsOfType delegate that determines the type of a resolver result.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Foo { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.IsOfType((context, result) => result is string s && s == \\\"bar\\\");\\n    }\\n}\\n\")), mdx(\"h2\", null, \"BindFields\"), mdx(\"p\", null, \"The object type descriptor will by default scan the provided entity type for additional fields. In some cases you might want to specify all the fields explicitly in order to have a more predictable schema. You might not want that a property or method that you add to your types automatically shows up in your schema. In those cases you can change the field binding behaviour to explicit.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Foo1 { get; set; }\\n  public string Foo2 { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.BindFields(BindingBehaviour.Explicit);\\n        desc.Field(t => t.Foo1);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Bar {\\n  foo1: String\\n}\\n\")), mdx(\"h2\", null, \"Field\"), mdx(\"p\", null, \"There are two ways to define fields. First you can specify a field configuration by pointing to a property or method that is declared in your .NET type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Xyz { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.Field(t => t.Xyz).Name(\\\"foo\\\");\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Bar {\\n  foo: String\\n}\\n\")), mdx(\"p\", null, \"Second, you can define fields that do not have any representation in your .NET type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar\\n{\\n  public string Xyz { get; set; }\\n}\\n\\npublic class BarType\\n  : ObjectType<Bar>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Bar> desc)\\n    {\\n        desc.Field(\\\"foo\\\").Resolver(() => \\\"hello world\\\");\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Bar {\\n  xyz: String\\n  foo: String\\n}\\n\")), mdx(\"h1\", null, \"ObjectType\"), mdx(\"p\", null, \"The second approach to describe object types is with the non-generic object type. The non-generic type does not necessarily have a fixed .NET type binding. This means that you have more flexibility in defining your schema type and how the data flows through the query engine.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class BarType\\n  : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor desc)\\n    {\\n        desc.Field(\\\"foo\\\").Resolver(() => \\\"hello world\\\");\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Bar {\\n  foo: String\\n}\\n\")), mdx(\"p\", null, \"Compared to the generic descriptor interface you are loosing the generic field descriptor that is able to bind a field to a .NET property or method.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#objecttypet","title":"ObjectType<T>"},{"url":"#object-type-descriptors","title":"Object Type Descriptors","items":[{"url":"#name","title":"Name"},{"url":"#description","title":"Description"},{"url":"#isoftype","title":"IsOfType"},{"url":"#bindfields","title":"BindFields"},{"url":"#field","title":"Field"}]},{"url":"#objecttype","title":"ObjectType"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/enQtNTA4NjA0ODYwOTQ0LTViMzA2MTM4OWYwYjIxYzViYmM0YmZhYjdiNzBjOTg2ZmU1YmMwNDZiYjUyZWZlMzNiMTk1OWUxNWZhMzQwY2Q"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/code-first-object-type.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}