{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/object-type","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/docs/hotchocolate/v10/schema/object-type","lastUpdated":"2021-06-25","lastAuthorName":"Tobias Tengler"},"frontmatter":{"title":"Object Type"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Object Type\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The object type is the most prominent output type in GraphQL and represents a kind of object we can fetch from our schema. The GraphQL schema representation of an object looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sdl\"\n  }, \"type Starship {\\n  id: ID!\\n  name: String!\\n  length(unit: LengthUnit = METER): Float\\n}\\n\")), mdx(\"p\", null, \"An object in GraphQL consists of a collection of fields. Object fields in GraphQL can have arguments, so we could compare it to methods in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"C#\"), \". Each field has a distinct type. All field types have to be output types (scalars, enums, objects, unions or interfaces). The arguments of a field on the other hand have to be input types scalars, enums and input objects).\"), mdx(\"p\", null, \"With Hot Chocolate we can define an object by using the GraphQL SDL syntax or by using C#. Each field of an object will get a resolver assigned that knows how to fetch the data for that field.\"), mdx(\"p\", null, \"A single GraphQL object might be the composition of data that comes from several data sources.\"), mdx(\"p\", null, \"If we take the following object for instance:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sdl\"\n  }, \"type Query {\\n  sayHello: String!\\n}\\n\")), mdx(\"p\", null, \"We could define this like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"SchemaBuilder.New()\\n  .AddDocumentFromString(@\\\"\\n      type Query {\\n        sayHello: String!\\n      }\\\")\\n  .AddResolver(context => \\\"Hello!\\\")\\n  .Create();\\n\")), mdx(\"p\", null, \"With C# we could define it like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"GraphQL has a concept of nun-null types. Basically any type can be a non-nullable type, in the SDL we decorate non-nullable types with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bang\"), \" token \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"!\"), \". In order to describe this in C# we can use attributes, use C# 8 and nullable reference types or use the underlying schema types to describe our GraphQL type explicitly.\"), mdx(\"p\", null, \"This is how it would look like with our attributes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Query\\n{\\n    [GraphQLNonNullType]\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"With C# 8.0 we can enable nullable reference type either in our project:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-xml\"\n  }, \"<PropertyGroup>\\n  <Nullable>enable</Nullable>\\n</PropertyGroup>\\n\")), mdx(\"p\", null, \"Or we could use pre-processor directives to opt-in on a by file base:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"#nullable enable\\n\\npublic class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<Query>()\\n  .Create();\\n\")), mdx(\"p\", null, \"With schema types the same thing would look like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Query\\n{\\n    public string SayHello() => \\\"Hello!\\\";\\n}\\n\\npublic class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.SayHello()).Type<NonNullType<StringType>>();\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  .AddQueryType<QueryType>()\\n  .Create();\\n\")), mdx(\"h1\", {\n    \"id\": \"resolvers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#resolvers\",\n    \"aria-label\": \"resolvers permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"viewBox\": \"0 0 512 512\",\n    \"width\": \"16\",\n    \"height\": \"16\"\n  }, \"\\n                        \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"d\": \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"\n  }), \"\\n                      \")), \"Resolvers\"), mdx(\"p\", null, \"Schema types will also allow us to add fields that are not on our current model.\\nLet\", \"`\", \"s say we have the following C# model:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\")), mdx(\"p\", null, \"And we want to expose the following object to our schema users:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sdl\"\n  }, \"type Person {\\n  id: Int!\\n  name: String!\\n  friends: [Person]\\n}\\n\")), mdx(\"p\", null, \"Then we could do something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class PersonType\\n    : ObjectType<Person>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();\\n        descriptor.Field(\\\"friends\\\")\\n            .Type<ListType<NonNullType<PersonType>>>()\\n            .Resolver(context =>\\n                context.Service<IPersonRepository>().GetFriends(\\n                    context.Parent<Person>().Id));\\n    }\\n}\\n\")), mdx(\"p\", null, \"Let\", \"`\", \"s have a look at the above example, first we have our name field there, since we need to declare it non-nullable.\\nBut we do not have the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"id\"), \" field there. Hot Chocolate will always try to infer the usage of the provided type if it is not overridden by the user. We always can opt out of this behavior and tell Hot Chocolate that we do want to declare everything explicitly.\"), mdx(\"p\", null, \"In the case of value types Hot Chocolate can infer the non-nullability correctly in any C# version and we do not have to specify anything extra.\"), mdx(\"p\", null, \"The second thing that is important in this example is that we can introduce fields that are not on our model and that might even come from a completely different data source. In these cases, we have to provide explicit resolvers since we cannot infer the resolver from the C# type.\"), mdx(\"p\", null, \"We also can use schema types if we have no .NET backing type at all. In these cases, we have to write explicit resolvers for each of the fields:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class QueryType\\n    : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Field(\\\"sayHello\\\")\\n            .Type<NonNullType<StringType>>()\\n            .Resolver(\\\"Hello!\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"We can also turn that around and write our resolver logic in our C# objects since we support method argument injection. We could also create our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Person\"), \" type in C# like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n\\n    public IEnumerable<Person> GetFriends([Service]IPersonRepository repository) =>\\n        repository.GetFriends(Id);\\n}\\n\")), mdx(\"p\", null, \"Since in many cases we do not want to put resolver code in our business objects we can also split our type and still move the resolver code to a C# class:\"), mdx(\"p\", null, \"Pure Code-First:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\\n[ExtendObjectType(Name = \\\"Person\\\")]\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends(Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\")), mdx(\"p\", null, \"Code-First:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class Person\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n}\\n\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends([Parent]Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\\npublic class PersonType\\n    : ObjectType<Person>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();\\n        descriptor.Field<PersonResolvers>(t => t.GetFriends(default, default))\\n            .Type<ListType<NonNullType<PersonType>>>();\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"More about resolvers can be read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/docs/hotchocolate/v10/schema/resolvers\"\n  }, \"here\"), \".\")), mdx(\"h1\", {\n    \"id\": \"extension\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"#extension\",\n    \"aria-label\": \"extension permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"xmlns\": \"http://www.w3.org/2000/svg\",\n    \"viewBox\": \"0 0 512 512\",\n    \"width\": \"16\",\n    \"height\": \"16\"\n  }, \"\\n                        \", mdx(\"path\", {\n    parentName: \"svg\",\n    \"d\": \"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"\n  }), \"\\n                      \")), \"Extension\"), mdx(\"p\", null, \"The GraphQL SDL supports extending object types, this means that we can add fields to an existing object type without changing the code of our initial type definition.\"), mdx(\"p\", null, \"Extending types is useful for schema stitching but also when we want to add just something to an exist type or if we just want to split large type definitions. The latter is often the case with the query type definition.\"), mdx(\"p\", null, \"Hot Chocolate supports extending types with SDL-first, pure code-first and code-first. Let\", \"`\", \"s have a look at how we can extend our person object:\"), mdx(\"p\", null, \"SDL-First:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sdl\"\n  }, \"extend type Person {\\n  address: String!\\n}\\n\")), mdx(\"p\", null, \"Pure Code-First:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"[ExtendObjectType(Name = \\\"Person\\\")]\\npublic class PersonResolvers\\n{\\n    public IEnumerable<Person> GetFriends([Parent]Person person, [Service]IPersonRepository repository) =>\\n        repository.GetFriends(person.Id);\\n}\\n\\nSchemaBuilder.New()\\n  ...\\n  .AddType<PersonType>()\\n  .AddType<PersonResolvers>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Code-First\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-csharp\"\n  }, \"public class PersonTypeExtension\\n    : ObjectTypeExtension\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Person\\\");\\n        descriptor.Field(\\\"address\\\")\\n            .Type<NonNullType<StringType>>()\\n            .Resolver(/\\\"Resolver Logic\\\"/);\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  ..\\n  .AddType<PersonType>()\\n  .AddType<PersonTypeExtension>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Type extensions basically work like usual types and are also added like usual types.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":1,"value":"Resolvers"},{"depth":1,"value":"Extension"}]}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Overview"},{"path":"queries","title":"Queries"},{"path":"mutations","title":"Mutations"},{"path":"subscriptions","title":"Subscriptions"},{"path":"object-types","title":"Object Types"},{"path":"scalars","title":"Scalars"},{"path":"arguments","title":"Arguments"},{"path":"input-object-types","title":"Input Object Types"},{"path":"lists","title":"Lists"},{"path":"non-null","title":"Non-Null"},{"path":"enums","title":"Enums"},{"path":"interfaces","title":"Interfaces"},{"path":"unions","title":"Unions"},{"path":"extending-types","title":"Extending Types"},{"path":"directives","title":"Directives"},{"path":"documentation","title":"Documentation"},{"path":"versioning","title":"Versioning"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.NET"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".NET CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/object-type.md"}},"staticQueryHashes":["2890364758","3416206942","4218812017"]}