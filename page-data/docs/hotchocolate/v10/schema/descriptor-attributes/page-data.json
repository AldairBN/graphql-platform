{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/descriptor-attributes","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/descriptor-attributes/"},"frontmatter":{"title":"Descriptor Attributes"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Descriptor Attributes\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Hot Chocolate allows to define a schema in various ways. When defining schemas with pure .NET types and custom attributes we need a way to access advanced features like custom field middleware that we have at our disposal with schema types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.Strings).UsePaging<StringType>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"This is where descriptor attributes come in. Descriptor attributes allow us to package descriptor configurations into an attribute that can be used to decorate our .NET types. Descriptor attributes act like an interceptor into the configuration of the inferred schema type.\"), mdx(\"p\", null, \"#\\xA0Built-In Attributes\"), mdx(\"p\", null, \"We have prepared the following set of built-in descriptor attributes.\"), mdx(\"h2\", null, \"UsePagingAttribute\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePagingAttribute\"), \" allows us to use the paging middleware by annotating it to a property or method.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UsePaging]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"h2\", null, \"UseFilteringAttribute\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFilteringAttribute\"), \" allows us to apply the filtering middleware to a property or method.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": Be sure to install the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Filters\"), \" NuGet package.\")), mdx(\"h2\", null, \"UseSortingAttribute\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSortingAttribute\"), \" allows us to apply the sorting middleware to a property or method.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseSorting]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": Be sure to install the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Sorting\"), \" NuGet package.\")), mdx(\"h2\", null, \"AuthorizeAttribute\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AuthorizeAttribute\"), \" allows to apply the authorize directives to a class, struct, interface, property or method. The attribute will only be applied if the inferred type is an object type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [Authorize(Policy = \\\"MyPolicy\\\")]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Attribute Chaining\"), mdx(\"p\", null, \"Attributes can by default be chained, meaning that the attributes are applied in order from the top one to the bottom one.\"), mdx(\"p\", null, \"The following code ...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UsePaging]\\n    [UseFiltering]\\n    [UseSorting]\\n    public IQueryable<Foo> GetFoos()\\n    {\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"... would translate to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.Foos)\\n            .UsePaging<ObjectType<Foo>>()\\n            .UseFiltering()\\n            .UseSorting();\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Custom Descriptor Attributes\"), mdx(\"p\", null, \"It is super simple to create custom descriptor attributes and package complex functionality in simple to use attributes.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class SomeMiddlewareAttribute\\n    : ObjectFieldDescriptorAttribute\\n{\\n    public override void OnConfigure(\\n        IDescriptorContext context,\\n        IObjectFieldDescriptor descriptor,\\n        MemberInfo member)\\n    {\\n        descriptor.Use(next => context => ...);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnConfigure\"), \" method you can do what you actually would do in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method of a type.\"), mdx(\"p\", null, \"But you also get some context information about where the configuration was applied to, like you get the member to which the attribute was applied to and you get the descriptor context.\"), mdx(\"p\", null, \"We have one descriptor base class for each first-class descriptor type.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"EnumTypeDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"EnumValueDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"InputObjectTypeDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"InputFieldDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"InterfaceTypeDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"InterfaceFieldDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ObjectTypeDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ObjectFieldDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"UnionTypeDescriptorAttribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ArgumentDescriptorAttribute\")), mdx(\"p\", null, \"All of these attribute base classes have already the allowed attribute targets applied. That means that we pre-configured the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectFieldDescriptorAttribute\"), \" for instance to be only valid on methods and properties.\"), mdx(\"p\", null, \"If you want to build more complex attributes that can be applied to multiple targets like an interface type and an object type at the same time then you can use our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DescriptorAttribute\"), \" base class. This base class is not pre-configured and lets you probe for configuration types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[AttributeUsage(\\n    AttributeTargets.Property | AttributeTargets.Method,\\n    Inherited = true,\\n    AllowMultiple = true)]\\npublic sealed class MyCustomAttribute : DescriptorAttribute\\n{\\n    protected override void TryConfigure(\\n        IDescriptorContext context,\\n        IDescriptor descriptor,\\n        ICustomAttributeProvider element)\\n    {\\n        if(element is MemberInfo member)\\n        {\\n            switch(descriptor)\\n            {\\n                case IInterfaceFieldDescriptor interfaceField:\\n                    // do something ...\\n                    break;\\n\\n                case IObjectFieldDescriptor interfaceField:\\n                    // do something ...\\n                    break;\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"It is simple to use these attributes. Just annotating a type or a property with an attribute will add the packaged functionality. The types can be used in conjunction with schema types or without.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#usepagingattribute","title":"UsePagingAttribute"},{"url":"#usefilteringattribute","title":"UseFilteringAttribute"},{"url":"#usesortingattribute","title":"UseSortingAttribute"},{"url":"#authorizeattribute","title":"AuthorizeAttribute"}]},{"url":"#attribute-chaining","title":"Attribute Chaining"},{"url":"#custom-descriptor-attributes","title":"Custom Descriptor Attributes"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"state-management","title":"State Management","items":null},{"path":"persisted-queries","title":"Persisted Queries","items":null},{"path":"configuration","title":"Configuration","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/descriptor-attributes.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}