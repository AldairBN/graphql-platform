{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/schema/custom-scalar-types","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/schema/custom-scalar-types/"},"frontmatter":{"title":"Scalar Type Support"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Scalar Type Support\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Scalar types in GraphQL represent the leaf types of the graph like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Int\"), \".\"), mdx(\"p\", null, \"Scalar values represent the concrete data that is exposed.\"), mdx(\"h1\", null, \"Core Scalar Types\"), mdx(\"p\", null, \"Hot Chocolate comes with the following core scalar types that are defined by the GraphQL specification:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Int\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Signed 32-bit numeric non-fractional value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Float\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Double-precision fractional values as specified by IEEE 754\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"String\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"UTF-8 character sequences\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Boolean\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Boolean type representing true or false\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ID\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Unique identifier\")))), mdx(\"h1\", null, \"Extended Scalar Types\"), mdx(\"p\", null, \"Apart from the core scalars we have also added support for an extended set of scalar types:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Byte\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }))), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Short\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Signed 16-bit numeric non-fractional value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Long\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Signed 64-bit numeric non-fractional value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Decimal\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \".NET Floating Point Type\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Url\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Url\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"DateTime\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"ISO-8601 date time\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Date\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"ISO-8601 date\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Uuid\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GUID\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Any\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"This type can be anything, string, int, list or object etc.\")))), mdx(\"h1\", null, \"Using Scalars\"), mdx(\"p\", null, \"We will automatically detect which of our scalars are being used and only integrate the ones needed.\"), mdx(\"p\", null, \"This keeps the schema definition small, simple and clean.\"), mdx(\"p\", null, \"For our built-in types we also have added automatic .NET type inference. This means that we will automatically translate for instance a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.String\"), \" to a GraphQL \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringType\"), \". We can override these default mappings by explicitly specifying type bindings with the schema builder.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    .BindClrType<string, MyCustomStringType>()\\n    ...\\n    .Create();\\n\")), mdx(\"p\", null, \"Furthermore, we can also bind scalars to arrays or type structures:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    .BindClrType<byte[], ByteArrayType>()\\n    ...\\n    .Create();\\n\")), mdx(\"p\", null, \"Theses explicit bindings will overwrite the internal default bindings.\"), mdx(\"p\", null, \"Specifying such a bindings explicitly can also be important when we have two types that bind to the same .NET Type like with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTimeType\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateType\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    .BindClrType<DateTime, DateTimeType>()\\n    ...\\n    .Create();\\n\")), mdx(\"p\", null, \"This will ensure that the type inference works predictable and will by default infer \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTimeType\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" for instance.\"), mdx(\"p\", null, \"As I said before in most cases we do not need to do anything since Hot Chocolate has default bindings.\"), mdx(\"p\", null, \"#\\xA0Any Type\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" scalar is a special type that can be compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" in c#. Any allows us to specify any literal or return any output type.\"), mdx(\"p\", null, \"Consider the following type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  foo(bar: Any): String\\n}\\n\")), mdx(\"p\", null, \"Since our field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" specifies an argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" all of the following queries would be valid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a: foo(bar: 1)\\n  b: foo(bar: [1, 2, 3, 4, 5])\\n  a: foo(bar: \\\"abcdef\\\")\\n  a: foo(bar: true)\\n  a: foo(bar: { a: \\\"foo\\\", b: { c: 1 } })\\n  a: foo(bar: [{ a: \\\"foo\\\", b: { c: 1 } }, { a: \\\"foo\\\", b: { c: 1 } }])\\n}\\n\")), mdx(\"p\", null, \"The same goes for the output side. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" can return a structure of data although it is a scalar type.\"), mdx(\"p\", null, \"If we want to access the data we can either fetch data as object or we can ask the context to provide it as a specific object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"Foo foo = context.Argument<Foo>(\\\"bar\\\");\\n\")), mdx(\"p\", null, \"We can also ask the context which kind the current argument is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"ValueKind kind = context.ArgumentKind(\\\"bar\\\");\\n\")), mdx(\"p\", null, \"The value kind will tell us by which kind of literal the argument is represented.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"An integer literal can still contain a long value and a float literal could be a decimal but it also could just be a float.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public enum ValueKind\\n{\\n    String,\\n    Integer,\\n    Float,\\n    Boolean,\\n    Enum,\\n    Object,\\n    Null\\n}\\n\")), mdx(\"p\", null, \"If we want to access an object in a dynamic way without serializing it to a strongly typed model we can get it as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyDictionary<string, object>\"), \" or as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectValueNode\"), \".\"), mdx(\"p\", null, \"Lists can be accessed in a generic way by getting them as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<object>\"), \" or as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ListValueNode\"), \".\"), mdx(\"h1\", null, \"Custom Scalars\"), mdx(\"p\", null, \"In order to implement a new scalar type extend the type: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScalarType\"), \".\"), mdx(\"p\", null, \"The following example shows you how a Custom String type could be implemented.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public sealed class CustomStringType\\n    : ScalarType\\n{\\n    public CustomStringType()\\n        : base(\\\"CustomString\\\")\\n    {\\n    }\\n\\n    // define which .NET type represents your type\\n    public override Type ClrType { get; } = typeof(string);\\n\\n    // define which literals this type can be parsed from.\\n    public override bool IsInstanceOfType(IValueNode literal)\\n    {\\n        if (literal == null)\\n        {\\n            throw new ArgumentNullException(nameof(literal));\\n        }\\n\\n        return literal is StringValueNode\\n            || literal is NullValueNode;\\n    }\\n\\n    // define how a literal is parsed to the native .NET type.\\n    public override object ParseLiteral(IValueNode literal)\\n    {\\n        if (literal == null)\\n        {\\n            throw new ArgumentNullException(nameof(literal));\\n        }\\n\\n        if (literal is StringValueNode stringLiteral)\\n        {\\n            return stringLiteral.Value;\\n        }\\n\\n        if (literal is NullValueNode)\\n        {\\n            return null;\\n        }\\n\\n        throw new ArgumentException(\\n            \\\"The string type can only parse string literals.\\\",\\n            nameof(literal));\\n    }\\n\\n    // define how a native type is parsed into a literal,\\n    public override IValueNode ParseValue(object value)\\n    {\\n        if (value == null)\\n        {\\n            return new NullValueNode(null);\\n        }\\n\\n        if (value is string s)\\n        {\\n            return new StringValueNode(null, s, false);\\n        }\\n\\n        if (value is char c)\\n        {\\n            return new StringValueNode(null, c.ToString(), false);\\n        }\\n\\n        throw new ArgumentException(\\n            \\\"The specified value has to be a string or char in order \\\" +\\n            \\\"to be parsed by the string type.\\\");\\n    }\\n\\n    // define the result serialization. A valid output must be of the following .NET types:\\n    // System.String, System.Char, System.Int16, System.Int32, System.Int64,\\n    // System.Float, System.Double, System.Decimal and System.Boolean\\n    public override object Serialize(object value)\\n    {\\n        if (value == null)\\n        {\\n            return null;\\n        }\\n\\n        if (value is string s)\\n        {\\n            return s;\\n        }\\n\\n        if(value is char c)\\n        {\\n            return c;\\n        }\\n\\n        throw new ArgumentException(\\n            \\\"The specified value cannot be serialized by the StringType.\\\");\\n    }\\n\\n    public override bool TryDeserialize(object serialized, out object value)\\n    {\\n        if (serialized is null)\\n        {\\n            value = null;\\n            return true;\\n        }\\n\\n        if (serialized is string s)\\n        {\\n            value = s;\\n            return true;\\n        }\\n\\n        value = null;\\n        return false;\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#core-scalar-types","title":"Core Scalar Types"},{"url":"#extended-scalar-types","title":"Extended Scalar Types"},{"url":"#using-scalars","title":"Using Scalars"},{"url":"#custom-scalars","title":"Custom Scalars"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/schema/custom-scalar-types.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}