{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/data-fetching/filters","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/data-fetching/filters/"},"frontmatter":{"title":"Filter and Sorting Support"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Filter and Sorting Support\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What are filters?\")), mdx(\"p\", null, \"With the Hot Chocolate filters you are able to expose complex filter object through your GraphQL API that translate to native database queries.\"), mdx(\"p\", null, \"The default filter implementation translates filters to expression trees that are applied on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \".\"), mdx(\"h1\", null, \"Using Filters\"), mdx(\"p\", null, \"Filters by default work on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" but you can also easily customize them to use other interfaces.\"), mdx(\"p\", null, \"Hot Chocolate by default will inspect your .NET model and infer from that the possible filter operations.\"), mdx(\"p\", null, \"The following type would yield the following filter operations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Foo\\n{\\n    public string Bar { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input FooFilter {\\n  bar: String\\n  bar_contains: String\\n  bar_ends_with: String\\n  bar_in: [String]\\n  bar_not: String\\n  bar_not_contains: String\\n  bar_not_ends_with: String\\n  bar_not_in: [String]\\n  bar_not_starts_with: String\\n  bar_starts_with: String\\n  AND: [FooFilter!]\\n  OR: [FooFilter!]\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"So how can we get started with filters?\")), mdx(\"p\", null, \"Getting started with filters is very easy and if you do not want to explicitly define filters or customize anything then filters are super easy to use, lets have a look at that.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPersons(default))\\n            .Type<ListType<NonNullType<PersonType>>>()\\n            .UseFiltering();\\n    }\\n}\\n\\npublic class Query\\n{\\n    public IQueryable<Person> GetPersons([Service]IPersonRepository repository)\\n    {\\n        repository.GetPersons();\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": Be sure to install the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Filters\"), \" NuGet package.\")), mdx(\"p\", null, \"In the above example the person resolver just returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" representing the data source. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" represents a not executed database query on which we are able to apply filters.\"), mdx(\"p\", null, \"The next thing to note is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFiltering\"), \" extension method which adds the filter argument to the field and a middleware that can apply those filters to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \". The execution engine will in the end execute the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" and fetch the data.\"), mdx(\"h1\", null, \"Customizing Filters\"), mdx(\"p\", null, \"The filter objects can be customized and you can rename and remove operations from it or define operations explicitly.\"), mdx(\"p\", null, \"Filters are input objects and are defined through a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType<T>\"), \". In order to define and customize a filter we have to inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType<T>\"), \" and configure it like any other type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonFilterType\\n    : FilterInputType<Person>\\n{\\n    protected override void Configure(\\n        IFilterInputTypeDescriptor<Person> descriptor)\\n    {\\n        descriptor\\n            .BindFieldsExplicitly()\\n            .Filter(t => t.Name)\\n            .BindOperationsExplicitly()\\n            .AllowEquals().Name(\\\"equals\\\").And()\\n            .AllowContains().Name(\\\"contains\\\").And()\\n            .AllowIn().Name(\\\"in\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"The above type defines explicitly for what fields filter operations are allowed and what filter operations are allowed. Also the filter renames the equals filter to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"equals\"), \".\"), mdx(\"p\", null, \"In order to apply this filter type we just have to provide the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFiltering\"), \" extension method with the filter type as type argument.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPerson(default))\\n            .Type<ListType<NonNullType<PersonType>>>();\\n            .UseFiltering<PersonFilterType>()\\n    }\\n}\\n\")), mdx(\"h1\", null, \"AND / OR Filter\"), mdx(\"p\", null, \"There are two built in fields.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AND\"), \": Every condition has to be valid\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"OR\"), \" : At least one condition has to be valid\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  posts(\\n    first: 5\\n    where: { OR: [{ title_contains: \\\"Doe\\\" }, { title_contains: \\\"John\\\" }] }\\n  ) {\\n    edges {\\n      node {\\n        id\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u26A0\\uFE0F OR does not work when you use it like this: \")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  posts(\\n    first: 5\\n    where: { title_contains: \\\"John\\\", OR: { title_contains: \\\"Doe\\\" } }\\n  ) {\\n    edges {\\n      node {\\n        id\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this case the filters are applied like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title_contains: \\\"John\\\" AND title_contains: \\\"Doe\\\"\")), mdx(\"h1\", null, \"Customizing Filter Transformation\"), mdx(\"p\", null, \"With our filter solution you can write your own filter transformation which is fairly easy once you wrapped your head around transforming graphs with visitors.\"), mdx(\"p\", null, \"We provide a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterVisitorBase\"), \" which is the base of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryableFilterVisitor\"), \" and it is basically just implementing an new visitor that walks the filter graph and translates it into any other query syntax.\"), mdx(\"h1\", null, \"Sorting\"), mdx(\"p\", null, \"Like with filter support you can add sorting support to your database queries.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPerson(default))\\n            .Type<ListType<NonNullType<PersonType>>>();\\n            .UseSorting()\\n    }\\n}\\n\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  person(order_by: { name: DESC }) {\\n    name\\n    age\\n  }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": Be sure to install the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Sorting\"), \" NuGet package.\")), mdx(\"p\", null, \"If you want to combine for instance paging, filtering and sorting make sure that the order is like follows:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPerson(default))\\n            .UsePaging<PersonType>()\\n            .UseFiltering()\\n            .UseSorting();\\n    }\\n}\\n\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  person(order_by: { name: DESC }) {\\n    edges {\\n      node {\\n        id\\n        name\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Why is the order important?\")), mdx(\"p\", null, \"Paging, filtering and sorting are modular middleware which form the field resolver pipeline.\"), mdx(\"p\", null, \"The above example basically forms the following pipeline:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Paging -> Filtering -> Sorting -> Field Resolver\")), mdx(\"p\", null, \"The paging middleware will first delegate to the next middleware, which is filtering.\"), mdx(\"p\", null, \"The filtering middleware will also first delegate to the next middleware, which is sorting.\"), mdx(\"p\", null, \"The sorting middleware will again first delegate to the next middleware, which is the actual field resolver.\"), mdx(\"p\", null, \"The field resolver will call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetPerson\"), \" which returns in this example an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<Person>\"), \". The queryable represents a not yet executed database query.\"), mdx(\"p\", null, \"After the resolver has been executed and put its result onto the middleware context the sorting middleware will apply the sort order on the query.\"), mdx(\"p\", null, \"After the sorting middleware has been executed and updated the result on the middleware context the filtering middleware will apply its filters on the queryable and updates the result on the middleware context.\"), mdx(\"p\", null, \"After the paging middleware has been executed and updated the result on the middleware context the paging middleware will slice the data and execute the queryable which will then actually pull in data from the data source.\"), mdx(\"p\", null, \"So, if we for instance applied paging as our last middleware the data set would have been sliced first and then filtered which in most cases is not what we actually want.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#using-filters","title":"Using Filters"},{"url":"#customizing-filters","title":"Customizing Filters"},{"url":"#and--or-filter","title":"AND / OR Filter"},{"url":"#customizing-filter-transformation","title":"Customizing Filter Transformation"},{"url":"#sorting","title":"Sorting"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/data-fetching/filters.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}