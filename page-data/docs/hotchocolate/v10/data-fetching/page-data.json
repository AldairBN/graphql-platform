{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/data-fetching","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/data-fetching/"},"frontmatter":{"title":"Data Loaders"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Data Loaders\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"If you want to read more about \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" in general, you can head over to Facebook's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/facebook/dataloader\"\n  }), \"GitHub repository\"), \".\"), mdx(\"p\", null, \"GraphQL is very flexible in the way we can request data. This flexibility also introduces new classes of problems called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"n+1\"), \" problem for the GraphQL server developer.\"), mdx(\"p\", null, \"In order to depict the issue that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" solves in this context, let me introduce a little GraphQL schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  person(id: ID): Person\\n}\\n\\ntype Person {\\n  id: ID\\n  name: String\\n  friends: [Person]\\n}\\n\")), mdx(\"p\", null, \"The above schema allows to fetch a person by its internal identifier and each person has a list of friends that is represented by a list of persons.\"), mdx(\"p\", null, \"Since GraphQL requests are not fixed requests like REST requests, the developer really defines what data he/she wants. This avoids over-fetching data that you do not need and also saves you unnecessary round-trips to the GraphQL backend.\"), mdx(\"p\", null, \"So, a query against the above schema could look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a: person(id: \\\"a\\\") {\\n    name\\n  }\\n\\n  b: person(id: \\\"b\\\") {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"The above request fetches two persons in one go without the need to call the backend twice. The problem for the GraphQL backend is that field resolvers are atomic and do not have any knowledge about the query as a whole. So, a field resolver does not know that it will be called multiple times in parallel to fetch similar or equal data from the same data source.\"), mdx(\"p\", null, \"This basically represents the first case where \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" help us by batching requests against our database or backend service. Currently, we allow \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" per request and globally.\"), mdx(\"p\", null, \"So, let's look at some code in order to understand what they are doing. First, let's have a look at how we would write our field resolver without \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<Person> GetPerson(string id, [Service]IPersonRepository repository)\\n{\\n    return await repository.GetPersonById(id);\\n}\\n\")), mdx(\"p\", null, \"The above example would result in two calls to the person repository that would than fetch the persons one by one from our data source.\"), mdx(\"p\", null, \"If you think that through you can see that each GraphQL request would cause multiple requests to our data source resulting in sluggish performance and unnecessary round-trips to our data source.\"), mdx(\"p\", null, \"This, means that we reduced the round-trips from our client to our server with GraphQL but multiplied the round-trips between the data sources and the service layer.\"), mdx(\"p\", null, \"With \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" we can now centralise our person fetching and reduce the number of round trips to our data source.\"), mdx(\"p\", null, \"In order to use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" with Hot Chocolate we have to add the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" registry. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" registry basically manages the data loader instances and interacts with the execution engine.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddDataLoaderRegistry();\\n\")), mdx(\"p\", null, \"Next, we have to create a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" that now acts as intermediary between a field resolver and the data source.\"), mdx(\"p\", null, \"You can either implement a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" as class or just provide us with a delegate that represents the fetch logic.\"), mdx(\"h1\", null, \"Class DataLoader\"), mdx(\"p\", null, \"Let us first look at the class \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class PersonDataLoader : DataLoaderBase<string, Person>\\n{\\n    private readonly IPersonRepository _repository;\\n\\n    public PersonDataLoader(IPersonRepository repository)\\n      : base(new DataLoaderOptions<string>())\\n    {\\n        _repository = repository;\\n    }\\n\\n    protected override async Task<IReadOnlyList<Result<Person>>> FetchAsync(\\n        IReadOnlyList<string> keys,\\n        CancellationToken cancellationToken)\\n    {\\n        return _repository.GetPersonBatch(keys);\\n    }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" is now injected by the execution engine as a field resolver argument.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" have to be injected at field resolver argument level and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOT\"), \" as constructor arguments since the lifetime of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" is in many cases shorter than the class containing the field resolvers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(string id, [DataLoader]PersonDataLoader personLoader)\\n{\\n    return personLoader.LoadAsync(id);\\n}\\n\")), mdx(\"p\", null, \"It is important that you do not have to register a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" with your dependency injection provider. Hot Chocolate will handle the instance management and register all \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" automatically with the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" registry that we have added earlier.\"), mdx(\"p\", null, \"Now, person requests in a single execution batch will be batched to the data source.\"), mdx(\"p\", null, \"But there are still some more issues ahead that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" will help us with. For that we should amend our query a little bit.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a: person(id: \\\"a\\\") {\\n    name\\n    friends {\\n      name\\n    }\\n  }\\n\\n  b: person(id: \\\"b\\\") {\\n    name\\n    friends {\\n      name\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"The above query now drills down into the friends property, which again yields persons.\"), mdx(\"p\", null, \"Let's say our person object is located in a Mongo database and the document would look something like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"id\\\":\\\"a\\\"\\n  \\\"name\\\":\\\"Foo\\\"\\n  \\\"friends\\\": [\\n    \\\"b\\\",\\n    \\\"c\\\",\\n    \\\"d\\\"\\n  ]\\n}\\n\\n{\\n  \\\"id\\\":\\\"b\\\"\\n  \\\"name\\\":\\\"Bar\\\"\\n  \\\"friends\\\": [\\n    \\\"a\\\",\\n    \\\"c\\\",\\n    \\\"e\\\"\\n  ]\\n}\\n\")), mdx(\"p\", null, \"The person with ID \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is also friends with person \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \". Moreover, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" is also friends with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \". Furthermore, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" is friends with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and also friends with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \".\\nThe best case now would be that we only fetch \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"d\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"e\"), \" since we have already fetched \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \".\"), mdx(\"p\", null, \"This is the second problem class the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" utility helps us with since the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" contains a cache and holds the resolved instances by default for the duration of your request.\"), mdx(\"h1\", null, \"Delegate DataLoader\"), mdx(\"p\", null, \"With the class \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" you have full control of how the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" works. But in many cases this control is not needed. We have specified four classes of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoaders\"), \" that can be specified as delegate.\"), mdx(\"h2\", null, \"Batch DataLoader\"), mdx(\"p\", null, \"The batch \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" collects requests for entities per processing level and send them as a batch request to the data source. Moreover, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" caches the retrieved entries within a request.\"), mdx(\"p\", null, \"The batch \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" gets the keys as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<TKey>\"), \" and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyDictionary<TKey, TValue>\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(string id, IResolverContext context, [Service]IPersonRepository repository)\\n{\\n    return context.BatchDataLoader<string, Person>(\\\"personByIdBatch\\\", keys => repository.GetPersonBatchAsync(keys)).LoadAsync(id);\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"An example with the \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Batch Dataloader\"), \" can be found \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/blob/master/misc/DataLoader/MessageType.cs\"\n  }), \"here\"), \".\")), mdx(\"h2\", null, \"Group DataLoader\"), mdx(\"p\", null, \"The Group \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" is also a batch \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" but instead of returning one entity per key it returns multiple entities per key. As with the Batch \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" retrieved collections are cached within a request.\"), mdx(\"p\", null, \"The Group \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" gets the keys as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<TKey>\"), \" and returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ILookup<TKey, TValue>\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<IEnumerable<Person>> GetPersonByCountry(string country, IResolverContext context, [Service]IPersonRepository repository)\\n{\\n    return context.GroupDataLoader<string, Person>(\\\"personByCountry\\\", keys => repository.GetPersonsByCountry(keys).ToLookup(t => t.Country)).LoadAsync(country);\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"An example with the \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Batch Dataloader\"), \" can be found \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/blob/master/misc/DataLoader/QueryType.cs\"\n  }), \"here\"), \".\")), mdx(\"h2\", null, \"Cache DataLoader\"), mdx(\"p\", null, \"The cache \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" is basically the easiest to implement since there is no batching involved. So, we can just use the initial \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetPersonById\"), \" method. We, do not get the benefits of batching with this one, but if in a query graph the same entity is resolved twice we will load it only once from the data source.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(string id, IResolverContext context, [Service]IPersonRepository repository)\\n{\\n    return context.CacheDataLoader<string, Person>(\\\"personById\\\", keys => repository.GetPersonById(keys)).LoadAsync(id);\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"An example with the \", mdx(\"strong\", {\n    parentName: \"em\"\n  }, \"Batch Dataloader\"), \" can be found \", mdx(\"a\", _extends({\n    parentName: \"em\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/blob/master/misc/DataLoader/MessageType.cs\"\n  }), \"here\"), \".\")), mdx(\"h2\", null, \"Fetch Once\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FetchOnceAsync\"), \" is not really a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" like described by facebook. It rather uses the infrastructure of our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" to provide an easy way to provide cache heavy resource calls that shall only be done once per request.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<Person> GetPerson(string id, IResolverContext context, [Service]IPersonRepository repository)\\n{\\n    return context.FetchOnceAsync(\\\"cachingLoader\\\", () => repository.GetSomeResource());\\n}\\n\")), mdx(\"h1\", null, \"Stacked DataLoader Calls\"), mdx(\"p\", null, \"This is more like an edge case that is supported than a certain type of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \". Sometimes we have more complex resolvers that might first fetch data from one \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" and use that to fetch data from the next. With the new \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" implementation this is supported and under test.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Task<IEnumerable<Customer>> GetCustomers(string personId, IResolverContext context, [Service]IPersonRepository personRepository, [Service]ICustomerRepository customerRepository)\\n{\\n    Person person = await context.DataLoader(\\\"personLoader\\\", keys => repository.GetPersonById(keys)).LoadAsync(id);\\n    return await context.DataLoader(\\\"customerLoader\\\", keys => repository.GetCustomerById(keys)).LoadAsync(person.CustomerIds);\\n}\\n\")), mdx(\"h1\", null, \"Global DataLoader\"), mdx(\"p\", null, \"Global \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" that are shared between requests. This can be useful for certain caching strategies.\"), mdx(\"p\", null, \"In order to add support for global \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" you can add a second \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" registry. This one has to be declared as singleton. It is important that you declare the global registry first since we use the last registry to register ad-hoc \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddSingleton<IDataLoaderRegistry, DataLoaderRegistry>();\\nservices.AddDataLoaderRegistry();\\n\")), mdx(\"p\", null, \"It is important to know that you always have to do \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddDataLoaderRegistry\"), \" since this also sets up the batch operation that is needed to hook up the execution engine with the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" registry.\"), mdx(\"h1\", null, \"DataLoader Dependency Injection Support\"), mdx(\"p\", null, \"It is possible to register a DataLoader with the standard dependency injection container. This enables referencing DataLoaders through interfaces.\"), mdx(\"p\", null, \"Here is how we can now register a DataLoader:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddDataLoader<IMyDataLoader, MyDataLoader>();\\nservices.AddDataLoader<MyDataLoader>();\\nservices.AddDataLoader<IMyDataLoader>(s => ....);\\n\")), mdx(\"p\", null, \"The DataLoaderRegistry is automatically registered when using this.\"), mdx(\"p\", null, \"On the resolver side I can now resolve my DataLoader through an interface:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<string> ResolveSomething(IMyDataLoader dataLoader)\\n{\\n\\n}\\n\")), mdx(\"p\", null, \"I also do not need to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[DataLoader]\"), \" attribute I the interface implements IDataLoader.\"), mdx(\"h1\", null, \"Custom Data Loaders and Batch Operations\"), mdx(\"p\", null, \"With the new API we are introducing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IBatchOperation\"), \" interface. The query engine will fetch all batch operations and trigger those once all data resolvers in one batch are running. We have implemented this interface for our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" as well. So, if you want to implement some database batching or integrate a custom \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \", then this interface is your friend. There is also a look ahead available which will provide you with the fields that have to be fetched.\"), mdx(\"p\", null, \"If you are planning to implement something in this area, get in contact with us and we will provide you with more information.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#class-dataloader","title":"Class DataLoader"},{"url":"#delegate-dataloader","title":"Delegate DataLoader","items":[{"url":"#batch-dataloader","title":"Batch DataLoader"},{"url":"#group-dataloader","title":"Group DataLoader"},{"url":"#cache-dataloader","title":"Cache DataLoader"},{"url":"#fetch-once","title":"Fetch Once"}]},{"url":"#stacked-dataloader-calls","title":"Stacked DataLoader Calls"},{"url":"#global-dataloader","title":"Global DataLoader"},{"url":"#dataloader-dependency-injection-support","title":"DataLoader Dependency Injection Support"},{"url":"#custom-data-loaders-and-batch-operations","title":"Custom Data Loaders and Batch Operations"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/join-chillicream-slack"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/data-fetching/index.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}