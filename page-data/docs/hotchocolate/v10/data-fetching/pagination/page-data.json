{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/data-fetching/pagination","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/data-fetching/pagination/"},"frontmatter":{"title":"Pagination"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Pagination\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Pagination is one of the most common problems that you have to solve when implementing your backend. Often, sets of data are too large to pass them directly to the consumer of your service.\"), mdx(\"p\", null, \"Pagination solves this problem by giving the consumer the capability to fetch a set in chunks.\"), mdx(\"p\", null, \"There are various ways to implement pagination in your server and you can basically do what ever feels best for you.\"), mdx(\"p\", null, \"However, there are two models that you see in most GraphQL server implementations and we have some specific helpers for the later one.\"), mdx(\"h1\", null, \"Offset-based\"), mdx(\"p\", null, \"Offset-based pagination \\u2014 also called numbered pages \\u2014 is a very common pattern.\"), mdx(\"p\", null, \"Offset-based pagination is found in many server implementation whether the backend is implemented in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"SOAP\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"REST\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \".\"), mdx(\"p\", null, \"Most databases enable you to simply skip and take records. The simplest way to provide such a capability is to add an argument \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"skip\"), \" and an argument \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"take\"), \" like in the following example.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    private readonly _strings = new List<string> { \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\", \\\"f\\\", \\\"g\\\" };\\n\\n    public IEnumerable<string> GetStrings(int? skip, int? take)\\n    {\\n        IEnumerable<string> strings = _strings;\\n\\n        if(skip.HasValue)\\n        {\\n            strings = strings.Skip(skip.Value);\\n        }\\n\\n        if(take.HasValue)\\n        {\\n            strings = strings.Take(take.Value);\\n        }\\n\\n        return strings;\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Relay-style cursor pagination\"), mdx(\"p\", null, \"In cursor-based pagination, a cursor is used to keep track of where in the data set the next items should be fetched from. The cursor can contain various information like the index of the record within the set and properties that the server can use to recreate the set.\"), mdx(\"p\", null, \"Relay\\u2019s support for pagination relies on the GraphQL server exposing connections in a standardized way. In the query, the connection model provides a standard mechanism for slicing and paginating the result set.\"), mdx(\"p\", null, \"Hot Chocolate provides many helpers to make implementing a relay-style cursor pagination a simple task.\"), mdx(\"h2\", null, \"Pagination support through \", mdx(\"inlineCode\", {\n    parentName: \"h2\"\n  }, \"IQueryable<T>\")), mdx(\"p\", null, \"Let us start with something simple and then drill deeper into more complex solutions. For our first example let us assume we have an in-memory list of strings that we do want to expose as paginated list.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public ICollection<string> Strings { get; } =\\n        new List<string> { \\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\", \\\"e\\\", \\\"f\\\", \\\"g\\\" };\\n}\\n\")), mdx(\"p\", null, \"In order to tell Hot Chocolate that an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" shall be exposed as page-able list in our schema we have to declare that in a schema type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.Strings).UsePaging<StringType>();\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" adds the relay-style cursor pagination arguments defined by the spec, defines the return type of the field to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConnectionType<StringType>\"), \" and adds a paging field middleware to the field resolver pipeline.\"), mdx(\"p\", null, \"The middleware can handle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \". This means that you can apply the middleware also to database drivers like entity framework or the Mongo db client.\"), mdx(\"p\", null, \"The database drivers will translate the queryable actions into native database queries.\"), mdx(\"p\", null, \"If you now want to support filtering and/or sorting on a page-able list you have to feed the sorting properties to the paging middleware so that the middleware can include them into the cursors. The cursors can then be used to recreate the data set in fetch more queries.\"), mdx(\"p\", null, \"Let's enhance our example and add the capability to sort our list in descending order.\"), mdx(\"p\", null, \"We will do that by adding another argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descending\"), \" to our field. If the argument is set to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" than the list is sorted by descending order otherwise the set is sorted in ascending order.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.Strings)\\n            .Argument(\\\"descending\\\", a => a.Type<BooleanType>())\\n            .UsePaging<StringType>()\\n            .Resolver(ctx =>\\n            {\\n                IDictionary<string, object> cursorProperties =\\n                    ctx.GetCursorProperties();\\n\\n                // get the sort order from the sorting argument or from a cursor that was passed in.\\n                bool descending = cursorProperties.TryGetValue(\\\"descending\\\", out object d)\\n                    ? (bool)d\\n                    : ctx.Argument<bool>(\\\"descending\\\");\\n\\n                // set the cursor sorting property.\\n                cursorProperties[\\\"descending\\\"] = descending;\\n\\n                IEnumerable<string> strings = ctx.Parent<Query>().Strings;\\n\\n                // return the sorted string dataset with the cursor properties.\\n                return descending\\n                    ? new PageableData<string>(strings.OrderByDescending(t => t), cursorProperties)\\n                    : new PageableData<string>(strings.OrderBy(t => t), cursorProperties);\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"The previous example shows how we can access the cursor sorting properties and how we can pass the cursor sorting properties to the middleware.\"), mdx(\"p\", null, \"Our default solution makes it very easy to provide paging capabilities, but a custom optimized paging could yield better performance.\"), mdx(\"p\", null, \"For this you can extend our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryableConnectionResolver\"), \" implementation or opt in to implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IConnection\"), \" by yourself.\"), mdx(\"p\", null, \"Let us first have a look how you can pass in an extended queryable resolver to our paging middleware.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.Strings)\\n            .Argument(\\\"descending\\\", a => a.Type<BooleanType>())\\n            .UsePaging<StringType>((source, pagingDetails) =>\\n                new QueryableConnectionResolver<T>(\\n                    source, pagingDetails))\\n            .Resolver(ctx =>\\n            {\\n                IDictionary<string, object> cursorProperties =\\n                    ctx.GetCursorProperties();\\n\\n                // get the sort order from the sorting argument or from a cursor that was passed in.\\n                bool descending = cursorProperties.TryGetValue(\\\"descending\\\", out object d)\\n                    ? (bool)d\\n                    : ctx.Argument<bool>(\\\"descending\\\");\\n\\n                // set the curosr sorting property.\\n                cursorProperties[\\\"descending\\\"] = descending;\\n\\n                IEnumerable<string> strings = ctx.Parent<Query>().Strings;\\n\\n                // return the sorted string dataset with the cursor properties.\\n                return descending\\n                    ? new PageableData<string>(strings.OrderByDescending(t => t), cursorProperties)\\n                    : new PageableData<string>(strings.OrderBy(t => t), cursorProperties);\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" extension provides an overload in which you can pass in a factory that creates a connection resolver.\"), mdx(\"h2\", null, \"Pagination support for stored procedures and other sources\"), mdx(\"p\", null, \"In case you want to provide pagination support for stored procedures or other data sources Hot Chocolate allows you to do that as well.\"), mdx(\"p\", null, \"Our generic connection type expects the executed page to be of the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IConnection\"), \". So, basically the field resolver just has to return a class implementing that interface or using our default implementation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Connection<T>\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(\\\"strings\\\")\\n            .AddPagingArguments()\\n            .Type<ConnectionType<StringType>>()\\n            .Resolver(ctx =>\\n            {\\n                // resolver logic that returns IConnection data.\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can implement your data resolver logic as resolver or if it is generalized enough you could implement it as a field middleware.\"), mdx(\"p\", null, \"A field middleware can be declared on the field or on the schema depending on what you want to do.\"), mdx(\"p\", null, \"Let's say you want to write a middleware to provide pagination support specifically for SQL server, then you could provide that as a middleware like we did for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \".\"), mdx(\"p\", null, \"If you need help implementing a pagination solution just reach out to us. We are happy to help you.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://relay.dev/graphql/connections.htm\"\n  }), \"Relay Cursor Connections Specification\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#offset-based","title":"Offset-based"},{"url":"#relay-style-cursor-pagination","title":"Relay-style cursor pagination","items":[{"url":"#pagination-support-through-iqueryablet","title":"Pagination support through IQueryable<T>"},{"url":"#pagination-support-for-stored-procedures-and-other-sources","title":"Pagination support for stored procedures and other sources"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/data-fetching/pagination.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}