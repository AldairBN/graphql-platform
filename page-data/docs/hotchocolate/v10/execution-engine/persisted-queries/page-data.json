{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/execution-engine/persisted-queries","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/execution-engine/persisted-queries/"},"frontmatter":{"title":"Persisted Queries"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Persisted Queries\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Persisted queries are a great way to improve the performance of your GraphQL server.\"), mdx(\"p\", null, \"Persisted queries are validated once no matter if your server restarts or your cache is cleared.\"), mdx(\"p\", null, \"Persisted queries are stored close to your server either in the file system or in a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Redis\"), \" cache this helps to reduce request sizes since your application can send in a query key instead of the whole query.\"), mdx(\"p\", null, \"Hot Chocolate supports out of the box two flows how to handle persisted queries.\"), mdx(\"h1\", null, \"Ahead of Time Query Persistence\"), mdx(\"p\", null, \"The first approach is to store queries ahead of time (ahead of deployment of your application). This can be done by extracting the queries from you client application, hashing them and pushing them to the query storage.\"), mdx(\"p\", null, \"Both \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Relay\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo\"), \" support this use-case and will provide the relevant hashes.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How do we setup Hot Chocolate for that?\")), mdx(\"p\", null, \"Persisted queries are by default disabled, or even more so the middleware that handles all of this is not even plugged in.\"), mdx(\"p\", null, \"In order to enable this, we will use the query execution builder to opt into a different execution pipeline.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(\\n    s => SchemaBuilder.New()\\n        ...\\n        ...\\n        .Create(),\\n    b =>  b.UsePersistedQueryPipeline()\\n        .AddSha256DocumentHashProvider());\\n\")), mdx(\"p\", null, \"So, with two extra lines in our schema initialization we have opted into the persisted query pipeline and opted to use SHA-256 to hash our query document. Hot Chocolate supports out of the box MD5, SHA-1, SHA-256.\"), mdx(\"p\", null, \"OK, Next, we need to add our query storage, since we only need to read from our query storage, we can opt to use a read-only query storage like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddReadOnlyRedisQueryStorage(s => s.GetRequiredService<ConnectionMultiplexer>().GetDatabase());\\n\")), mdx(\"p\", null, \"Alternatively, to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Redis\"), \" we can also use the local file system to load queries:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddReadOnlyFileSystemQueryStorage(\\\"/usr/temp/queries\\\");\\n\")), mdx(\"p\", null, \"With that we have pretty much configured our server to use query persistence. The next thing you would have to do is to rework your \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Relay\"), \" or \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo\"), \" build scripts in order to export your query to your chosen storage. The queries are stored as plain document and have to have the hash as the name without any extension. In case of the file system the hash is saved as URL compliant base64, in case of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Redis\"), \" storage the key is the hash as standard base64.\"), mdx(\"p\", null, \"In your requests to the server you usually send the query wrapped in the JSON request like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"query\\\": \\\"{ foo { bar } }\\\"\\n}\\n\")), mdx(\"p\", null, \"Instead of doing that we can now just specify the request like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"id\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\"\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Read more about how to do persisted queries with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://relay.dev/docs/en/persisted-queries.html\"\n  }), \"Relay\"), \".\\nRead more about how to do persisted queries with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://blog.apollographql.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5\"\n  }), \"Apollo\"), \".\")), mdx(\"h1\", null, \"Active Query Persistence\"), mdx(\"p\", null, \"Active query persistence builds upon the query persistence pipeline and adds the ability to store queries on the fly.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How does this work?\")), mdx(\"p\", null, \"The client would have a flow that would always first ask the server for the query with the query hash.\"), mdx(\"p\", null, \"If the server can find the query in the query storage the server will execute it and return the result just like the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ahead of time persistence\"), \" and if the server could not find the query then again like the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ahead of time persistence\"), \" the server would return a GraphQL error that the query was not found.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"errors\\\": [\\n    {\\n      \\\"message\\\": \\\"PersistedQueryNotFound\\\",\\n      \\\"extensions\\\": {\\n        \\\"code\\\": \\\"PERSISTED_QUERY_NOT_FOUND\\\"\\n      }\\n    }\\n  ]\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The error message and properties can be modified by adding a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IErrorFilter\"), \" that handles the specified error-code.\")), mdx(\"p\", null, \"When the client receives this error message, the client will issue a full JSON request with the GraphQL query and the query hash.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"query\\\": \\\"{ foo { bar } }\\\",\\n  \\\"extensions\\\": {\\n    \\\"persistedQuery\\\": {\\n      \\\"sha256Hash\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\"\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"If the query matches the server query hash the server will store the query in the query persistence storage and execute it. The server response would look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"foo\\\": {\\n      \\\"bar\\\": \\\"baz\\\"\\n    }\\n  },\\n  \\\"extensions\\\": {\\n    \\\"persistedQuery\\\": {\\n      \\\"sha256Hash\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\",\\n      \\\"persisted\\\": true\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"All calls after that will use again only the hash. Since we only ever once per query will have to issue two calls, we will have over the application lifetime no overhead at all.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"How do we set this up?\")), mdx(\"p\", null, \"Again, we have to divert from the default query pipeline, this time we will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseActivePersistedQueryPipeline\"), \" that can also handle storing queries into our query storage.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(\\n    s => SchemaBuilder.New()\\n        ...\\n        ...\\n        .Create(),\\n    b =>  b.UseActivePersistedQueryPipeline()\\n        .AddSha256DocumentHashProvider());\\n\")), mdx(\"p\", null, \"So, with two extra lines in our schema initialization we have opted into the active persisted query pipeline and opted to use SHA-256 to hash our query document. Hot Chocolate supports out of the box MD5, SHA-1, SHA-256.\"), mdx(\"p\", null, \"Next, we need to add our query storage, this time we need a storage to which we can write to.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddRedisQueryStorage(s => s.GetRequiredService<ConnectionMultiplexer>().GetDatabase());\\n\")), mdx(\"p\", null, \"Alternatively, to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Redis\"), \" we can also use the local file system to load queries:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddFileSystemQueryStorage(\\\"/usr/temp/queries\\\");\\n\")), mdx(\"p\", null, \"OK that\\u2019s it.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We are currently working on enabling this flow with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Relay\"), \". Stay tuned for updates on this one.\\nRead more about how to do active persisted queries with \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://medium.com/open-graphql/graphql-dynamic-persisted-queries-eb259700f1d3\"\n  }), \"Apollo\"), \".\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#ahead-of-time-query-persistence","title":"Ahead of Time Query Persistence"},{"url":"#active-query-persistence","title":"Active Query Persistence"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"state-management","title":"State Management","items":null},{"path":"persisted-queries","title":"Persisted Queries","items":null},{"path":"configuration","title":"Configuration","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/execution-engine/persisted-queries.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}