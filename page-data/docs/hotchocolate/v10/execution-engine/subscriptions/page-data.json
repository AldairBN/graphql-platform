{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/execution-engine/subscriptions","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/execution-engine/subscriptions/"},"frontmatter":{"title":"Subscriptions"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Subscriptions\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"What are GraphQL subscriptions?\"), mdx(\"p\", null, \"Subscriptions is a GraphQL feature that allows a server to send data to its clients when a specific event on the server-side occurs.\"), mdx(\"p\", null, \"Subscribing to an event is like writing a standard query. The one difference here is the operation keyword and that we are only allowed to have one root field in our query since the root fields represent events.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"subscription {\\n  onReview(episode: NEWHOPE) {\\n    stars\\n    comment\\n  }\\n}\\n\")), mdx(\"p\", null, \"When using GraphQL over HTTP subscriptions are most most likely served over websocket. Hot Chocolate has implemented the Apollo subscriptions protocol in order to serve subscriptions over websocket.\"), mdx(\"h1\", null, \"Getting started\"), mdx(\"p\", null, \"The subscription type is almost implemented like a simple query. In many cases subscriptions are raised through mutations, but subscriptions could also be raised through other backend systems.\"), mdx(\"p\", null, \"In order to enable subscriptions we have to register a subscription provider with our server. A subscription provider represents a pub/sub system abstraction that handles the events.\"), mdx(\"p\", null, \"We currently support the following subscription provider:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"InMemory\\nThis one is good enough if we have a single server and all events are triggered through our mutations.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Redis\\nWe have an out-of-the-box redis subscription provider that uses the redis publish/subscribe functionality. If we have multiple instances of our server then this provider is our best option.\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We are in the process to add more pub-/sub-provider for Kafka, Redis Streams, Azure EventHub and Azure ServiceBus. We also can help along if you want to implement your own subscription provider.\")), mdx(\"p\", null, \"In order to add the subscription provider to our server add the following service in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ConfigureServices\"), \" method of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Startup.cs\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddInMemorySubscriptionProvider();\\n\")), mdx(\"p\", null, \"or\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddRedisSubscriptionProvider(configuration);\\n\")), mdx(\"p\", null, \"Finally, we have to configure our ASP.NET Core pipeline to use websocket:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Startup\\n{\\n    public void Configure(IApplicationBuilder app, IHostingEnvironment env)\\n    {\\n        app.UseWebSockets()\\n          .UseGraphQL();\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"More about configuring ASP.NET Core can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/v10/server\"\n  }), \"here\"), \".\")), mdx(\"p\", null, \"Once this is setup, subscriptions are generally available. In order to define subscriptions we have to create a subscription type. The subscription type is just a regular \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \", so we create it like any other root type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class SubscriptionType\\n    : ObjectType<Subscription>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Subscription> descriptor)\\n    {\\n        descriptor.Field(t => t.OnReview(default, default))\\n            .Type<NonNullType<ReviewType>>()\\n            .Argument(\\\"episode\\\", arg => arg.Type<NonNullType<EpisodeType>>());\\n    }\\n}\\n\")), mdx(\"p\", null, \"But there is a difference when it comes to the resolver. A subscription resolver can ask for an additional argument that represents the event message.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public Review OnReview(Episode episode, IEventMessage message)\\n{\\n    return (Review)message.Payload;\\n}\\n\")), mdx(\"p\", null, \"The event message can have a user-defined payload representing some kind of prepared data or whatever we want to put in there. The allowed payload size depends on the subscription provider.\"), mdx(\"p\", null, \"The payload can also be null and we can pull relevant data in from other data sources whenever the event occurs.\"), mdx(\"p\", null, \"An event is triggered when we use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEventSender\"), \" to raise an event. This will be mostly done within a mutation since the mutation represents the operation that changes the server state and hence cause it to raise events.\"), mdx(\"p\", null, \"So, in our mutation we can ask for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEventSender\"), \" and raise an event like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<Review> CreateReview(\\n    Episode episode, Review review,\\n    [Service]IEventSender eventSender)\\n{\\n    _repository.AddReview(episode, review);\\n    await eventSender.SendAsync(new OnReviewMessage(episode, review));\\n    return review;\\n}\\n\")), mdx(\"p\", null, \"In the above case we are sending a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnReviewMessage\"), \" which actually inherits from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EventMessage\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class OnReviewMessage\\n    : EventMessage\\n{\\n    public OnReviewMessage(Episode episode, Review review)\\n        : base(CreateEventDescription(episode), review)\\n    {\\n    }\\n\\n    private static EventDescription CreateEventDescription(Episode episode)\\n    {\\n        return new EventDescription(\\\"onReview\\\",\\n            new ArgumentNode(\\\"episode\\\",\\n                new EnumValueNode(\\n                    episode.ToString().ToUpperInvariant())));\\n    }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We have a working example for subscription in our Star Wars \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate/tree/master/examples/AspNetCore.StarWars\"\n  }), \"example\"), \".\")), mdx(\"h1\", null, \"In-Memory Provider\"), mdx(\"p\", null, \"The in-memory subscription provider does not need any configuration and is easily setup:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddInMemorySubscriptionProvider();\\n\")), mdx(\"h1\", null, \"Redis Provider\"), mdx(\"p\", null, \"The redis subscription provider uses Redis as pub/sub system to handle messages, this enables us to run multiple instances of the Hot Chocolate server and handle subscription events reliably.\"), mdx(\"p\", null, \"In order to use the Redis provider add the following package:\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Subscriptions.Redis\")), mdx(\"p\", null, \"After we have added the package we can add the redis subscription provider to our services like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var configuration = new ConfigurationOptions\\n{\\n    Ssl = true,\\n    AbortOnConnectFail = false,\\n    Password = password\\n};\\n\\nconfiguration.EndPoints.Add(\\\"host:port\\\");\\n\\nservices.AddRedisSubscriptionProvider(configuration);\\n\")), mdx(\"p\", null, \"Our Redis subscription provider uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StackExchange.Redis\"), \" Redis client underneath and we have integration tests against the Azure Cache.\"), mdx(\"h1\", null, \"PubSub usage from version 10.x\"), mdx(\"p\", null, \"Since version \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10.x\"), \" it is possible to create subscriptions in a more convenient fashion using the built-in PubSub System. The setup to get subscriptions running did not change. We may not need to use a specific Subscription Type. The Schema Builder can defer the Subscription Type directly from our method.\"), mdx(\"p\", null, \"To use the PubSub System in the subscription inject is as a service via the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventReceiver\"), \" and return the subscribed stream.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [SubscribeAndResolve]\\n    public async ValueTask<IAsyncEnumerable<Review>> UserCreated(Episode episode, [Service] ITopicEventReceiver receiver)\\n    {\\n        return await receiver.SubscribeAsync<string, Review>($\\\"Episode{episode}Reviewed\\\");\\n    }\\n\\n    // ...\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Make sure to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IAsyncEnumerable<T>\"), \" in the return value, otherwise the Schema Builder will throw an exception.\")), mdx(\"p\", null, \"To trigger the subscription we can use the counterpart to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventReceiver\"), \", which is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventSender\"), \". It provides the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SendAsync\"), \" method, which takes two parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The first parameter is the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"topic\"), \" the PubSub should publish on.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The second parameter is the \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"payload\"), \".\")), mdx(\"p\", null, \"In our case the review will published on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EpisodeXYReviewed\"), \" channel. This call will subscriptions returned in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Subscription\"), \" class above.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Mutation {\\n    // ...\\n\\n    public async Task<Review> CreateReview(\\n        Episode episode, Review review,\\n        [Service] ITopicEventSender eventSender)\\n    {\\n        _repository.AddReview(episode, review);\\n        await eventSender.SendAsync($\\\"Episode{episode}Reviewed\\\", review));\\n        return review;\\n    }\\n\\n    // ...\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#what-are-graphql-subscriptions","title":"What are GraphQL subscriptions?"},{"url":"#getting-started","title":"Getting started"},{"url":"#in-memory-provider","title":"In-Memory Provider"},{"url":"#redis-provider","title":"Redis Provider"},{"url":"#pubsub-usage-from-version-10x","title":"PubSub usage from version 10.x"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/enQtNTA4NjA0ODYwOTQ0LTViMzA2MTM4OWYwYjIxYzViYmM0YmZhYjdiNzBjOTg2ZmU1YmMwNDZiYjUyZWZlMzNiMTk1OWUxNWZhMzQwY2Q"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/execution-engine/subscriptions.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}