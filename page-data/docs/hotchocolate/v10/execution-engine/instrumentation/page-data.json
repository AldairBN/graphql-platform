{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/v10/execution-engine/instrumentation","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/v10/execution-engine/instrumentation/"},"frontmatter":{"title":"Instrumentation"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Instrumentation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The Hot Chocolate instrumentation allows you to receive internal instrumentation events and process them further. Instrumentation events are provided through a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DiagnosticSource\"), \".\"), mdx(\"p\", null, \"Using Microsoft\", \"`\", \"s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DiagnosticSource\"), \" API allows us to provide rich events without compromising on information detail.\"), mdx(\"p\", null, \"As a developer using Hot Chocolate we can subscribe to those events and delegate them either to our logging provider or to another tracing infrastructure for further processing.\"), mdx(\"p\", null, \"This allows us to just take the information we need for a certain logging solution and for instance craft the events provided by Hot Chocolate into logging messages that fit our project.\"), mdx(\"h1\", null, \"Events\"), mdx(\"p\", null, \"First let us have a look at what events Hot Chocolate currently provides and what they mean. Later we will walk you through how to setup an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDiagnosticObserver\"), \".\"), mdx(\"h2\", null, \"Query Events\"), mdx(\"p\", null, \"Query events are raised per request. This means that for each query request that we fire up against a Hot Chocolate one query event is raised.\"), mdx(\"p\", null, \"The following query events are available:\"), mdx(\"h2\", null, \"Start Query\"), mdx(\"p\", null, \"The start event is raised once the query engine receives a request.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Query.Start\\\")]\\npublic void BeginQueryExecute(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"p\", null, \"The query context that we provide as payload with the event is the full query context on which the query middleware operates. This enables us to pick and choose the information that we want.\"), mdx(\"h2\", null, \"Stop Query\"), mdx(\"p\", null, \"The stop event is raised once the query engine has completed processing the request. This event is even called if an error has occurred. Additional to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryContext\"), \" the event also provides the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IExecutionResult\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Query.Stop\\\")]\\npublic void EndQueryExecute(\\n    IQueryContext context,\\n    IExecutionResult result)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Query Error\"), mdx(\"p\", null, \"The error event is raised should there be an unhandled exception on the query middleware level. This event is not raised whenever a validation or field error is thrown.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Query.Error\\\")]\\npublic virtual void OnQueryError(\\n    IQueryContext context,\\n    Exception exception)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Parser Events\"), mdx(\"p\", null, \"The parser events are raised when the parser middleware is invoked. It is important to know that the Hot Chocolate server caches queries. This means that only the first time a query is executed, we can measure the parsing time.\"), mdx(\"h2\", null, \"Start Parsing\"), mdx(\"p\", null, \"The start event is raised once the parser middleware is invoked.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Parsing.Start\\\")]\\npublic void BeginParsing(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Stop Parsing\"), mdx(\"p\", null, \"The stop event is raised once the parser finished. It is important to know that the stop event is even raised if a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxException\"), \" is thrown. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Document\"), \" property on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryContext\"), \" will be null in this case. The parser middleware will add a property to the context data indicating if the query was retrieved from the cache: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DocumentRetrievedFromCache\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Parsing.Stop\\\")]\\npublic void EndParsing(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Parsing Errors\"), mdx(\"p\", null, \"The parser will throw a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxException\"), \" if the query is not syntactically correct. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxException\"), \" will cause a query error.\"), mdx(\"h2\", null, \"Validation Events\"), mdx(\"p\", null, \"The validation events are raised whenever the validation middleware is invoked. Like with the parsing middleware the validation middleware will cache validation results. This means that only the first validation of a query document can be used to measure the validation duration. The context property \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DocumentRetrievedFromCache\"), \" can also be used in this case to detect if the validation result was pulled from the internal cache or if it was computed.\"), mdx(\"h2\", null, \"Validation Start\"), mdx(\"p\", null, \"The validation start event is called once the validation middleware is invoked.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Validation.Start\\\")]\\npublic void BeginValidation(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Validation Stop\"), mdx(\"p\", null, \"The stop event is raised once the validation finished. It is important to know that the stop event is even raised if a validation error is raised.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Validation.Stop\\\")]\\npublic void EndValidation(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Validation Errors\"), mdx(\"p\", null, \"The validation error event will be raised for each query document analysis that yields at least one error.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Validation.Error\\\")]\\npublic void OnValidationError(\\n    IQueryContext context,\\n    IReadOnlyCollection<IError> errors)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Operation Events\"), mdx(\"p\", null, \"Operation events represent the execution of the operation by the query engine. At this point all information about the operation have been resolved and can be accessed.\"), mdx(\"p\", null, \"The following operation events are available:\"), mdx(\"h2\", null, \"Start Operation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Operation.Start\\\")]\\npublic void BeginOperationExecute(IQueryContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Stop Operation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Operation.Stop\\\")]\\npublic void EndOperationExecute(\\n    IQueryContext context,\\n    IExecutionResult result)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Resolver Events\"), mdx(\"p\", null, \"Resolver events are raised for every single resolver that is invoked. This is the perfect event to subscribe to if you want to add performance analysis or other resolver tracing solutions.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Have a look at our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate/blob/master/src/Core/Core/Execution/Instrumentation/ApolloTracingDiagnosticObserver.cs\"\n  }), \"ApolloTracingDiagnosticObserver\"), \" to get an idea of how to implement a performance analysis solution.\")), mdx(\"h2\", null, \"Resolver Start\"), mdx(\"p\", null, \"The resolver start event is raised for each invocation of a resolver pipeline. The resolver pipeline is made-up of multiple field middleware components. The exact composition of such a pipeline varies on your setup.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Resolver.Start\\\")]\\npublic void BeginResolveField(IResolverContext context)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Resolver Stop\"), mdx(\"p\", null, \"The resolver stop event is raised once the execution of the resolver pipeline is completed. The provided result is the not completed result of the resolver. This means that the actual result that is integrated into the query result can differ since type converter and serialization are applied during field value completion.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Resolver.Stop\\\")]\\npublic void EndResolveField(\\n    IResolverContext context,\\n    object result)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h2\", null, \"Resolver Error\"), mdx(\"p\", null, \"The resolver error event is raised should one or more resolver errors occurs.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[DiagnosticName(\\\"HotChocolate.Execution.Resolver.Error\\\")]\\npublic void OnResolverError(\\n    IResolverContext context,\\n    IEnumerable<IError> errors)\\n{\\n    // ... your code\\n}\\n\")), mdx(\"h1\", null, \"How to subscribe\"), mdx(\"p\", null, \"In order to subscribe to the Hot Chocolate instrumentation events, you have to create a class that implements the marker interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDiagnosticObserver\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDiagnosticObserver\\n    : IDiagnosticObserver\\n{\\n}\\n\")), mdx(\"p\", null, \"The observer subscribes to an event by adding a method that is annotated with the event name like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDiagnosticObserver\\n    : IDiagnosticObserver\\n{\\n    [DiagnosticName(\\\"HotChocolate.Execution.Validation.Error\\\")]\\n    public void OnValidationError(\\n        IQueryContext context,\\n        IReadOnlyCollection<IError> errors)\\n    {\\n        // ... your code\\n    }\\n}\\n\")), mdx(\"p\", null, \"When subscribing to start/stop events you also have to add the actual event method, otherwise the diagnostic source will not enable the event.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDiagnosticObserver\\n    : IDiagnosticObserver\\n{\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query\\\")]\\n    public void OnQuery(IQueryContext context)\\n    {\\n        // This method is used to enable start/stop events for query.\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Start\\\")]\\n    public void BeginQueryExecute(IQueryContext context)\\n    {\\n        // ... your code\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Stop\\\")]\\n    public void EndQueryExecute(\\n        IQueryContext context,\\n        IExecutionResult result)\\n    {\\n        // ... your code\\n    }\\n}\\n\")), mdx(\"p\", null, \"You can use the context data to pass tracing details like a custom request id between your events:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyDiagnosticObserver\\n    : IDiagnosticObserver\\n{\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query\\\")]\\n    public void OnQuery(IQueryContext context)\\n    {\\n        // This method is used to enable start/stop events for query.\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Start\\\")]\\n    public void BeginQueryExecute(IQueryContext context)\\n    {\\n        context.ContextData[\\\"TracingId\\\"] = Guid.NewGuid();\\n        // ... your code\\n    }\\n\\n    [DiagnosticName(\\\"HotChocolate.Execution.Query.Stop\\\")]\\n    public void EndQueryExecute(\\n        IQueryContext context,\\n        IExecutionResult result)\\n    {\\n        Guid tracingId = (Guid)context.ContextData[\\\"TracingId\\\"];\\n        // ... your code\\n    }\\n}\\n\")), mdx(\"p\", null, \"There are two ways to register the diagnostics observer with the execution engine. You can either register the observer with the executor directly through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryExecutionBuilder\"), \" or you can add the diagnostic observer to your dependency injection provider.\"), mdx(\"p\", null, \"Registering the observer with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryExecutionBuilder\"), \" does not require any dependency injection provider, but let`s you only inject infrastructure services.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    ...\\n    .Create()\\n    .MakeExecutable(builder => builder\\n        .AddDiagnosticObserver<MyDiagnosticObserver>()\\n        .UseDefaultPipeline());\\n\")), mdx(\"p\", null, \"If you want to use the observer in conjunction with your dependency injection provider you can also add the observer to your services. We have added an extension method for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IServiceCollection\"), \" that mirrors the builder extension.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddDiagnosticObserver<MyDiagnosticObserver>();\\n\")), mdx(\"p\", null, \"If you are registering the diagnostics observer with the dependency injection you have to ensure that the resulting service provider is registered with the schema.\"), mdx(\"p\", null, \"If you are using our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGraphQL\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddStitchedSchema\"), \" extensions, you should be covered. In the case that you are putting everything together yourself you will need to register the service provider with your schema manually.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"service.AddSingleton(sp => SchemaBuilder.New()\\n    .AddServices(sp)\\n    ...\\n    .Create());\\n\\nQueryExecutionBuilder\\n    .New()\\n    .UseDefaultPipeline()\\n    .Populate(services);\\n\")), mdx(\"h1\", null, \"Examples\"), mdx(\"p\", null, \"We have created a little example project that demonstrates how you can delegate Hot Chocolate events to the ASP.NET core logger API.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/tree/master/misc/Instrumentation\"\n  }), \"ASP.NET ILogger Example\")), mdx(\"p\", null, \"We also have an implementation that we use in production that builds upon Microsoft\", \"`\", \"s ETW. This is a more complex example since there is a lot of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"unsafe\"), \" code.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/thor-client/tree/master/src/Clients/HotChocolate\"\n  }), \"ETW Example\")), mdx(\"h1\", null, \"Blogs\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://chillicream.com/blog/2019/03/19/logging-with-hotchocolate\"\n  }), \"Tracing with Hot Chocolate\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#events","title":"Events","items":[{"url":"#query-events","title":"Query Events"},{"url":"#start-query","title":"Start Query"},{"url":"#stop-query","title":"Stop Query"},{"url":"#query-error","title":"Query Error"},{"url":"#parser-events","title":"Parser Events"},{"url":"#start-parsing","title":"Start Parsing"},{"url":"#stop-parsing","title":"Stop Parsing"},{"url":"#parsing-errors","title":"Parsing Errors"},{"url":"#validation-events","title":"Validation Events"},{"url":"#validation-start","title":"Validation Start"},{"url":"#validation-stop","title":"Validation Stop"},{"url":"#validation-errors","title":"Validation Errors"},{"url":"#operation-events","title":"Operation Events"},{"url":"#start-operation","title":"Start Operation"},{"url":"#stop-operation","title":"Stop Operation"},{"url":"#resolver-events","title":"Resolver Events"},{"url":"#resolver-start","title":"Resolver Start"},{"url":"#resolver-stop","title":"Resolver Stop"},{"url":"#resolver-error","title":"Resolver Error"}]},{"url":"#how-to-subscribe","title":"How to subscribe"},{"url":"#examples","title":"Examples"},{"url":"#blogs","title":"Blogs"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/zt-lqkb8z7b-aFepT0Qrsgv5_yKy0yoyzw"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/v10/execution-engine/instrumentation.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}