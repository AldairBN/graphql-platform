{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/api-reference/aspnetcore","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/api-reference/aspnetcore/"},"frontmatter":{"title":"ASP.NET Core"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"ASP.NET Core\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Hot Chocolate comes with integration to the ASP.NET Core endpoints API. The middleware implementation follows the current GraphQL over HTTP Spec.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\\n{\\n    app.UseRouting()\\n\\n    app.UseEndpoints(endpoints =>\\n    {\\n        endpoints.MapGraphQL();\\n    });\\n}\\n\")), mdx(\"h1\", null, \"GraphQL over HTTP Spec\"), mdx(\"p\", null, \"The following GraphQL requests follow the current GraphQL over HTTP spec draft.\"), mdx(\"p\", null, \"If no path is specified, the GraphQL middleware will follow the spec recommendation to map the endpoint to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/graphql\"), \".\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://example.com/graphql\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://product.example.com/graphql\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"http://example.com/product/graphql\")), mdx(\"h2\", null, \"GraphQL HTTP POST requests\"), mdx(\"p\", null, \"The GraphQL HTTP POST request is the most commonly used variant for GraphQL requests over HTTP and is specified \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/graphql/graphql-over-http/blob/master/spec/GraphQLOverHTTP.md#post\"\n  }), \"here\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"request:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"POST /graphql\\nHOST: foo.example\\nContent-Type: application/json\\n\\n{\\n  \\\"query\\\": \\\"query($id: ID!){user(id:$id){name}}\\\",\\n  \\\"variables\\\": { \\\"id\\\": \\\"QVBJcy5ndXJ1\\\" }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"response:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"HTTP/1.1 200 OK\\nContent-Type: application/json\\n\\n{\\n  \\\"data\\\": {\\n    \\\"user\\\": {\\n      \\\"name\\\": \\\"Jon Doe\\\"\\n    }\\n  }\\n}\\n\")), mdx(\"h2\", null, \"GraphQL HTTP GET request\"), mdx(\"p\", null, \"GraphQL can also be served through an HTTP GET request. You have the same options as the HTTP POST request, just that the request properties are provided as query parameters. GraphQL HTTP GET requests can be a good choice if you are looking to cache GraphQL requests.\"), mdx(\"p\", null, \"For example, if we wanted to execute the following GraphQL query:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query($id: ID!) {\\n  user(id: $id) {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"With the following query variables:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"id\\\": \\\"QVBJcy5ndXJ1\\\"\\n}\\n\")), mdx(\"p\", null, \"This request could be sent via an HTTP GET as follows:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"request:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"GET /graphql?query=query(%24id%3A%20ID!)%7Buser(id%3A%24id)%7Bname%7D%7D&variables=%7B%22id%22%3A%22QVBJcy5ndXJ1%22%7D`\\nHOST: foo.example\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"response:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"HTTP/1.1 200 OK\\nContent-Type: application/json\\n\\n{\\n  \\\"data\\\": {\\n    \\\"user\\\": {\\n      \\\"name\\\": \\\"Jon Doe\\\"\\n    }\\n  }\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: {query} and {operationName} parameters are encoded as raw strings in the query component. Therefore if the query string contained operationName=null then it should be interpreted as the {operationName} being the string \\\"null\\\". If a literal null is desired, the parameter (e.g. {operationName}) should be omitted.\")), mdx(\"p\", null, \"The GraphQL HTTP GET request is specified \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/graphql/graphql-over-http/blob/master/spec/GraphQLOverHTTP.md#get\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"By default, Hot Chocolate will only serve query operations when HTTP GET requests are used. You can change this default by specifying the GraphQL server options.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\\n{\\n    app.UseRouting()\\n\\n    app.UseEndpoints(endpoints =>\\n    {\\n        endpoints\\n            .MapGraphQL()\\n            .WithOptions(new GraphQLServerOptions\\n            {\\n                AllowedGetOperations = AllowedGetOperations.QueryAndMutation\\n            });\\n    });\\n}\\n\")), mdx(\"p\", null, \"You can also entirely deactivate HTTP GET request handling.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\\n{\\n    app.UseRouting()\\n\\n    app.UseEndpoints(endpoints =>\\n    {\\n        endpoints\\n            .MapGraphQL()\\n            .WithOptions(new GraphQLServerOptions\\n            {\\n                EnableGetRequests = false\\n            });\\n    });\\n}\\n\")), mdx(\"h2\", null, \"Incremental Delivery over HTTP\"), mdx(\"p\", null, \"The Hot Chocolate GraphQL server supports incremental delivery over HTTP, which essentially uses HTTP chunked transfer encoding combined with the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html\"\n  }), \"specification of multipart content defined by the W3 in rfc1341\"), \".\"), mdx(\"p\", null, \"The incremental delivery is at the moment at the RFC stage and is specified \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/graphql/graphql-over-http/blob/master/rfcs/IncrementalDelivery.md\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Incremental delivery is used with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@defer\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@stream\"), \", and with request batching.\"), mdx(\"h1\", null, \"Additional Requests\"), mdx(\"p\", null, \"Apart from the requests defined by the GraphQL over HTTP spec, Hot Chocolate allows you to batch requests, download the GraphQL SDL, and many more things.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Many of the request types stated in this section are on their way into the GraphQL over HTTP spec, and we will update this document as the spec, and its RFCs change.\")), mdx(\"h2\", null, \"GraphQL Schema request\"), mdx(\"p\", null, \"Although you can access and query the schema definition through introspection, we support fetching the GraphQL schema SDL as a file. The GraphQL schema SDL is richer with more information and easier to read.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"request:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"GET /graphql?sdl\\nHOST: foo.example\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"response:\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"HTTP/1.1 200 OK\\nContent-Type: application/graphql\\n\\ntype Query {\\n  hello: String!\\n}\\n\")), mdx(\"h2\", null, \"GraphQL HTTP POST batching request\"), mdx(\"p\", null, \"We support two kinds of batching variants.\"), mdx(\"p\", null, \"The first variant to batch GraphQL requests is by sending in an array of GraphQL requests. Hot Chocolate will execute them in order.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"POST /graphql\\nHOST: foo.example\\nContent-Type: application/json\\n\\n[\\n    {\\n        # The query document.\\n        \\\"query\\\": \\\"query getHero { hero { name } }\\\",\\n\\n        # The name of the operation that shall be executed.\\n        \\\"operationName\\\": \\\"getHero\\\",\\n\\n        # A key under which a query document was saved on the server.\\n        \\\"id\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\",\\n\\n        # The variable values for this request.\\n        \\\"variables\\\": {\\n            \\\"a\\\": 1,\\n            \\\"b\\\": \\\"abc\\\"\\n        },\\n\\n        # Custom properties that can be passed to the execution engine context data.\\n        \\\"extensions\\\": {\\n            \\\"a\\\": 1,\\n            \\\"b\\\": \\\"abc\\\"\\n        }\\n    },\\n    {\\n        # The query document.\\n        \\\"query\\\": \\\"query getHero { hero { name } }\\\",\\n\\n        # The name of the operation that shall be executed.\\n        \\\"operationName\\\": \\\"getHero\\\",\\n\\n        # A key under which a query document was saved on the server.\\n        \\\"id\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\",\\n\\n        # The variable values for this request.\\n        \\\"variables\\\": {\\n            \\\"a\\\": 1,\\n            \\\"b\\\": \\\"abc\\\"\\n        },\\n\\n        # Custom properties that can be passed to the execution engine context data.\\n        \\\"extensions\\\": {\\n            \\\"a\\\": 1,\\n            \\\"b\\\": \\\"abc\\\"\\n        }\\n    },\\n]\\n\")), mdx(\"p\", null, \"The second GraphQL batching variant is called operation batching, where you send in one GraphQL request document with multiple operations. The operation execution order is then specified as a query param.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-http\"\n  }), \"POST /graphql?batchOperations=[a,b]\\nHOST: foo.example\\nContent-Type: application/json\\n\\n{\\n    # The query document.\\n    \\\"query\\\": \\\"query a { hero { name } } query b { hero { name } }\\\",\\n\\n    # The name of the operation that shall be executed.\\n    \\\"operationName\\\": \\\"getHero\\\",\\n\\n    # A key under which a query document was saved on the server.\\n    \\\"id\\\": \\\"W5vrrAIypCbniaIYeroNnw==\\\",\\n\\n    # The variable values for this request.\\n    \\\"variables\\\": {\\n        \\\"a\\\": 1,\\n        \\\"b\\\": \\\"abc\\\"\\n    },\\n\\n    # Custom properties that can be passed to the execution engine context data.\\n    \\\"extensions\\\": {\\n        \\\"a\\\": 1,\\n        \\\"b\\\": \\\"abc\\\"\\n    }\\n}\\n\")), mdx(\"p\", null, \"By default, the GraphQL server will use the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"incremental delivery over HTTP\"), \"specification to write the stream results as soon as they are available. This means that depending on your client implementation; you can start using the results as they appear in order.\"), mdx(\"p\", null, \"The serialization defaults can be changed like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpResultSerializer(\\n    batchSerialization: HttpResultSerialization.JsonArray,\\n    deferSerialization: HttpResultSerialization.MultiPartChunked)\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"More about batching can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"batching\"\n  }), \"here\"), \".\")), mdx(\"h1\", null, \"Subscription Transport\"), mdx(\"p\", null, \"Subscriptions are by default delivered over WebSocket. We have implemented the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md\"\n  }), \"GraphQL over WebSocket Protocol\"), \" specified by Apollo.\"), mdx(\"h2\", null, \"Alternative Transport Protocols\"), mdx(\"p\", null, \"With version 11.1, we will add alternative transport protocols like the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/graphql/graphql-over-http/pull/140\"\n  }), \"new proposal for the GraphQL over HTTP spec\"), \".\"), mdx(\"p\", null, \"Moreover, we are working on allowing this protocol to be used over SignalR, which gives more flexibility to use subscriptions.\"), mdx(\"h1\", null, \"Tooling\"), mdx(\"p\", null, \"The Hot Chocolate GraphQL server comes right out of the gate with excellent tooling. By default, we are mapping our GraphQL IDE Banana Cake Pop to the GraphQL endpoint. This means you just need to open your browser and navigate to the configured endpoint to send requests to your server, explore your schema, or build-up tests.\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"800px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/8d34e72aa3e7a2f3bee4d10735181576/9b01a/get-started-bcp-query.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"63%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAACrUlEQVQ4y22Sy08TQRjA9y/AoxhLAcXExEcsYuUhaXgcMIpGViUxURLiwRsnNX2AWhMOJtgbN7Ph6tGbIfggAbUbQCkUi2lFoF1ot9vHtrvb2e18zixtQewkv52Z/b755cs3w5xrqr3bYTs76bjSPtHZZvedqLf4amqO+I7VHvXV11l8Vstxn7XuEJb9uaHBSpk42dgw2VhvHWHs3dff9lxjoZvQ2XcLevvvwNDQA+jq7YMLLW3QbG8H26W2Cs0l6PqivQMud3ZBq6MHHD1XCX0hpvXh6zdT7z7D/MKK+n5uCS0GIwgAoz/bAvq+GkLB9QhaIwTXwygYCqPl4DpaJv9XQxFCGK2QOfAzrAVCEZjzL31hTt14ws3yAdCVrCGJCZzJpEFVFdDkNFQbRUomA0YBmevSMOhHFBM8c7L/KTc9vwxyRjKisRhOiCLohgEIITCM4j7FIui6DnlVA6SqoORVyGs6FItm3BRGo1Geabrp5Ga+BiCXTRkxQcDJZLJKXXivOnK4gPTSrhTBmGIKBUHgmdPsGDfzbQVymZQhHBCWEiuUhZQqcVMYi8V45sygl/vgX/1PWG3Qw2XhoWEKJUnimfP3xrmPfJAIJSLcwSIR0h4ah6D9o30tC8vV7vXQMIXZbJZnbPdfcZ/4NZDTkk6F8QS5aTmH8/k8VhQFq6pqrtPpNHkBGSwlJRzd3saiKOJ8LodlWaYYJIf20M+0DPu42cV1UOS0vrsbNw+WbqEqwY1N/CsqYIXItEIBa5pG0Wn18Xjcz9iHJ6am539AYicKvzc2YGtrC1KpFJBqgMj/ISVJEIpEYFMQIEmeFxFUIBVDOBxeYBo7btsejTwe9D5/NuAZHWXdbjfrdDpZr9fLjpK9x+Op4CaMe1+yL8bGWBfJOxAbILmDLpfL8RdooDsb/PCD8QAAAABJRU5ErkJggg==')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"GraphQL IDE\",\n    \"title\": \"GraphQL IDE\",\n    \"src\": \"/static/8d34e72aa3e7a2f3bee4d10735181576/7842b/get-started-bcp-query.png\",\n    \"srcSet\": [\"/static/8d34e72aa3e7a2f3bee4d10735181576/f8f3a/get-started-bcp-query.png 200w\", \"/static/8d34e72aa3e7a2f3bee4d10735181576/6a8a8/get-started-bcp-query.png 400w\", \"/static/8d34e72aa3e7a2f3bee4d10735181576/7842b/get-started-bcp-query.png 800w\", \"/static/8d34e72aa3e7a2f3bee4d10735181576/5ece7/get-started-bcp-query.png 1200w\", \"/static/8d34e72aa3e7a2f3bee4d10735181576/0d4f8/get-started-bcp-query.png 1600w\", \"/static/8d34e72aa3e7a2f3bee4d10735181576/9b01a/get-started-bcp-query.png 3480w\"],\n    \"sizes\": \"(max-width: 800px) 100vw, 800px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"The GraphQL IDE can be disabled by specifying tool options:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"endpoints\\n    .MapGraphQL()\\n    .WithOptions(\\n        new GraphQLServerOptions\\n        {\\n            Tool = { Enable = false }\\n        }));\\n\")), mdx(\"h1\", null, \"Serialization\"), mdx(\"p\", null, \"The Hot Chocolate GraphQL server has abstracted the result serialization with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IHttpResultSerializer\"), \" interface. The server uses the registered implementation to resolve the HTTP status code, the HTTP content type, and the serialized response from a GraphQL execution result.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"/// <summary>\\n/// This interface specifies how a GraphQL result is serialized to a HTTP response.\\n/// </summary>\\npublic interface IHttpResultSerializer\\n{\\n    /// <summary>\\n    /// Gets the HTTP content type for the specified execution result.\\n    /// </summary>\\n    /// <param name=\\\"result\\\">\\n    /// The GraphQL execution result.\\n    /// </param>\\n    /// <returns>\\n    /// Returns a string representing the content type,\\n    /// eg. \\\"application/json; charset=utf-8\\\".\\n    /// </returns>\\n    string GetContentType(IExecutionResult result);\\n\\n    /// <summary>\\n    /// Gets the HTTP status code for the specified execution result.\\n    /// </summary>\\n    /// <param name=\\\"result\\\">\\n    /// The GraphQL execution result.\\n    /// </param>\\n    /// <returns>\\n    /// Returns the HTTP status code, eg. <see cref=\\\"HttpStatusCode.OK\\\"/>.\\n    /// </returns>\\n    HttpStatusCode GetStatusCode(IExecutionResult result);\\n\\n    /// <summary>\\n    /// Serializes the specified execution result.\\n    /// </summary>\\n    /// <param name=\\\"result\\\">\\n    /// The GraphQL execution result.\\n    /// </param>\\n    /// <param name=\\\"stream\\\">\\n    /// The HTTP response stream.\\n    /// </param>\\n    /// <param name=\\\"cancellationToken\\\">\\n    /// The request cancellation token.\\n    /// </param>\\n    ValueTask SerializeAsync(\\n        IExecutionResult result,\\n        Stream stream,\\n        CancellationToken cancellationToken);\\n}\\n\")), mdx(\"p\", null, \"We have a default implementation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultHttpResultSerializer\"), \") that can be used to built custom logic on top of the original implementation to make extensibility easier. By default, we are using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Text.Json\"), \" to serialize GraphQL execution results to JSON.\"), mdx(\"p\", null, \"A custom implementation of the result serializer is registered like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpResultSerializer<MyCustomHttpResultSerializer>();\\n\")), mdx(\"p\", null, \"If you, for instance, wanted to add some special error code handling when some error happened during execution, you could implement this like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyCustomHttpResultSerializer : DefaultHttpResultSerializer\\n{\\n    public override HttpStatusCode GetStatusCode(IExecutionResult result)\\n    {\\n        if (result is IQueryResult queryResult &&\\n            queryResult.Errors?.Count > 0 &&\\n            queryResult.Errors.Any(error => error.Code == \\\"SOME_AUTH_ISSUE\\\"))\\n        {\\n            return HttpStatusCode.Forbidden;\\n        }\\n\\n        return base.GetStatusCode(result);\\n    }\\n}\\n\")), mdx(\"h1\", null, \"GraphQL request customization\"), mdx(\"p\", null, \"The GraphQL server allows you to customize how the GraphQL request is created. For this, you need to implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IHttpRequestInterceptor\"), \". For convenience reasons, we provide a default implementation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultHttpRequestInterceptor\"), \") that can be extended.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class DefaultHttpRequestInterceptor : IHttpRequestInterceptor\\n{\\n    public virtual ValueTask OnCreateAsync(\\n        HttpContext context,\\n        IRequestExecutor requestExecutor,\\n        IQueryRequestBuilder requestBuilder,\\n        CancellationToken cancellationToken)\\n    {\\n        requestBuilder.TrySetServices(context.RequestServices);\\n        requestBuilder.TryAddProperty(nameof(HttpContext), context);\\n        requestBuilder.TryAddProperty(nameof(ClaimsPrincipal), context.User);\\n        requestBuilder.TryAddProperty(nameof(CancellationToken), context.RequestAborted);\\n\\n        if (context.IsTracingEnabled())\\n        {\\n            requestBuilder.TryAddProperty(WellKnownContextData.EnableTracing, true);\\n        }\\n\\n        return default;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Suppose you want to add more data to a GraphQL request; override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OnCreateAsync\"), \" method, and add your custom data as a request property. These request properties are mapped to the request context data, which can be accessed in the field resolver or a field middleware through the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"if(context.ContextData.ContainsKey(nameof(HttpContext)))\\n{\\n    // some logic\\n}\\n\")), mdx(\"p\", null, \"The context data can also be injected into resolver methods.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public string MyResolver([GlobalState(nameof(HttpContext))] HttpContext context)\\n{\\n    // some logic\\n}\\n\")), mdx(\"p\", null, \"A good practice is to inherit from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GlobalStateAttribute\"), \" to create a custom typed attribute.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public string MyResolver([HttpContext] HttpContext context)\\n{\\n    // some logic\\n}\\n\")), mdx(\"h1\", null, \"Subscription session handling\"), mdx(\"p\", null, \"The Hot Chocolate GraphQL server allows you to interact with the server's socket session handling by implementing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ISocketSessionInterceptor\"), \". For convenience reasons, we provide a default implementation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultSocketSessionInterceptor\"), \") that can be extended.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class DefaultSocketSessionInterceptor : ISocketSessionInterceptor\\n{\\n    public virtual ValueTask<ConnectionStatus> OnConnectAsync(\\n        ISocketConnection connection,\\n        InitializeConnectionMessage message,\\n        CancellationToken cancellationToken) =>\\n        new ValueTask<ConnectionStatus>(ConnectionStatus.Accept());\\n\\n    public virtual ValueTask OnRequestAsync(\\n        ISocketConnection connection,\\n        IQueryRequestBuilder requestBuilder,\\n        CancellationToken cancellationToken)\\n    {\\n        HttpContext context = connection.HttpContext;\\n        requestBuilder.TrySetServices(connection.RequestServices);\\n        requestBuilder.TryAddProperty(nameof(CancellationToken), connection.RequestAborted);\\n        requestBuilder.TryAddProperty(nameof(HttpContext), context);\\n        requestBuilder.TryAddProperty(nameof(ClaimsPrincipal), context.User);\\n\\n        if (connection.HttpContext.IsTracingEnabled())\\n        {\\n            requestBuilder.TryAddProperty(WellKnownContextData.EnableTracing, true);\\n        }\\n\\n        return default;\\n    }\\n\\n    public virtual ValueTask OnCloseAsync(\\n        ISocketConnection connection,\\n        CancellationToken cancellationToken) =>\\n        default;\\n}\\n\")), mdx(\"p\", null, \"A custom socket session interceptor can be registered like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddSocketSessionInterceptor<MyCustomSocketSessionInterceptor>();\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#graphql-over-http-spec","title":"GraphQL over HTTP Spec","items":[{"url":"#graphql-http-post-requests","title":"GraphQL HTTP POST requests"},{"url":"#graphql-http-get-request","title":"GraphQL HTTP GET request"},{"url":"#incremental-delivery-over-http","title":"Incremental Delivery over HTTP"}]},{"url":"#additional-requests","title":"Additional Requests","items":[{"url":"#graphql-schema-request","title":"GraphQL Schema request"},{"url":"#graphql-http-post-batching-request","title":"GraphQL HTTP POST batching request"}]},{"url":"#subscription-transport","title":"Subscription Transport","items":[{"url":"#alternative-transport-protocols","title":"Alternative Transport Protocols"}]},{"url":"#tooling","title":"Tooling"},{"url":"#serialization","title":"Serialization"},{"url":"#graphql-request-customization","title":"GraphQL request customization"},{"url":"#subscription-session-handling","title":"Subscription session handling"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/zt-lqkb8z7b-aFepT0Qrsgv5_yKy0yoyzw"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/api-reference/aspnetcore.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}