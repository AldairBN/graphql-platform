{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/api-reference/extending-filtering","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/api-reference/extending-filtering/"},"frontmatter":{"title":"Extending Filtering"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Extending Filtering\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Work in progress\"), \": This documentation is not yet complete.\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Data\"), \" package works with all databases that support \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \". Included in the\\ndefault settings, are all filter operations that work over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" on all databases.\\nSometimes this is not enough. Some databases might not support \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \". Some other databases may have\\ntechnology-specific operations (e.g. SQL Like). Filtering was designed with extensibility in mind.\"), mdx(\"p\", null, \"Filtering can be broken down into two basic parts. Schema building and execution. In schema building,\\nthe input types are created. In execution, the data passed by the user is analyzed and translated to a\\ndatabase query. Both parts can be configured over a convention.\"), mdx(\"p\", null, \"In theory, you are free to design the structure of filters as it suits you best.\\nUsually, it makes sense to divide the structure into two parts. The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"field\"), \" and the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"operation\"), \".\"), mdx(\"p\", null, \"The query below returns all movies where the franchise is equal to \\\"Star Wars\\\". The \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"field\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"franchise\"), \" where the filter\\nis applied to and the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"operation\"), \" equals (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \") that should operate on this field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  movies(where: { franchise: { eq: \\\"Star Wars\\\" } }) {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"Fields can also form paths. In the query below there are two \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fields\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"genre\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalMovieCount\"), \" and one operation equals\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  movies(where: { genre: { totalMovieCount: { eq: 100 } } }) {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"The two queries above show the difference between \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fields\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"operations\"), \" well. A field is always context-specific.\\nEven when two fields have the same name, like the description of a movie and the description of a genre, they have different meanings.\\nOne field refers to the description of a movie and the other description refers to the description of a genre.\\nSame name, different meanings. An operation on the other hand, has always the same meaning.\\nThe equals operation (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \") do always mean that the value of the selected field, should\\nbe equals to the value that was provided in the query.\\nOperations can be applied in different contexts, but the operation itself, stays the same.\\nThe name of the operation should be consistent. There should only be one operation that checks for equality.\\nThis operation should always have the same name.\"), mdx(\"p\", null, \"With this in mind, we can have a deeper dive into filtering. Buckle up, this might get exciting.\"), mdx(\"h1\", null, \"How everything fits together\"), mdx(\"p\", null, \"At the core of the configuration API of filtering there sits a convention. The convention holds the whole\\nconfiguration that filtering needs to create filter types and to translate them to the database.\\nDuring schema creation, the schema builder asks the convention how the schema should look like.\\nThe convention defines the names and descriptions of types and fields and also what the type should be used for properties\\nThe convention also defines what provider should be used to translate a GraphQL query to a database query.\\nThe provider is the only thing that is used after the schema is built.\\nEvery field or operation in a filter type has a handler annotated.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"During schema initialization, these handlers are bound, to the GraphQL fields. The provider can specify which handler should be bound to which field.\\nDuring execution, the provider visits the incoming value node and executes the handler on the fields.\\nThis loose coupling allows defining the provider independently of the convention.\"), mdx(\"h1\", null, \"Filter Convention\"), mdx(\"p\", null, \"A filter convention is a dotnet class that has to implement the interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IFilterConvention\"), \".\\nInstead of writing a convention completely new, it is recommended to extend the base convention \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConvention\"), \"\\nThis convention is also configurable with a fluent interface, so in most cases you can probably just use the descriptor API.\"), mdx(\"h2\", null, \"Descriptor\"), mdx(\"p\", null, \"Most of the capabilities of the descriptor are already documented under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fetching Data -> Filtering\"), \".\\nIf you have not done this already, it is now the right time to head over to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/fetching-data/filtering\"\n  }), \"Filtering\"), \" and read the parts about the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConventions\")), mdx(\"p\", null, \"There are two things on this descriptor that are not documented in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Fetching Data\"), \":\"), mdx(\"h3\", null, \"Operation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IFilterOperationConventionDescriptor Operation(int operationId);\\n\")), mdx(\"p\", null, \"Operations are configured globally. Each operation has a unique identifier. You can find the build-in identifiers in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultFilterOperations\"), \".\\nThis identifier is used in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType<T>\"), \"'s to bind operations on a type. Filter operations can also be configured with a fluent interface.\\nYou can specify the name and the description of the operation. This configuration is applied to all operation fields a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType<T>\"), \" defines.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"conventionDescriptor\\n    .Operation(DefaultFilterOperations.Equals)\\n    .Name(\\\"equals\\\")\\n    .Description(\\\"Compares the value of the input to the value of the field\\\");\\n\")), mdx(\"p\", null, \"With this configuration, all equals operations are now no longer names \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \" but \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"equals\"), \" and have a description.\"), mdx(\"p\", null, \"If you want to create your own operations, you have to choose an identifier.\\nTo make sure to not collide with the framework, choose a number that is higher than 1024.\\nIf you are a framework developer and want to create an extension for HotChocolate, talk to us.\\nWe can assign you a range of operations so you do not collide with the operations defined by users.\"), mdx(\"p\", null, \"You will need this identifier later, so it probably makes sense to store it somewhere on a class\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public static class CustomOperations\\n{\\n    public const int Like = 1025;\\n}\\n\\npublic static class CustomerFilterConventionExtensions\\n{\\n    public static IFilterConventionDescriptor AddInvariantComparison(\\n        this IFilterConventionDescriptor conventionDescriptor) =>\\n        conventionDescriptor\\n            .Operation(CustomOperations.Like)\\n            .Name(\\\"like\\\");\\n}\\n\")), mdx(\"p\", null, \"To apply this configuration to operations types, you can use the Configure method\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    conventionDescriptor.Configure<StringOperationInputType>(\\n        x => x.Operation(CustomOperations.Like))\\n\")), mdx(\"h3\", null, \"Provider\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IFilterConventionDescriptor Provider<TProvider>()\\n        where TProvider : class, IFilterProvider;\\n    IFilterConventionDescriptor Provider<TProvider>(TProvider provider)\\n        where TProvider : class, IFilterProvider;\\n    IFilterConventionDescriptor Provider(Type provider);\\n\")), mdx(\"p\", null, \"On the convention, you can also specify what provider should be used. For now you need just to know\\nthat you can configure the provider here. We will have a closer look at the provider later.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"conventionDescriptor.Provider<CustomProvider>();\\n\")), mdx(\"h2\", null, \"Custom Conventions\"), mdx(\"p\", null, \"Most of the time the descriptor API should satisfy your needs. It is recommended to build extensions\\nbased on the descriptor API, rather than creating a custom convention.\\nHowever, if you want to have full control over naming and type creation, you can also override the methods\\nyou need on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConvention\"), \".\"), mdx(\"p\", null, \"You can also override the configure method to have a (probably) familiar API experience.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConvention : FilterConventio\\n{\\n    protected override void Configure(IFilterConventionDescriptor descriptor)\\n    {\\n        desciptor.AddDefaults();\\n    }\\n\\n    public override NameString GetTypeName(Type runtimeType) =>\\n        base.GetTypeName(runtimeType) + \\\"Suffix\\\";\\n}\\n\")), mdx(\"h1\", null, \"Providers\"), mdx(\"p\", null, \"Like the convention, a provider can be configured over a fluent interface.\\nEvery filter field or operation has a specific handler defined. The handler translates the operation to the database.\\nThese handlers are stored on the provider. After the schema is initialized, an interceptor visits the filter types and requests a handler from the provider.\\nThe handler is annotated directly on the field.\\nThe provider translates an incoming query into a database query by traversing an input object and executing the handlers on the fields.\"), mdx(\"p\", null, \"The output of a translation is always some kind of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"filter definition\"), \". In case, of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" this is an expression.\\nIn case, of MongoDB this is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterDefinition\"), \". Provider, visitor context and handler, operate on and produce this \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"filter definition\"), \".\"), mdx(\"p\", null, \"To inspect and analyze the input object, the provider uses a visitor.\\nWhat a visitor is and how you can write you own visitor, you can find here: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"\"\n  }), \"Visitor Documentation\"), \"\\nVisitors are a powerful yet complex concept, we tried our best to abstract it away.\\nFor most cases, you will not need to create a custom visitor.\"), mdx(\"h2\", null, \"Provider Descriptor\"), mdx(\"p\", null, \"The descriptor of a provider is simple. It only has one method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    IFilterProviderDescriptor<TContext> AddFieldHandler<TFieldHandler>()\\n        where TFieldHandler : IFilterFieldHandler<TContext>;\\n\")), mdx(\"p\", null, \"With this method you can register field handlers on the provider.\"), mdx(\"h2\", null, \"Field Handler\"), mdx(\"p\", null, \"Every field or operation is annotated with an instance of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterFieldHandler<TContext, T>\"), \". When the provider is asked for a handler for a field, it iterates sequentially through the list of existing field handlers and calls the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CanHandle\"), \" method.\\nThe first field handler that can handle the field, is annotated on the field.\\nAs the visitor traverses the input object, it calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TryHandleEnter\"), \" as it enters the input field and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TryHandleLeave\"), \" as it leaves it.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A field handler supports constructor injection and is a singleton. Do not store data on the field handler. use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"context\"), \" of the visitor for state management.\")), mdx(\"h3\", null, \"CanHandle\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    bool CanHandle(\\n        ITypeCompletionContext context,\\n        IFilterInputTypeDefinition typeDefinition,\\n        IFilterFieldDefinition fieldDefinition);\\n\")), mdx(\"p\", null, \"Tests if this field handler can handle a field. If it can handle the field it will be attached to it.\"), mdx(\"h3\", null, \"TryHandleEnter\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"bool TryHandleEnter(\\n    TContext context,\\n    IFilterField field,\\n    ObjectFieldNode node,\\n    [NotNullWhen(true)] out ISyntaxVisitorAction? action);\\n\")), mdx(\"p\", null, \"This method is called when the visitor encounters a field.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"context\"), \" is the context of the visitor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"field\"), \" is the instance of the field that is currently visited\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node\"), \" is the field node of the input object. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node.Value\"), \" contains the value of the field.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"action\"), \" If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TryHandleEnter\"), \" returns true, the action is used for further processing by the visitor.\")), mdx(\"h3\", null, \"TryHandleLeave\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"bool TryHandleLeave(\\n    TContext context,\\n    IFilterField field,\\n    ObjectFieldNode node,\\n    [NotNullWhen(true)] out ISyntaxVisitorAction? action);\\n\")), mdx(\"p\", null, \"This method is called when the visitor leave the field it previously entered.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"context\"), \" is the context of the visitor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"field\"), \" is the instance of the field that is currently visited\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node\"), \" is the field node of the input object. \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"node.Value\"), \" contains the value of the field.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"action\"), \" If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TryHandleLeave\"), \" returns true, the action is used for further processing by the visitor.\")), mdx(\"h2\", null, \"Filter Operation Handlers\"), mdx(\"p\", null, \"There is only one kind of field handler. To make it easier to handle operations, there also exists \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterOperationHandler<TContext, T>\"), \", a more specific abstraction.\\nYou can override \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TryHandleOperation\"), \" to handle operations.\"), mdx(\"h2\", null, \"The Context\"), mdx(\"p\", null, \"As the visitor and the field handlers are singletons, a context object is passed along with the traversation of input objects.\\nField handlers can push data on this context, to make it available for other handlers further down in the tree.\"), mdx(\"p\", null, \"The context contains \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Types\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Operations\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Errors\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Scopes\"), \". It is very provider-specific what data you need to store in the context.\\nIn the case of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" provider, it also contains \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RuntimeTypes\"), \" and knows if the source is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InMemory\"), \" or a database call.\"), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Scopes\"), \" it is possible to add multiple logical layers to a context. In the case of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQuerable\"), \" this is needed, whenever a new closure starts\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"//          /------------------------ SCOPE 1 -----------------------------\\\\\\n//                                        /----------- SCOPE 2 -------------\\\\\\nusers.Where(x => x.Company.Addresses.Any(y => y.Street == \\\"221B Baker Street\\\"))\\n\")), mdx(\"p\", null, \"A filter statement that produces the expression above would look like this\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users(\\n    where: {\\n      company: { addresses: { any: { street: { eq: \\\"221B Baker Street\\\" } } } }\\n    }\\n  ) {\\n    name\\n  }\\n}\\n\")), mdx(\"p\", null, \"A little simplified this is what happens during visitation:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users(\\n    where: # level[0] = [] # instance[0] = x # Create SCOPE 1 with parameter x of type User\\n    {\\n      # Push property User.Company onto the scope\\n      # instance[1] =  x.Company\\n      # level[1] = []\\n      company: {\\n        # Push property Company.Addresses onto the scope\\n        # instance[2] x.Company.Addresses\\n        # level[2] = []\\n        addresses: {\\n          # Create SCOPE 2 with parameter y of type Address\\n          # instance[0] = y\\n          # level[0] = []\\n          any: {\\n            # Push poperty Address.Street onto the scope\\n            # instance[1] = y.Street\\n            # level[1] = []\\n            street: {\\n              # Create and push the operation onto the scope\\n              # instance[2] = y.Street\\n              # level[2] = [y.Street == \\\"221B Baker Street\\\"]\\n              eq: \\\"221B Baker Street\\\"\\n            }\\n            # Combine everything of the current level and pop the porperty street from the instance\\n            # instance[1] = y.Street\\n            # level[1] = [y.Street == \\\"221B Baker Street\\\"]\\n          }\\n          # Combine everything of the current level, create the any operation and exit SCOPE 2\\n          # instance[2] = x.Company.Addresses\\n          # level[2] = [x.Company.Addresses.Any(y => y.Street == \\\"221B Baker Street\\\")]\\n        }\\n        # Combine everything of the current level and pop the porperty street from the instance\\n        # instance[1] = x.Company\\n        # level[1] = [x.Company.Addresses.Any(y => y.Street == \\\"221B Baker Street\\\")]\\n      }\\n      # Combine everything of the current level and pop the porperty street from the instance\\n      # instance[0] = x\\n      # level[0] = [x.Company.Addresses.Any(y => y.Street == \\\"221B Baker Street\\\")]\\n    }\\n  ) {\\n    name\\n  }\\n}\\n\")), mdx(\"h1\", null, \"Extending IQueryable\"), mdx(\"p\", null, \"The default filtering implementation uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" under the hood. You can customize the translation of queries by registering handlers on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryableFilterProvider\"), \".\"), mdx(\"p\", null, \"The following example creates a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringOperationHandler\"), \" that supports case insensitive filtering:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"// The QueryableStringOperationHandler already has an implemenation of CanHandle\\n// It checks if the field is declared in a string operation type and also checks if\\n// the operation of this field uses the `Operation` specified in the override property further\\n// below\\npublic class QueryableStringInvariantEqualsHandler : QueryableStringOperationHandler\\n{\\n    // For creating a expression tree we need the `MethodInfo` of the `ToLower` method of string\\n    private static readonly MethodInfo _toLower = typeof(string)\\n        .GetMethods()\\n        .Single(\\n            x => x.Name == nameof(string.ToLower) &&\\n            x.GetParameters().Length == 0);\\n\\n    // This is used to match the handler to all `eq` fields\\n    protected override int Operation => DefaultFilterOperations.Equals;\\n\\n    public override Expression HandleOperation(\\n        QueryableFilterContext context,\\n        IFilterOperationField field,\\n        IValueNode value,\\n        object parsedValue)\\n    {\\n        // We get the instance of the context. This is the expression path to the propert\\n        // e.g. ~> y.Street\\n        Expression property = context.GetInstance();\\n\\n        // the parsed value is what was specified in the query\\n        // e.g. ~> eq: \\\"221B Baker Street\\\"\\n        if (parsedValue is string str)\\n        {\\n            // Creates and returnes the operation\\n            // e.g. ~> y.Street.ToLower() == \\\"221b baker street\\\"\\n            return Expression.Equal(\\n                Expression.Call(property, _toLower),\\n                Expression.Constant(str.ToLower()));\\n        }\\n\\n        // Something went wrong \\uD83D\\uDE31\\n        throw new InvalidOperationException();\\n    }\\n}\\n\")), mdx(\"p\", null, \"This operation handler can be registered on the convention:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomFilteringConvention : FilterConvention\\n{\\n    protected override void Configure(IFilterConventionDescriptor descriptor)\\n    {\\n        descriptor.AddDefaults();\\n        descriptor.Provider(\\n            new QueryableFilterProvider(\\n                x => x\\n                    .AddDefaultFieldHandlers()\\n                    .AddFieldHandler<QueryableStringInvariantEqualsHandler>()));\\n    }\\n}\\n\\n// and then\\nservices.AddGraphQLServer()\\n    .AddFiltering<CustomFilteringConvention>();\\n\")), mdx(\"p\", null, \"To make this registration easier, HotChocolate also supports convention and provider extensions.\\nInstead of creating a custom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConvention\"), \", you can also do the follwing:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    .AddFiltering()\\n    .AddConvention<IFilterConvention>(\\n        new FilterConventionExtension(\\n            x => x.AddProviderExtension(\\n                new QueryableFilterProviderExtension(\\n                    y => y.AddFieldHandler<QueryableStringInvariantEqualsHandler>()))));\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#how-everything-fits-together","title":"How everything fits together"},{"url":"#filter-convention","title":"Filter Convention","items":[{"url":"#descriptor","title":"Descriptor"},{"url":"#custom-conventions","title":"Custom Conventions"}]},{"url":"#providers","title":"Providers","items":[{"url":"#provider-descriptor","title":"Provider Descriptor"},{"url":"#field-handler","title":"Field Handler"},{"url":"#filter-operation-handlers","title":"Filter Operation Handlers"},{"url":"#the-context","title":"The Context"}]},{"url":"#extending-iqueryable","title":"Extending IQueryable"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/api-reference/extending-filtering.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}