{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/api-reference/interface-type","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/api-reference/interface-type/"},"frontmatter":{"title":"Interface Type"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Interface Type\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The interface is an abstract output type that includes a certain set of fields that an object must include to implement the interface.\"), mdx(\"p\", null, \"The GraphQL schema representation of an interface looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"interface Node {\\n  id: ID!\\n}\\n\")), mdx(\"p\", null, \"The GraphQL schema representation of an object implementing that interface would look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Starship implements Node {\\n  id: ID!\\n  name: String!\\n  length(unit: LengthUnit = METER): Float\\n}\\n\")), mdx(\"p\", null, \"A single object can implement multiple interfaces and is not limited to just one.\"), mdx(\"p\", null, \"An interface in GraphQL consists of a collection of fields. Multiple objects can implement this interface.\"), mdx(\"p\", null, \"With Hot Chocolate you can define an interface by using the GraphQL SDL syntax or by using C#. In contrast to objects we do not need to specify resolvers for interface fields since the interface only specifies the structure of the data that can be queried but not how to retrieve the data.\"), mdx(\"p\", null, \"In order to specify an interface, we only have to write an actual C# interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public interface INode\\n{\\n    string Id { get; }\\n}\\n\\n\\nSchemaBuilder.New()\\n  .AddType<INode>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Like with objects we can also specify an interface with a schema type to express in more detail what we want our schema type to look like.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class NodeType\\n    : InterfaceType<INode>\\n{\\n    protected override void Configure(IInterfaceTypeDescriptor<INode> descriptor)\\n    {\\n        descriptor.Name(\\\"Node\\\");\\n        descriptor.Field(t => t.Id).Type<NonNullType<IdType>>();\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  .AddType<NodeType>()\\n  .Create();\\n\")), mdx(\"p\", null, \"Also like with any type you have a generic schema type and a non-generic one:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class NodeType\\n    : InterfaceType\\n{\\n    protected override void Configure(IInterfaceTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Node\\\");\\n        descriptor.Field(\\\"id\\\").Type<NonNullType<IdType>>();\\n    }\\n}\\n\\nSchemaBuilder.New()\\n  .AddType<NodeType>()\\n  .Create();\\n\")), mdx(\"p\", null, \"There are two important things to know here, if you are using a generic schema-type or if you are registering the interface directly with the schema then you do not have to explicitly specify with the object type that the object is implementing this schema since we can infer that.\"), mdx(\"p\", null, \"Let me give you an example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Foo : INode\\n{\\n    string Id { get; }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" class is implementing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INode\"), \" so if we register \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INode\"), \" with our schema as an interface then the schema would infer that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" implements \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INode\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n  .AddType<INode>()\\n  .AddType<Foo>()\\n  .Create();\\n\")), mdx(\"p\", null, \"The upper schema would look like the following in the GraphQL SDL syntax:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"interface INode {\\n  id: ID!\\n}\\n\\ntype Foo implements INode {\\n  id: ID!\\n}\\n\")), mdx(\"p\", null, \"If we did not register \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INode\"), \" with our schema we would ignore the interface implementation:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n  .AddType<Foo>()\\n  .Create();\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Foo {\\n  id: ID!\\n}\\n\")), mdx(\"p\", null, \"But what if we defined the schema with the non-generic base class or if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Foo\"), \" did not implement that interface?\"), mdx(\"p\", null, \"In this case we could tell our schema type that we are implementing it.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType\\n    : ObjectType<Foo>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Foo> descriptor)\\n    {\\n        descriptor.Implements<NodeType>();\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"coding-approaches","title":"Coding Approaches"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/api-reference/interface-type.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}