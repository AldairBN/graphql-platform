{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/fetching-data/filtering","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/fetching-data/filtering/"},"frontmatter":{"title":"Filtering"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Filtering\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"With Hot Chocolate filters, you can expose complex filter objects through your GraphQL API that translates to native database queries. The default filter implementation translates filters to expression trees that are applied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \".\\nHot Chocolate by default will inspect your .NET model and infer the possible filter operations from it.\\nFilters use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable\"), \") by default, but you can also easily customize them to use other interfaces.\"), mdx(\"p\", null, \"The following type would yield the following filter operations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Foo\\n{\\n    public string Bar { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input FooFilterInput {\\n  and: [FooFilterInput!]\\n  or: [FooFilterInput!]\\n  name: StringOperationFilterInput\\n}\\n\\ninput StringOperationFilterInput {\\n  and: [StringOperationFilterInput!]\\n  or: [StringOperationFilterInput!]\\n  eq: String\\n  neq: String\\n  contains: String\\n  ncontains: String\\n  in: [String]\\n  nin: [String]\\n  startsWith: String\\n  nstartsWith: String\\n  endsWith: String\\n  nendsWith: String\\n}\\n\")), mdx(\"h1\", null, \"Getting started\"), mdx(\"p\", null, \"Filtering is part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Data\"), \" package. You can add the dependency with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" cli\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet add package HotChocolate.Data\\n\")), mdx(\"p\", null, \"To use filtering you need to register it on the schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n  // Your schmea configuration\\n  .AddFiltering();\\n\")), mdx(\"p\", null, \"Hot Chocolate will infer the filters directly from your .Net Model and then use a Middleware to apply filters to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" on execution.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\npublic class QueryType : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor\\n            .Field(f => f.GetUsers(default))\\n            .Type<ListType<NonNullType<UserType>>>()\\n            .UseFiltering();\\n    }\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support filtering!\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" If you use more than one middleware, keep in mind that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ORDER MATTERS\"), \". The correct order is UsePaging > UseProjections > UseFiltering > UseSorting\")), mdx(\"h1\", null, \"Customization\"), mdx(\"p\", null, \"Under the hood, filtering is based on top of normal Hot Chocolate input types. You can easily customize them with a very familiar fluent interface. The filter input types follow the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor\"), \" scheme as you are used to from the normal input types. Just extend the base class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType<T>\"), \" and override the descriptor method.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IFilterInputTypeDescriptor<T>\"), \" supports most of the methods of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IInputTypeDescriptor<T>\"), \". By default filters for all fields of the type are generated.\\nIf you do want to specify the filters by yourself you can change this behavior with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFields\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFieldsExplicitly\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFieldsImplicitly\"), \".\\nWhen fields are bound implicitly, meaning filters are added for all properties, you may want to hide a few fields. You can do this with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ignore(x => Bar)\"), \".\\nIt is also possible to customize the GraphQL field of the operation further. You can change the name, add a description or directive.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserFilterType : FilterInputType<User>\\n{\\n    protected override void Configure(\\n        IFilterInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.BindFieldsExplicitly();\\n        descriptor.Field(f => f.Name).Name(\\\"custom_name\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you want to limit the operations on a field, you need to declare you own operation type.\\nGiven you want to only allow \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"eq\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"neq\"), \" on a string field, this could look like this\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\",\n    \"metastring\": \"{7}\",\n    \"{7}\": true\n  }), \"public class UserFilterType : FilterInputType<User>\\n{\\n    protected override void Configure(\\n        IFilterInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.BindFieldsExplicitly();\\n        descriptor.Field(f => f.Name).Type<CustomStringFilterType>();\\n    }\\n}\\n\\npublic class CustomerOperationFilterInput : StringOperationFilterInput\\n{\\n    protected override void Configure(IFilterInputTypeDescriptor descriptor)\\n    {\\n        descriptor.Operation(DefaultFilterOperations.Equals);\\n        descriptor.Operation(DefaultFilterOperations.NotEquals);\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  name: CustomerOperationFilterInput\\n}\\n\\ninput CustomerOperationFilterInput {\\n  and: [CustomerOperationFilterInput!]\\n  or: [CustomerOperationFilterInput!]\\n  eq: String\\n  neq: String\\n}\\n\")), mdx(\"p\", null, \"To apply this filter type we just have to provide it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFiltering\"), \" extension method with as the generic type argument.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseFiltering(typeof(UserFilterType))]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(f => f.GetUsers(default))\\n            .Type<ListType<NonNullType<UserType>>>();\\n            .UseFiltering<UserFilterType>()\\n    }\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support filtering!\"))), mdx(\"h1\", null, \"AND / OR Filter\"), mdx(\"p\", null, \"There are two built in fields.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AND\"), \": Every condition has to be valid\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"OR\"), \" : At least one condition has to be valid\")), mdx(\"p\", null, \"Example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  posts(\\n    first: 5\\n    where: {\\n      OR: [{ title: { contains: \\\"Doe\\\" } }, { title: { contains: \\\"John\\\" } }]\\n    }\\n  ) {\\n    edges {\\n      node {\\n        id\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u26A0\\uFE0F OR does not work when you use it like this: \")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  posts(\\n    first: 5\\n    where: { title: { contains: \\\"John\\\", OR: { title: { contains: \\\"Doe\\\" } } } }\\n  ) {\\n    edges {\\n      node {\\n        id\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this case the filters are applied like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title.Contains(\\\"John\\\") && title.Contains(\\\"Doe\\\")\"), \" rather than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"title.Contains(\\\"John\\\") || title.Contains(\\\"Doe\\\")\"), \" how you probably intended it.\"), mdx(\"h2\", null, \"Removing AND / OR\"), mdx(\"p\", null, \"If you do not want to expose \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AND\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OR\"), \" you can remove these fields with the descriptor API:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserFilterType : FilterInputType<User>\\n{\\n    protected override void Configure(\\n        IFilterInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.AllowAnd(false).AllowOr(false);\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Filter Types\"), mdx(\"h2\", null, \"Boolean Filter\"), mdx(\"p\", null, \"Defined the filter operations of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool\"), \" field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public bool IsOnline { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput BooleanOperationFilterInput {\\n  eq: Boolean\\n  neq: Boolean\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  isOnline: BooleanOperationFilterInput\\n}\\n\")), mdx(\"h2\", null, \"Comparable Filter\"), mdx(\"p\", null, \"Defines filters for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IComparables\"), \" like: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bool\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"byte\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shot\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"long\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"float\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"double\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decimal\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Guid\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTimeOffset\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TimeSpan\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public int LoginAttempts { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput ComparableOperationInt32FilterInput {\\n  eq: Int\\n  neq: Int\\n  in: [Int!]\\n  nin: [Int!]\\n  gt: Int\\n  ngt: Int\\n  gte: Int\\n  ngte: Int\\n  lt: Int\\n  nlt: Int\\n  lte: Int\\n  nlte: Int\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  loginAttempts: ComparableOperationInt32FilterInput\\n}\\n\")), mdx(\"h2\", null, \"String Filter\"), mdx(\"p\", null, \"Defines filters for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public string Name { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput StringOperationFilterInput {\\n  and: [StringOperationFilterInput!]\\n  or: [StringOperationFilterInput!]\\n  eq: String\\n  neq: String\\n  contains: String\\n  ncontains: String\\n  in: [String]\\n  nin: [String]\\n  startsWith: String\\n  nstartsWith: String\\n  endsWith: String\\n  nendsWith: String\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  name: StringOperationFilterInput\\n}\\n\")), mdx(\"h2\", null, \"Enum Filter\"), mdx(\"p\", null, \"Defines filters for C# enums\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public enum Role {\\n  Default,\\n  Moderator,\\n  Admin\\n}\\n\\npublic class User\\n{\\n    public Role Role { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput RoleOperationFilterInput {\\n  eq: Role\\n  neq: Role\\n  in: [Role!]\\n  nin: [Role!]\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  kind: RoleOperationFilterInput\\n}\\n\")), mdx(\"h2\", null, \"Object Filter\"), mdx(\"p\", null, \"An object filter is generated for all nested objects. The object filter can also be used to filter over database relations.\\nFor each nested object, filters are generated.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public Address Address { get; set; }\\n}\\n\\npublic class Address\\n{\\n    public string Street { get; set; }\\n\\n    public bool IsPrimary { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput AddressFilterInput {\\n  and: [AddressFilterInput!]\\n  or: [AddressFilterInput!]\\n  street: StringOperationFilterInput\\n  isPrimary: BooleanOperationFilterInput\\n}\\n\\ninput BooleanOperationFilterInput {\\n  eq: Boolean\\n  neq: Boolean\\n}\\n\\ninput StringOperationFilterInput {\\n  and: [StringOperationFilterInput!]\\n  or: [StringOperationFilterInput!]\\n  eq: String\\n  neq: String\\n  contains: String\\n  ncontains: String\\n  in: [String]\\n  nin: [String]\\n  startsWith: String\\n  nstartsWith: String\\n  endsWith: String\\n  nendsWith: String\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  address: AddressFilterInput\\n}\\n\")), mdx(\"h2\", null, \"List Filter\"), mdx(\"p\", null, \"List filters are generated for all nested enumerations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public string[] Roles { get; set; }\\n\\n    public IEnumerable<Address> Addresses { get; set; }\\n}\\n\\npublic class Address\\n{\\n    public string Street { get; set; }\\n\\n    public bool IsPrimary { get; set; }\\n}\\n\\npublic class Query\\n{\\n    [UseFiltering]\\n    public IQueryable<User> GetUsers([Service] IUserRepository repository)\\n        => repository.GetUsers();\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ninput AddressFilterInput {\\n  and: [AddressFilterInput!]\\n  or: [AddressFilterInput!]\\n  street: StringOperationFilterInput\\n  isPrimary: BooleanOperationFilterInput\\n}\\n\\ninput BooleanOperationFilterInput {\\n  eq: Boolean\\n  neq: Boolean\\n}\\n\\ninput ListAddressFilterInput {\\n  all: AddressFilterInput\\n  none: AddressFilterInput\\n  some: AddressFilterInput\\n  any: Boolean\\n}\\n\\ninput ListStringOperationFilterInput {\\n  all: StringOperationFilterInput\\n  none: StringOperationFilterInput\\n  some: StringOperationFilterInput\\n  any: Boolean\\n}\\n\\ninput StringOperationFilterInput {\\n  and: [StringOperationFilterInput!]\\n  or: [StringOperationFilterInput!]\\n  eq: String\\n  neq: String\\n  contains: String\\n  ncontains: String\\n  in: [String]\\n  nin: [String]\\n  startsWith: String\\n  nstartsWith: String\\n  endsWith: String\\n  nendsWith: String\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  roles: ListStringOperationFilterInput\\n  addresses: ListAddressFilterInput\\n}\\n\")), mdx(\"h1\", null, \"Filter Conventions\"), mdx(\"p\", null, \"If you want to change the behavior filtering globally, you want to create a convention for your filters. The filter convention comes with a fluent interface that is close to a type descriptor.\"), mdx(\"h2\", null, \"Get Started\"), mdx(\"p\", null, \"To use a filter convention you can extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConvention\"), \" and override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method. Alternatively, you can directly configure the convention over the constructor argument.\\nYou then have to register your custom convention on the schema builder with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddConvention\"), \".\\nBy default a new convention is empty. To add the default behaviour you have to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddDefaults\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConvention : FilterConvention\\n{\\n    protected override void Configure(IFilterConventionDescriptor descriptor)\\n    {\\n        descriptor.AddDefaults();\\n    }\\n}\\n\\nservices.AddGraphQLServer()\\n    .AddConvention<IFilterConvention, CustomConvention>();\\n// or\\nservices.AddGraphQLServer()\\n    .AddConvention<IFilterConvention>(new FilterConvention(x =>\\n        x.AddDefaults()))\\n\")), mdx(\"p\", null, \"Often you just want to extend the default behaviour of filtering. If this is the case, you can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterConventionExtension\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConventionExtension : FilterConventionExtension\\n{\\n    protected override void Configure(IFilterConventionDescriptor descriptor)\\n    {\\n        // config\\n    }\\n}\\n\\nservices.AddGraphQLServer()\\n    .AddConvention<IFilterConvention, CustomConventionExtension>();\\n// or\\nservices.AddGraphQLServer()\\n    .AddConvention<IFilterConvention>(new FilterConventionExtension(x =>\\n    {\\n        // config\\n    }));\\n\")), mdx(\"h2\", null, \"Argument Name\"), mdx(\"p\", null, \"With the convention descriptor, you can easily change the argument name of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.ArgumentName(\\\"example_argument_name\\\");\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(example_argument_name: UserFilter): [User]\\n}\\n\")), mdx(\"h2\", null, \"Binding of FilterTypes\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType\"), \"'s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cannot\"), \" just be registered on the schema. You have to bind them to the runtime type on the convention.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserFilterInput : FilterInputType<User>\\n{\\n    protected override void Configure(\\n        IFilterInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.Field(x => x.Name).Description(\\\"This is the name\\\");\\n    }\\n}\\n\\npublic class CustomStringOperationFilterInput : StringOperationFilterInput\\n{\\n    protected override void Configure(IFilterInputTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Operation(DefaultFilterOperations.Equals)\\n            .Type<StringType>();\\n        descriptor\\n            .Operation(DefaultFilterOperations.NotEquals)\\n            .Type<StringType>();\\n    }\\n}\\n\\ndescriptor.BindRuntimeType<string, CustomStringOperationFilterInput >();\\ndescriptor.BindRuntimeType<User, UserFilterInput>();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): [User]\\n}\\n\\ntype User {\\n  name: String!\\n}\\n\\ninput CustomStringOperationFilterInput {\\n  and: [CustomStringOperationFilterInput!]\\n  or: [CustomStringOperationFilterInput!]\\n  eq: String\\n  neq: String\\n}\\n\\ninput UserFilterInput {\\n  and: [UserFilterInput!]\\n  or: [UserFilterInput!]\\n  \\\"This is the name\\\"\\n  name: CustomStringOperationFilterInput\\n}\\n\")), mdx(\"h2\", null, \"Extend FilterTypes\"), mdx(\"p\", null, \"Instead of defining your own operation type, you can also just change the configuration of the built\\nin ones.\\nYou can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure<TFilterType>()\"), \" to alter the configuration of a type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"  descriptor.Configure<StringOperationFilterInput>(\\n    x => x.Operation(DefaultFilterOperations.Equals).Description(\\\"Equals\\\"))\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input StringOperationFilterInput {\\n  and: [StringOperationFilterInput!]\\n  or: [StringOperationFilterInput!]\\n  \\\"Equals\\\"\\n  eq: String\\n  neq: String\\n  contains: String\\n  ncontains: String\\n  in: [String]\\n  nin: [String]\\n  startsWith: String\\n  nstartsWith: String\\n  endsWith: String\\n  nendsWith: String\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#getting-started","title":"Getting started"},{"url":"#customization","title":"Customization"},{"url":"#and--or-filter","title":"AND / OR Filter","items":[{"url":"#removing-and--or","title":"Removing AND / OR"}]},{"url":"#filter-types","title":"Filter Types","items":[{"url":"#boolean-filter","title":"Boolean Filter"},{"url":"#comparable-filter","title":"Comparable Filter"},{"url":"#string-filter","title":"String Filter"},{"url":"#enum-filter","title":"Enum Filter"},{"url":"#object-filter","title":"Object Filter"},{"url":"#list-filter","title":"List Filter"}]},{"url":"#filter-conventions","title":"Filter Conventions","items":[{"url":"#get-started","title":"Get Started"},{"url":"#argument-name","title":"Argument Name"},{"url":"#binding-of-filtertypes","title":"Binding of FilterTypes"},{"url":"#extend-filtertypes","title":"Extend FilterTypes"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/join-chillicream-slack"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/fetching-data/filtering.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}