{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/fetching-data/sorting","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/fetching-data/sorting/"},"frontmatter":{"title":"Sorting"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Sorting\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"What is sorting\"), mdx(\"p\", null, \"Ordering results of a query dynamically is a common case. With Hot Chocolate sorting, you can expose a sorting argument, that abstracts the complexity of ordering logic.\\nWith little configuration your GraphQL API has sorting capabilities which translates to native database queries.\\nThe default sort implementation translates sorting statements to expression trees that are applied to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \".\\nHot Chocolate by default will inspect your .NET model and infer the possible filter operations from it.\\nSorting uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable\"), \") by default but you can also easily customize them to use other interfaces.\"), mdx(\"p\", null, \"The following type would yield the following sorting operation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public class User\\n    {\\n        public string Name { get; set; }\\n\\n        public Address Address { get; set; }\\n    }\\n\\n    public class Address\\n    {\\n        public string Street { get; set; }\\n    }\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(order: [UserSortInput]): [User]\\n}\\n\\ntype User {\\n  name: String!\\n  address: Address!\\n}\\n\\ninput AddressSortInput {\\n  street: SortEnumType\\n}\\n\\ninput UserSortInput {\\n  name: SortEnumType\\n  address: AddressSortInput\\n}\\n\\nenum SortEnumType {\\n  ASC\\n  DESC\\n}\\n\")), mdx(\"h1\", null, \"Getting started\"), mdx(\"p\", null, \"Sorting is part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Data\"), \" package. You can add the dependency with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" cli\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"  dotnet add package HotChocolate.Data\\n\")), mdx(\"p\", null, \"To use sorting you need to register it on the schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n  // Your schmea configuration\\n  .AddSorting();\\n\")), mdx(\"p\", null, \"Hot Chocolate will infer the sorting types directly from your .Net Model and then use a Middleware to apply the order to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" on execution.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" If you use more than middleware, keep in mind that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ORDER MATTERS\"), \". The correct order is UsePaging > UseProjections > UseFiltering > UseSorting\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPersons(default)).UseSorting();\\n    }\\n}\\n\\npublic class Query\\n{\\n    public IQueryable<Person> GetPersons([Service]IPersonRepository repository) =>\\n        repository.GetPersons();\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pure Code First\")), mdx(\"p\", null, \"The field descriptor attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseSorting]\"), \" does apply the extension method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSorting()\"), \" on the field descriptor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseSorting]\\n    public IQueryable<Person> GetPersons([Service]IPersonRepository repository)\\n    {\\n        repository.GetPersons();\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Customization\"), mdx(\"p\", null, \"Under the hood, sorting is based ontop of normal Hot Chocolate input types. You can easily customize them with a very familiar fluent interface. The sorting input types follow the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor\"), \" scheme as you are used to from the normal input types. Just extend the base class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SortInputType<T>\"), \" and override the descriptor method.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ISortInputTypeDescriptor<T>\"), \" supports most of the methods of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IInputTypeDescriptor<T>\"), \". By default, operations are generated for all fields of the type.\\nMembers that are collections are skipped because you cannot order based on lists.\\nIf you do want to specify the sorting types by yourself you can change this behavior with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFields\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFieldsExplicitly\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BindFieldsImplicitly\"), \".\\nWhen fields are bound implicitly, meaning sorting is added for all valid properties, you may want to hide a few fields. You can do this with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Ignore(x => Bar)\"), \".\\nIt is also possible to customize the GraphQL field of the operation further. You can change the name, add a description or directive.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserSortType\\n    : SortInputType<User>\\n{\\n    protected override void Configure(ISortInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.BindFieldsExplicitly();\\n        descriptor.Field(x => x.Name).Name(\\\"custom_name\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"If you want to change the sorting operations on a field, you need to declare you own operation enum type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\",\n    \"metastring\": \"{7}\",\n    \"{7}\": true\n  }), \"public class UserSortType\\n    : SortInputType<User>\\n{\\n    protected override void Configure(ISortInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.BindFieldsExplicitly();\\n        descriptor.Field(x => x.Name).Type<AscOnlySortEnumType>();\\n    }\\n}\\n\\npublic class AscOnlySortEnumType\\n    : DefaultSortEnumType\\n{\\n    protected override void Configure(ISortEnumTypeDescriptor descriptor)\\n    {\\n        descriptor.Operation(DefaultSortOperations.Ascending);\\n    }\\n}\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(order: [UserSortInput]): [User]\\n}\\n\\ntype User {\\n  name: String!\\n  address: Address!\\n}\\n\\ninput UserSortInput {\\n  name: AscOnlySortEnumType\\n}\\n\\nenum AscOnlySortEnumType {\\n  ASC\\n}\\n\")), mdx(\"p\", null, \"To apply this sorting type we just have to provide it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseSorting\"), \" extension method with as the generic type argument.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor\\n          .Field(t => t.GetUser(default))\\n          .UseSorting<UserSortType>()\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pure Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseSorting(typeof(UserSortType))]\\n    public IQueryable<User> GetUsers([Service]IUserRepository repository)\\n    {\\n        repository.GetUsers();\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Sorting Conventions\"), mdx(\"p\", null, \"If you want to change the behavior sorting globally, you want to create a convention for sorting. The sorting convention comes with a fluent interface that is close to a type descriptor.\"), mdx(\"h2\", null, \"Get Started\"), mdx(\"p\", null, \"To use a sort convention you have to extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SortConvention\"), \" and override the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method. Alternatively, you can directly configure the convention over the constructor argument.\\nYou then have to register your custom convention on the schema builder with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddConvention\"), \".\\nBy default a new convention is empty. To add the default behaviour you have to add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddDefaults\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConvention\\n    : SortConvention\\n{\\n    protected override void Configure(ISortConventionDescriptor descriptor)\\n    {\\n        descriptor.AddDefaults();\\n    }\\n}\\n\\nservices.AddGraphQLServer()\\n  .AddConvention<ISortConvention, CustomConvention>();\\n// or\\nservices.AddGraphQLServer()\\n  .AddConvention<ISortConvention>(new Convention(x => x.AddDefaults()))\\n\")), mdx(\"p\", null, \"Often you just want to extend the default behaviour of sorting. If this is the case, you can also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SortConventionExtension\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConventionExtension\\n    : SortConventionExtension\\n{\\n    protected override void Configure(ISortConventionDescriptor descriptor)\\n    {\\n      // config\\n    }\\n}\\n\\nservices.AddGraphQLServer()\\n  .AddConvention<ISortConvention, CustomConventionExtension>();\\n// or\\nservices.AddGraphQLServer()\\n  .AddConvention<IFilterConvention>(new FilterConventionExtension(x => /*config*/))\\n\")), mdx(\"h2\", null, \"Argument Name\"), mdx(\"p\", null, \"With the convention descriptor, you can easily change the argument name of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterInputType\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.ArgumentName(\\\"example_argument_name\\\");\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(example_argument_name: [UserSortInput]): [User]\\n}\\n\")), mdx(\"h2\", null, \"Binding of SortTypes\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SortInputType\"), \"'s \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cannot\"), \" just be registered on the schema. You have to bind them to the runtime type on the convention.\"), mdx(\"h3\", null, \"SortInputType bindings\"), mdx(\"p\", null, \"By default only the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" type is bound explicitly. If you want to configure sorting globally you are free to bind additional types.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomSortInputType\\n    : SortInputType<User>\\n{\\n    protected override void Configure(ISortInputTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.Name(\\\"CustomSortInputType\\\");\\n    }\\n}\\npublic class CustomConvention\\n    : SortConvention\\n{\\n    protected override void Configure(ISortConventionDescriptor descriptor)\\n    {\\n        descriptor.AddDefaults().BindRuntimeType<User, CustomSortInputType>();\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\ntype Query {\\n  users(order: [CustomSortInputType!]): [User]\\n}\\n\\ntype User {\\n  name: String!\\n}\\n\\ninput CustomSortInputType {\\n  name: SortEnumType\\n}\\n\\nenum SortEnumType {\\n  ASC\\n  DESC\\n}\\n\")), mdx(\"h3\", null, \"Default bindings\"), mdx(\"p\", null, \"For fields all fields where no explicit binding is found, a default is applied. This default is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultSortEnumType\"), \".\\nThis can be configured with the method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultBinding\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Configuration\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class CustomConvention\\n    : SortConvention\\n{\\n    protected override void Configure(ISortConventionDescriptor descriptor)\\n    {\\n        descriptor.AddDefaults().DefaultBinding<AscOnlySortEnumType>();\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Result\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(order: [UserSortInput]): [User]\\n}\\n\\ntype User {\\n  logonCount: Int!\\n}\\n\\ninput UserSortInput {\\n  logonCount: AscOnlySortEnumType\\n}\\n\\nenum AscOnlySortEnumType {\\n  ASC\\n}\\n\")), mdx(\"h2\", null, \"Extend Types\"), mdx(\"h3\", null, \"SortEnumType\"), mdx(\"p\", null, \"When you build extensions for sorting, you may want to modify or extend the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultSortEnumType\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.ConfigureEnum<DefaultSortEnumType>(\\n  x => x.Operaion(CustomOperations.NULL_FIRST).Name(\\\"NULL_FIRST));\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"enum SortEnumType {\\n  ASC\\n  DESC\\n  NULL_FIRST\\n}\\n\")), mdx(\"h3\", null, \"SortType\"), mdx(\"p\", null, \"In case you want to change a specific sort type you can do this too.\\nYou can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure<TSortType>()\"), \" to alter the configuration of a type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.Configure<CustomSortInputType>(\\n  x => x.Description(\\\"This is my custome description\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"This is my customer description\\\"\\ninput CustomSortInputType {\\n  name: SortEnumType\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#what-is-sorting","title":"What is sorting"},{"url":"#getting-started","title":"Getting started"},{"url":"#customization","title":"Customization"},{"url":"#sorting-conventions","title":"Sorting Conventions","items":[{"url":"#get-started","title":"Get Started"},{"url":"#argument-name","title":"Argument Name"},{"url":"#binding-of-sorttypes","title":"Binding of SortTypes"},{"url":"#extend-types","title":"Extend Types"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/fetching-data/sorting.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}