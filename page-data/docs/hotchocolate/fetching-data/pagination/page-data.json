{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/fetching-data/pagination","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/fetching-data/pagination/"},"frontmatter":{"title":"Pagination"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Pagination\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Pagination is one of the most common problems that we have to solve when implementing our backend. Often, sets of data are too large to pass them directly to the consumer of our service.\"), mdx(\"p\", null, \"Pagination solves this problem by giving the consumer the ability to fetch a set in chunks.\"), mdx(\"h1\", null, \"Connections\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connections\"), \" are a standardized way to expose pagination to clients.\"), mdx(\"p\", null, \"Instead of returning a list of entries, we return a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connection\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(first: Int after: String last: Int before: String): UserConnection\\n}\\n\\ntype UserConnection {\\n  pageInfo: PageInfo!\\n  edges: [UserEdge!]\\n  nodes: [User!]\\n}\\n\\ntype UserEdge {\\n  cursor: String!\\n  node: User!\\n}\\n\\ntype PageInfo {\\n  hasNextPage: Boolean!\\n  hasPreviousPage: Boolean!\\n  startCursor: String\\n  endCursor: String\\n}\\n\")), mdx(\"p\", null, \"You can learn more about this in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://relay.dev/graphql/connections.htm\"\n  }), \"GraphQL Cursor Connections Specification\"), \".\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connections\"), \" are often associated with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor-based\"), \" pagination, due to the use of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \". Since the specification describes the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \" as opague though, it can be used to faciliate an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset\"), \" as well.\")), mdx(\"h2\", null, \"Usage\"), mdx(\"p\", null, \"Adding pagination capabilties to our fields is a breeze. All we have to do is add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" middleware.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UsePaging]\\n    public IEnumerable<User> GetUsers([Service] IUserRespository repository)\\n        => repository.GetUsers();\\n}\\n\")), mdx(\"p\", null, \"If we need to specify the concrete node type of our pagination, we can do so by passing a Type as the constructor argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UsePaging(typeof(User))]\"), \".\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" attribute also allows us to configure some other properties, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultPageSize\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxPageSize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IncludeTotalCount\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UsePaging(MaxPageSize = 50)]\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Field(\\\"users\\\")\\n            .UsePaging()\\n            .Resolve(context =>\\n            {\\n                var repository = context.Service<IUserRespository>();\\n\\n                return repository.GetUsers();\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"If we need to specify the concrete node type of our pagination, we can do so via the generic argument: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging<UserType>()\"), \".\"), mdx(\"p\", null, \"We can also configure the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" middleware further, by specifying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PagingOptions\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.UsePaging(options: new PagingOptions\\n{\\n    MaxPageSize = 50\\n});\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"p\", null, \"For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" middleware to work, our resolver needs to return an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \". The middleware will then apply the pagination arguments to what we have returned. In the case of an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" this means that the pagination operations can be directly translated to native database queries, through database drivers like EntityFramework or the MongoDB client.\"), mdx(\"h2\", null, \"Customization\"), mdx(\"p\", null, \"If we need more control over the pagination process we can do so, by returning a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Connection<T>\"), \".\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UsePaging]\\n    public Connection<User> GetUsers(string? after, int? first, string sortBy)\\n    {\\n        // get users using the above arguments\\n        IEnumerable<User> users = null;\\n\\n        var edges = users.Select(user => new Edge<User>(user, user.Id))\\n                            .ToList();\\n        var pageInfo = new ConnectionPageInfo(false, false, null, null);\\n\\n        var connection = new Connection<User>(edges, pageInfo,\\n                            ct => ValueTask.FromResult(0));\\n\\n        return connection;\\n    }\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Field(\\\"users\\\")\\n            .UsePaging()\\n            .Argument(\\\"sortBy\\\", a => a.Type<NonNullType<StringType>>())\\n            .Resolve(context =>\\n            {\\n                var after = context.ArgumentValue<string?>(\\\"after\\\");\\n                var first = context.ArgumentValue<int?>(\\\"first\\\");\\n                var sortBy = context.ArgumentValue<string>(\\\"sortBy\\\");\\n\\n                // get users using the above arguments\\n                IEnumerable<User> users = null;\\n\\n                var edges = users.Select(user => new Edge<User>(user, user.Id))\\n                                    .ToList();\\n                var pageInfo = new ConnectionPageInfo(false, false, null, null);\\n\\n                var connection = new Connection<User>(edges, pageInfo,\\n                                    ct => ValueTask.FromResult(0));\\n\\n                return connection;\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"If we need to work on an even lower level, we could also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor.AddPagingArguments()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor.Type<ConnectionType<UserType>>()\"), \" to get rid of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" middleware.\")), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"h2\", null, \"Total count\"), mdx(\"p\", null, \"Sometimes we might want to return the total number of pageable entries.\"), mdx(\"p\", null, \"For this to work we need to enable the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IncludeTotalCount\"), \" flag on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UsePaging\"), \" middleware.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UsePaging(IncludeTotalCount = true)]\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.UsePaging(options: new PagingOptions\\n{\\n    IncludeTotalCount = true\\n});\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"p\", null, \"This will add a new field called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" to our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connection\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type UserConnection {\\n  pageInfo: PageInfo!\\n  edges: [UserEdge!]\\n  nodes: [User!]\\n  totalCount: Int!\\n}\\n\")), mdx(\"p\", null, \"If our resolver returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" will be automatically computed, if it has been specified as a subfield in the query.\"), mdx(\"p\", null, \"If we have customized our pagination and our resolver now returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Connection<T>\"), \", we have to explicitly declare how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" value is computed.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var connection = new Connection<User>(\\n    edges,\\n    pageInfo,\\n    getTotalCount: cancellationToken => ValueTask.FromResult(0));\\n\")), mdx(\"h1\", null, \"Offset Pagination\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: While we support \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination, we highly encourage the use of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#connections\"\n  }), mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Connections\")), \" instead. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connections\"), \" provide an abstraction which makes it easier to switch to another pagination mechanism later on.\")), mdx(\"p\", null, \"Besides \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Connections\"), \" we can also expose a more traditional \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(skip: Int take: Int): UserCollectionSegment\\n}\\n\\ntype UserCollectionSegment {\\n  items: [User!]\\n  pageInfo: CollectionSegmentInfo!\\n}\\n\\ntype CollectionSegmentInfo {\\n  hasNextPage: Boolean!\\n  hasPreviousPage: Boolean!\\n}\\n\")), mdx(\"h2\", null, \"Usage\"), mdx(\"p\", null, \"To add \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination capabilties to our fields we have to add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" middleware.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseOffsetPaging]\\n    public IEnumerable<User> GetUsers([Service] IUserRespository repository)\\n        => repository.GetUsers();\\n}\\n\")), mdx(\"p\", null, \"If we need to specify the concrete node type of our pagination, we can do so by passing a Type as the constructor argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseOffsetPaging(typeof(User))]\"), \".\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" attribute also allows us to configure some other properties, like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultPageSize\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MaxPageSize\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IncludeTotalCount\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UseOffsetPaging(MaxPageSize = 50)]\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Field(\\\"users\\\")\\n            .UseOffsetPaging()\\n            .Resolve(context =>\\n            {\\n                var repository = context.Service<IUserRespository>();\\n\\n                return repository.GetUsers();\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"If we need to specify the concrete node type of our pagination, we can do so via the generic argument: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging<UserType>()\"), \".\"), mdx(\"p\", null, \"We can also configure the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" middleware further, by specifying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PagingOptions\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.UseOffsetPaging(options: new PagingOptions\\n{\\n    MaxPageSize = 50\\n});\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"p\", null, \"For the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" middleware to work, our resolver needs to return an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \". The middleware will then apply the pagination arguments to what we have returned. In the case of an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" this means that the pagination operations can be directly translated to native database queries, through database drivers like EntityFramework or the MongoDB client.\"), mdx(\"h2\", null, \"Customization\"), mdx(\"p\", null, \"If we need more control over the pagination process we can do so, by returning a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CollectionSegment<T>\"), \".\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseOffsetPaging]\\n    public CollectionSegment<User> GetUsers(int? skip, int? take, string sortBy)\\n    {\\n        /// get users using the above arguments\\n        IEnumerable<User> users = null;\\n\\n        var pageInfo = new CollectionSegmentInfo(false, false);\\n\\n        var collectionSegment = new CollectionSegment<User>(\\n            users,\\n            pageInfo,\\n            ct => ValueTask.FromResult(0));\\n\\n        return collectionSegment;\\n    }\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Field(\\\"users\\\")\\n            .UseOffsetPaging()\\n            .Argument(\\\"sortBy\\\", a => a.Type<NonNullType<StringType>>())\\n            .Resolve(context =>\\n            {\\n                var skip = context.ArgumentValue<int?>(\\\"skip\\\");\\n                var take = context.ArgumentValue<int?>(\\\"take\\\");\\n                var sortBy = context.ArgumentValue<string>(\\\"sortBy\\\");\\n\\n                // get users using the above arguments\\n                IEnumerable<User> users = null;\\n\\n                var pageInfo = new CollectionSegmentInfo(false, false);\\n\\n                var collectionSegment = new CollectionSegment<User>(\\n                    users,\\n                    pageInfo,\\n                    ct => ValueTask.FromResult(0));\\n\\n                return collectionSegment;\\n            });\\n    }\\n}\\n\")), mdx(\"p\", null, \"If we need to work on an even lower level, we could also use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor.AddOffsetPagingArguments()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"descriptor.Type<CollectionSegmentType<UserType>>()\"), \" to get rid of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" middleware.\")), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"h2\", null, \"Total count\"), mdx(\"p\", null, \"Sometimes we might want to return the total number of pageable entries.\"), mdx(\"p\", null, \"For this to work we need to enable the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IncludeTotalCount\"), \" flag on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseOffsetPaging\"), \" middleware.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UseOffsetPaging(IncludeTotalCount = true)]\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor.UseOffsetPaging(options: new PagingOptions\\n{\\n    IncludeTotalCount = true\\n});\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"\\u26A0\\uFE0F Schema-first does currently not support pagination!\"))), mdx(\"p\", null, \"This will add a new field called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" to our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"CollectionSegment\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type UserCollectionSegment {\\n  pageInfo: CollectionSegmentInfo!\\n  items: [User!]\\n  totalCount: Int!\\n}\\n\")), mdx(\"p\", null, \"If our resolver returns an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IEnumerable<T>\"), \" or an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \" the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" will be automatically computed, if it has been specified as a subfield in the query.\"), mdx(\"p\", null, \"If we have customized our pagination and our resolver now returns a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CollectionSegment<T>\"), \", we have to explicitly declare how the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"totalCount\"), \" value is computed.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var collectionSegment = new CollectionSegment<User>(\\n    items,\\n    pageInfo,\\n    getTotalCount: cancellationToken => ValueTask.FromResult(0));\\n\")), mdx(\"h1\", null, \"Pagination defaults\"), mdx(\"p\", null, \"If we want to enforce consistent pagination defaults throughout our app, we can do so, by setting the global \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"PagingOptions\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            // ...\\n            .SetPagingOptions(new PagingOptions\\n            {\\n                MaxPageSize = 50\\n            });\\n    }\\n}\\n\")), mdx(\"h1\", null, \"Types of pagination\"), mdx(\"p\", null, \"In this section we will look at the most common pagination approaches and their downsides. There are mainly two concepts we find today: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor-based\"), \" pagination.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note: This section is intended as a brief overview and should not be treated as a definitive guide or recommendation.\")), mdx(\"h2\", null, \"Offset Pagination\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Offset-based\"), \" pagination is found in many server implementations whether the backend is implemented in SOAP, REST or GraphQL.\"), mdx(\"p\", null, \"It is so common, since it is the simplest form of pagination we can implement. All it requires is an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"offset\"), \" (start index) and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"limit\"), \" (number of entries) argument.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT * FROM Users\\nORDER BY Id\\nLIMIT %limit OFFSET %offset\\n\")), mdx(\"h3\", null, \"Problems\"), mdx(\"p\", null, \"But whilst \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination is simple to implement and works relatively well, there are also some problems:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OFFSET\"), \" on the database-side does not scale well for large datasets. Most databases work with an index instead of numbered rows. This means the database always has to count \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset + limit\"), \" rows, before discarding the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset\"), \" and only returning the requested number of rows.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"If new entries are written to or removed from our database at high frequency, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset\"), \" becomes unreliable, potentially skipping or returning duplicate entries.\"))), mdx(\"h2\", null, \"Cursor Pagination\"), mdx(\"p\", null, \"Contrary to the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination, where we identify the position of an entry using an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset\"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor-based\"), \" pagination works by returning the pointer to the next entry in our pagination.\"), mdx(\"p\", null, \"To understand this concept better, let's look at an example: We want to paginate over the users in our application.\"), mdx(\"p\", null, \"First we execute the following to receive our first page:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT * FROM Users\\nORDER BY Id\\nLIMIT %limit\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"%limit\"), \" is actually \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"limit + 1\"), \". We are doing this to know wether there are more entries in our dataset and to receive the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \" of the next entry (in this case its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Id\"), \"). This additional entry will not be returned to the consumer of our pagination.\"), mdx(\"p\", null, \"To now receive the second page, we execute:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT * FROM Users\\nWHERE Id >= %cursor\\nORDER BY Id\\nLIMIT %limit\\n\")), mdx(\"p\", null, \"Using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OFFSET\"), \" is great, since now we can leverage the index of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Id\"), \" field and the database does not have to compute an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset\"), \".\"), mdx(\"p\", null, \"For this to work though, our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \" needs to be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"unique\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sequential\"), \". Most of the time the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Id\"), \" field will be the best fit.\"), mdx(\"p\", null, \"But what if we need to sort by a field that does not have the aforementioned properties? We can simply combine the field with another field, which has the needed properties (like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Id\"), \"), to form a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \".\"), mdx(\"p\", null, \"Let's look at another example: We want to paginate over the users sorted by their birthday.\"), mdx(\"p\", null, \"After receiving the first page, we create a combined \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \", like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"1435+2020-12-31\\\"\"), \" (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Id\"), \" + \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Birthday\"), \"), of the next entry. To receive the second page, we convert the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor\"), \" to its original values (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Id\"), \" + \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Birthday\"), \") and use them in our query:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT * FROM Users\\nWHERE (Birthday >= %cursorBirthday\\nOR (Birthday = %cursorBirthday AND Id >= %cursorId))\\nORDER BY Birthday, Id\\nLIMIT %limit\\n\")), mdx(\"h3\", null, \"Problems\"), mdx(\"p\", null, \"Even though \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"cursor-based\"), \" pagination can be more performant than \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"offset-based\"), \" pagination, it comes with some downsides as well:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WHERE\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ORDER BY\"), \" on a field without an index, it can be slower than using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ORDER BY\"), \" with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"OFFSET\"), \".\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Since we now only know of the next entry, there is no more concept of pages. If we have a feed or only \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Next\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Previous\"), \" buttons, this works great, but if we depend on page numbers, we are in a tight spot.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#connections","title":"Connections","items":[{"url":"#usage","title":"Usage"},{"url":"#customization","title":"Customization"},{"url":"#total-count","title":"Total count"}]},{"url":"#offset-pagination","title":"Offset Pagination","items":[{"url":"#usage-1","title":"Usage"},{"url":"#customization-1","title":"Customization"},{"url":"#total-count-1","title":"Total count"}]},{"url":"#pagination-defaults","title":"Pagination defaults"},{"url":"#types-of-pagination","title":"Types of pagination","items":[{"url":"#offset-pagination-1","title":"Offset Pagination"},{"url":"#cursor-pagination","title":"Cursor Pagination"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"coding-approaches","title":"Coding Approaches"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/fetching-data/pagination.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}