{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/fetching-data/projections","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/fetching-data/projections/"},"frontmatter":{"title":"Projections"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Projections\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Every GraphQL request specifies exactly what data should be returned. Over or under fetching can be reduced\\nor even eliminated. HotChocolate projections leverage this concept and directly projects incoming queries\\nto the database.\"), mdx(\"p\", null, \"Projections operate on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" by default, but it is possible to create custom providers for projections\\nto support a specific database driver.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users {\\n    email\\n    address {\\n      street\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT \\\"u\\\".\\\"Email\\\", \\\"a\\\".\\\"Id\\\" IS NOT NULL, \\\"a\\\".\\\"Street\\\"\\nFROM \\\"Users\\\" AS \\\"u\\\"\\nLEFT JOIN \\\"Address\\\" AS \\\"a\\\" ON \\\"u\\\".\\\"AddressId\\\" = \\\"a\\\".\\\"Id\\\"\\n\")), mdx(\"h1\", null, \"Getting Started\"), mdx(\"p\", null, \"Filtering is part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Data\"), \" package. You can add the dependency with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" cli\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"  dotnet add package HotChocolate.Data\\n\")), mdx(\"p\", null, \"To use projections with your GraphQL endpoint you have to register projections on the schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQLServer()\\n  // Your schmea configuration\\n  .AddProjections();\\n\")), mdx(\"p\", null, \"Projections can be registered on a field. A middleware will apply the selected fields on the result.\\nSupport for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \" comes out of the box.\\nThe projection middleware will create a projection for the whole subtree of its field. Only fields that\\nare members of a type will be projected. Fields that define a customer resolver cannot be projected\\nto the database. If the middleware encounters a field that specifies \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseProjection()\"), \" this field will be skipped.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u26A0\\uFE0F \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" If you use more than middleware, keep in mind that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ORDER MATTERS\"), \". The correct order is UsePaging > UseProjection > UseFiltering > UseSorting\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType\\n    : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor.Field(t => t.GetPersons(default)).UseProjection();\\n    }\\n}\\n\\npublic class Query\\n{\\n    public IQueryable<Person> GetPersons([Service]IPersonRepository repository) =>\\n        repository.GetPersons();\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pure Code First\")), mdx(\"p\", null, \"The field descriptor attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseProjection]\"), \" does apply the extension method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseProjection()\"), \" on the field descriptor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UseProjection]\\n    public IQueryable<Person> GetPersons([Service]IPersonRepository repository)\\n    {\\n        repository.GetPersons();\\n    }\\n}\\n\")), mdx(\"h1\", null, \"FirstOrDefault / SingleOrDefault\"), mdx(\"p\", null, \"If you want to limit the response to a single result, you would have to declare a resolver.\\nWithout returning an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<>\"), \" you lose the ability to use filtering.\"), mdx(\"p\", null, \"There are two extensions you can use to leverage \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"collection.FirstOrDefault()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".collection.SingleOrDefault()\"), \" to\\nthe GraphQL layer. The extensions will rewrite the response type to the element type of the collection apply the behavior.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public class Query\\n    {\\n        [UseFirstOrDefault]\\n        [UseProjection]\\n        [UseFiltering]\\n        public IQueryable<User> GetUsers([ScopedService] SomeDbContext someDbContext)\\n        {\\n            return someDbContext.Users;\\n        }\\n    }\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  users(where: UserFilterInput): User\\n}\\n\\ntype User {\\n  id: Int!\\n  name: String!\\n  email: String!\\n}\\n\")), mdx(\"h1\", null, \"Sorting Filtering and Paging\"), mdx(\"p\", null, \"Projections can be used together with sorting, filtering and paging. The order of the middlewares must be correct.\\nMake sure to have the following order: UsePaging > UseProjection > UseFiltering > UseSorting\"), mdx(\"p\", null, \"Filtering and sorting can be projected over relations. Projections \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"cannot\"), \" project paging over relations.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    [UsePaging]\\n    [UseProjection]\\n    [UseFiltering]\\n    [UseSorting]\\n    public IQueryable<User> GetUsers([ScopedService] SomeDbContext someDbContext)\\n    {\\n        return someDbContext.Users;\\n    }\\n}\\n\\npublic class User\\n{\\n    public int Id { get; set; }\\n\\n    public string Name { get; set; }\\n\\n    public string Email { get; set; }\\n\\n    [UseFiltering]\\n    [UseSorting]\\n    public ICollection<Address> Addresses { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users(\\n    where: { name: { eq: \\\"ChilliCream\\\" } }\\n    order: [{ name: DESC }, { email: DESC }]\\n  ) {\\n    nodes {\\n      email\\n      addresses(where: { street: { eq: \\\"Sesame Street\\\" } }) {\\n        street\\n      }\\n    }\\n    pageInfo {\\n      endCursor\\n      hasNextPage\\n      hasPreviousPage\\n      startCursor\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT \\\"t\\\".\\\"Email\\\", \\\"t\\\".\\\"Id\\\", \\\"a\\\".\\\"Street\\\", \\\"a\\\".\\\"Id\\\"\\nFROM (\\n    SELECT \\\"u\\\".\\\"Email\\\", \\\"u\\\".\\\"Id\\\", \\\"u\\\".\\\"Name\\\"\\n    FROM \\\"Users\\\" AS \\\"u\\\"\\n    WHERE \\\"u\\\".\\\"Name\\\" = @__p_0\\n    ORDER BY \\\"u\\\".\\\"Name\\\" DESC, \\\"u\\\".\\\"Email\\\" DESC\\n    LIMIT @__p_1\\n) AS \\\"t\\\"\\nLEFT JOIN \\\"Address\\\" AS \\\"a\\\" ON \\\"t\\\".\\\"Id\\\" = \\\"a\\\".\\\"UserId\\\"\\nORDER BY \\\"t\\\".\\\"Name\\\" DESC, \\\"t\\\".\\\"Email\\\" DESC, \\\"t\\\".\\\"Id\\\", \\\"a\\\".\\\"Id\\\"\\n\")), mdx(\"h1\", null, \"Always Project Fields\"), mdx(\"p\", null, \"Resolvers on types often access data of the parent. e.g. uses the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Email\"), \" member of the parent to fetch some\\nrelated data from another service. With projections, this resolver could only work when the user also queries\\nfor the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"email\"), \" field. To ensure a field is always projected you have to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IsProjected(true)\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserType : ObjectType<User>\\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.Feild(x => x.Email).IsProjected(true);\\n        descriptor.Field(\\\"messages\\\")\\n            .Type<MessageType>()\\n            .Resolver(\\n                async ctx =>\\n                {\\n                    var dataloader = ctx.DataLoader<MessageDataLoader>();\\n                    var mail = ctx.Parent<User>().Email;\\n                    return await dataloader.LoadAsync(\\n                        mail,\\n                        ctx.RequestAborted);\\n                });\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pure Code First\")), mdx(\"p\", null, \"The field descriptor attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[IsProjected]\"), \" does apply the extension method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IsProjected()\"), \" on the field descriptor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n    [IsProjected(true)]\\n    public string Email { get; set; }\\n    public Address Address { get; set; }\\n}\\n\\n[ExtendObjectType(nameof(User))]\\npublic class UserTypeExtension\\n{\\n    public Message GetMessagesAsync(\\n        [Parent] User user,\\n        MessageDataLoader dataloader,\\n        CancellationToken cancellationToken) =>\\n        dataloader.LoadAsync(user.Email, cancellationToken);\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users {\\n    address {\\n      street\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT \\\"u\\\".\\\"Email\\\", \\\"a\\\".\\\"Id\\\" IS NOT NULL, \\\"a\\\".\\\"Street\\\"\\nFROM \\\"Users\\\" AS \\\"u\\\"\\nLEFT JOIN \\\"Address\\\" AS \\\"a\\\" ON \\\"u\\\".\\\"AddressId\\\" = \\\"a\\\".\\\"Id\\\"\\n\")), mdx(\"h1\", null, \"Exclude fields\"), mdx(\"p\", null, \"If a projected field is requested, the whole subtree is processed. Sometimes you want to opt out of projections.\\nThe projections middleware skips a field in two cases. Either the visitor encounters a fields that is a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseProjection\"), \" field\\nitself, or it defines \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IsProjected(false)\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserType : ObjectType<User>\\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.Field(x => x.Email).IsProjected(false);\\n    }\\n}\\n\\n\\npublic class User\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n    public string Email { get; set; }\\n    public Address Address { get; set; }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Pure Code First\")), mdx(\"p\", null, \"The field descriptor attribute \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[UseProjection]\"), \" does apply the extension method \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseProjection()\"), \" on the field descriptor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User\\n{\\n    public int Id { get; set; }\\n    public string Name { get; set; }\\n    [IsProjected(false)]\\n    public string Email { get; set; }\\n    public Address Address { get; set; }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  users {\\n    email\\n    address {\\n      street\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT \\\"a\\\".\\\"Id\\\" IS NOT NULL, \\\"a\\\".\\\"Street\\\"\\nFROM \\\"Users\\\" AS \\\"u\\\"\\nLEFT JOIN \\\"Address\\\" AS \\\"a\\\" ON \\\"u\\\".\\\"AddressId\\\" = \\\"a\\\".\\\"Id\\\"\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#getting-started","title":"Getting Started"},{"url":"#firstordefault--singleordefault","title":"FirstOrDefault / SingleOrDefault"},{"url":"#sorting-filtering-and-paging","title":"Sorting Filtering and Paging"},{"url":"#always-project-fields","title":"Always Project Fields"},{"url":"#exclude-fields","title":"Exclude fields"}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/fetching-data/projections.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}