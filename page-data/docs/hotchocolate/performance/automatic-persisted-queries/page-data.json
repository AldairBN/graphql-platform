{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/performance/automatic-persisted-queries","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/performance/automatic-persisted-queries/"},"frontmatter":{"title":"Automatic persisted queries"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Automatic persisted queries\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This guide will walk you through how automatic persisted queries work and how you can set them up with the Hot Chocolate GraphQL server.\"), mdx(\"h1\", null, \"How it works\"), mdx(\"p\", null, \"The automatic persisted queries protocol was originally specified by Apollo and represent an evolution of the persisted query feature that many GraphQL servers implement. Instead of storing persisted queries ahead of time, the client can store queries dynamically. This preserves the original proposal's performance benefits but removes the friction of setting up build processes that post-process the client applications source code.\"), mdx(\"p\", null, \"When the client makes a request to the server, it will optimistically send a short cryptographic hash instead of the full query text.\"), mdx(\"h2\", null, \"Optimized Path\"), mdx(\"p\", null, \"Hot Chocolate server will inspect the incoming request for a query id or a full GraphQL query. If the request has only a query id the execution engine will first try to resolve the full query from the query storage. If the query storage contains a query that matches the provided query id, the request will be upgraded to a fully valid GraphQL request and will be executed.\"), mdx(\"h2\", null, \"New Query Path\"), mdx(\"p\", null, \"If the query storage does not contain a query that matches the sent query id, the Hot Chocolate server will return an error result that indicates that the query was not found (this will only happen the first time a client asks for a certain query). The client application will then send in a second request with the specified query id and the complete GraphQL query. This will trigger Hot Chocolate server to store this new query in its query storage and, at the same time, execute the query and returning the result.\"), mdx(\"h1\", null, \"Setup\"), mdx(\"p\", null, \"In the following tutorial, we will walk you through creating a Hot Chocolate GraphQL server and configuring it to support automatic persisted queries.\"), mdx(\"h2\", null, \"Step 1: Create a GraphQL server project\"), mdx(\"p\", null, \"Open your preferred terminal and select a directory where you want to add the code of this tutorial.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Install the Hot Chocolate GraphQL server template.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet new -i HotChocolate.Templates.Server\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Create a new Hot Chocolate GraphQL server project.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet new graphql\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add the in-memory query storage to your project.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet add package HotChocolate.PersistedQueries.InMemory\\n\")), mdx(\"h2\", null, \"Step 2: Configure automatic persisted queries\"), mdx(\"p\", null, \"Next, we want to configure our GraphQL server to be able to handle automatic persisted query requests. For this, we need to register the in-memory query storage and configure the automatic persisted query request pipeline.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Configure GraphQL server to use the automatic persisted query pipeline.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .UseAutomaticPersistedQueryPipeline();\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next, register the in-memory query storage.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .UseAutomaticPersistedQueryPipeline()\\n        .AddInMemoryQueryStorage();\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Last but not least, we need to add the Microsoft Memory Cache, which the in-memory query storage will use as the in-memory key-value store.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        // Global Services\\n        .AddRouting()\\n        .AddMemoryCache()\\n\\n        // GraphQL server configuration\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .UseAutomaticPersistedQueryPipeline()\\n        .AddInMemoryQueryStorage();\\n}\\n\")), mdx(\"h2\", null, \"Step 3: Verify server setup\"), mdx(\"p\", null, \"Now that our server is set up with automatic persisted queries, let us verify that it works as expected. We can do that by just using our console and a tool called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"curl\"), \". For our example, we will use a dummy query \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{__typename}\"), \" with an MD5 hash serialized to base64 as a query id \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"71yeex4k3iYWQgg9TilDIg==\"), \". We will test the full automatic persisted query flow and walk you through the responses.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start the GraphQL server.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet run\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"First, we will ask our GraphQL server to execute our query with the optimized request containing only the query hash. At this point, the server will not know this query and hast to return an error indicating this.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"md5Hash\\\":\\\"71yeex4k3iYWQgg9TilDIg==\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"p\", null, \"The response indicates, as expected, that this query is unknown so far.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"errors\\\": [\\n    {\\n      \\\"message\\\": \\\"PersistedQueryNotFound\\\",\\n      \\\"extensions\\\": { \\\"code\\\": \\\"HC0020\\\" }\\n    }\\n  ]\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next, we want to store our dummy query on the server. We will send in the hash as before but now also provide the query parameter with the full GraphQL query string.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?query={__typename}&extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"md5Hash\\\":\\\"71yeex4k3iYWQgg9TilDIg==\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"p\", null, \"Our GraphQL server will respond with the query result and indicate that the query was stored on the server \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"persisted\\\": true\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": { \\\"__typename\\\": \\\"Query\\\" },\\n  \\\"extensions\\\": {\\n    \\\"persistedQuery\\\": {\\n      \\\"md5Hash\\\": \\\"71yeex4k3iYWQgg9TilDIg==\\\",\\n      \\\"persisted\\\": true\\n    }\\n  }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Last but not least, we will verify that we can now use our optimized request by executing our initial request containing only the query hash.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"md5Hash\\\":\\\"71yeex4k3iYWQgg9TilDIg==\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"p\", null, \"This time the server knows the query and will respond with the simple result of this query.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{ \\\"data\\\": { \\\"__typename\\\": \\\"Query\\\" } }\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"In this example, we used GraphQL HTTP GET requests, which are also useful in caching scenarios with CDNs. But the automatic persisted query flow can also be used with GraphQL HTTP POST requests.\")), mdx(\"h2\", null, \"Step 4: Configure the hashing algorithm\"), mdx(\"p\", null, \"Hot Chocolate server is configured to use by default the MD5 hashing algorithm, which is serialized to a base64 string. Hot Chocolate server comes out of the box with support for MD5, SHA1, and SHA256 and can serialize the hash to base64 or hex. In this step, we will walk you through changing the hashing algorithm to SHA256 with a hex serialization.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add the SHA256 document hash provider to your Hot Chocolate GraphQL server's global services.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        // Global Services\\n        .AddRouting()\\n        .AddMemoryCache()\\n        .AddSha256DocumentHashProvider(HashFormat.Hex)\\n\\n        // GraphQL server configuration\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .UseAutomaticPersistedQueryPipeline()\\n        .AddInMemoryQueryStorage();\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start the GraphQL server.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet run\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next, let us verify that our server now operates with the new hash provider and the new hash serialization format. For this we will store again a query on the server, but this time our hash string will look like the following: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\"), \".\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?query={__typename}&extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"sha256Hash\\\":\\\"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": { \\\"__typename\\\": \\\"Query\\\" },\\n  \\\"extensions\\\": {\\n    \\\"persistedQuery\\\": {\\n      \\\"sha256Hash\\\": \\\"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\\\",\\n      \\\"persisted\\\": true\\n    }\\n  }\\n}\\n\")), mdx(\"h2\", null, \"Step 4: Use Redis as a query storage\"), mdx(\"p\", null, \"If you run multiple Hot Chocolate server instances and want to preserve stored queries after a server restart, you can opt to use a file system based query storage or opt to use a Redis cache. Hot Chocolate server supports both.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Setup a Redis docker container.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"docker run --name redis-stitching -p 7000:6379 -d redis\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add the Redis persisted query storage package to your server.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet add package HotChocolate.PersistedQueries.Redis\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Next, we need to configure the server to use Redis as query storage.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        // Global Services\\n        .AddRouting()\\n        .AddSha256DocumentHashProvider(HashFormat.Hex)\\n\\n        // GraphQL server configuration\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .UseAutomaticPersistedQueryPipeline()\\n        .AddRedisQueryStorage(services => ConnectionMultiplexer.Connect(\\\"localhost:7000\\\").GetDatabase());\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Start the GraphQL server.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet run\\n\")), mdx(\"ol\", {\n    \"start\": 5\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Now, let us verify again if our server works correctly by storing our query first.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?query={__typename}&extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"sha256Hash\\\":\\\"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": { \\\"__typename\\\": \\\"Query\\\" },\\n  \\\"extensions\\\": {\\n    \\\"persistedQuery\\\": {\\n      \\\"sha256Hash\\\": \\\"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\\\",\\n      \\\"persisted\\\": true\\n    }\\n  }\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 6\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Stop your GraphQL server.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Start your GraphQL server again.\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet run\\n\")), mdx(\"ol\", {\n    \"start\": 8\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Let us execute the optimized query to see if our query was correctly stored on our Redis cache.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Request\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"curl -g 'http://localhost:5000/graphql/?extensions={\\\"persistedQuery\\\":{\\\"version\\\":1,\\\"sha256Hash\\\":\\\"7f56e67dd21ab3f30d1ff8b7bed08893f0a0db86449836189b361dd1e56ddb4b\\\"}}'\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Response\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{ \\\"data\\\": { \\\"__typename\\\": \\\"Query\\\" } }\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#how-it-works","title":"How it works","items":[{"url":"#optimized-path","title":"Optimized Path"},{"url":"#new-query-path","title":"New Query Path"}]},{"url":"#setup","title":"Setup","items":[{"url":"#step-1-create-a-graphql-server-project","title":"Step 1: Create a GraphQL server project"},{"url":"#step-2-configure-automatic-persisted-queries","title":"Step 2: Configure automatic persisted queries"},{"url":"#step-3-verify-server-setup","title":"Step 3: Verify server setup"},{"url":"#step-4-configure-the-hashing-algorithm","title":"Step 4: Configure the hashing algorithm"},{"url":"#step-4-use-redis-as-a-query-storage","title":"Step 4: Use Redis as a query storage"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/zt-lqkb8z7b-aFepT0Qrsgv5_yKy0yoyzw"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/performance/automatic-persisted-queries.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}