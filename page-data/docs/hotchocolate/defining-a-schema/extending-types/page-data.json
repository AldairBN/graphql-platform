{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/defining-a-schema/extending-types","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/defining-a-schema/extending-types/"},"frontmatter":{"title":"Extending Types"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Extending Types\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In GraphQL we only have one query, mutation, and subscription type. These types can become huge, which makes them hard to maintain. To divide types into separate definitions, GraphQL allows to extend types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  foo: String\\n}\\n\\nextend type Query {\\n  bar: String\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" Every single code example will be shown in three different approaches, annotation-based (previously known as pure code-first), code-first, and schema-first. However, they will always result in the same outcome on a GraphQL schema perspective and internally in Hot Chocolate. All three approaches have their pros and cons and can be combined when needed with each other. If you would like to learn more about the three approaches in Hot Chocolate, click on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/docs/hotchocolate/api-reference/coding-approaches\"\n  }), \"Coding Approaches\"), \".\")), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public string GetFoo() => ...\\n}\\n\\n[ExtendObjectType(typeof(Query))]\\npublic class QueryExtensions\\n{\\n    public string GetBar() => ...\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class QueryType : ObjectType<Query>\\n{\\n}\\n\\npublic class QueryTypeExtension : ObjectTypeExtension<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Query\\\")\\n    }\\n}\\n\\npublic class Query\\n{\\n    public string GetFoo() => ...\\n}\\n\\npublic class QueryExtensions\\n{\\n    public string GetBar() => ...\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  foo: String\\n}\\n\\nextend type Query {\\n  bar: String\\n}\\n\")))), mdx(\"h1\", null, \"Extending types with the annotation-based approach\"), mdx(\"p\", null, \"Extending types can be beneficial even with non-root types. Let's say we are building a schema with the annotation-based approach where we use pure C# to describe our types.\"), mdx(\"p\", null, \"Given is the following entity that we do want to extend in our graph with additional fields.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Session\\n{\\n    public int Id { get; set; }\\n\\n    [Required]\\n    [StringLength(200)]\\n    public string? Title { get; set; }\\n\\n    [StringLength(4000)]\\n    public string? Abstract { get; set; }\\n\\n    public int? TrackId { get; set; }\\n}\\n\")), mdx(\"h2\", null, \"Replace a field\"), mdx(\"p\", null, \"We could start adding our GraphQL concerns to this type directly. But often, we want to keep our entity clean from any graph concerns.\"), mdx(\"p\", null, \"To replace the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TrackId\"), \" with a field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Track\"), \" that returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Tack\"), \" object we could do the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(typeof(Session))]\\npublic class SessionResolvers\\n{\\n    [BindProperty(nameof(Session.TrackId))]\\n    public async Task<Track> GetTrackAsync([Parent] Session session) => ...\\n}\\n\")), mdx(\"h2\", null, \"Remove a field\"), mdx(\"p\", null, \"We also easily can remove properties that we do not like on our initial type. For instance, let us omit the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Abstract\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(\\n    typeof(Session),\\n    IgnoreProperties = new[] { nameof(Session.Abstract) })]\\npublic class SessionResolvers\\n{\\n}\\n\")), mdx(\"h2\", null, \"Add a field\"), mdx(\"p\", null, \"Further, might we want to be able to add new fields to our entity.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(typeof(Session))]\\npublic class SessionResolvers\\n{\\n    public async Task<IEnumerable<Speaker>> GetSpeakersAsync([Parent] Session session) => ...\\n}\\n\")), mdx(\"h2\", null, \"Select types to extend\"), mdx(\"p\", null, \"Moreover, we can extend multiple types at once by extending upon base types or interfaces.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(typeof(object))] // <-- we are now extending every type that inherits from object (essentially every type).\\npublic class SessionResolvers\\n{\\n    public string SayHello() => \\\"Hello\\\";\\n}\\n\")), mdx(\"p\", null, \"We can also extend multiple types at once with a type but dedicate specific resolvers to specific types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(typeof(object))] // <-- we are now extending every type that inherits from object (essentially every type)\\npublic class SessionResolvers\\n{\\n    public string Abc([Parent] Session session) => \\\"abc\\\"; // <-- we are only adding this field to the Session type\\n\\n    public string Def([Parent] Track track) => \\\"def\\\"; // <-- we are only adding this field to the Track type\\n}\\n\")), mdx(\"p\", null, \"Instead of using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"typeof(object)\"), \" as a selector for extending types you can also use interfaces or other base types.\"), mdx(\"h2\", null, \"Select types to extend with schema types\"), mdx(\"p\", null, \"We also can use schema types as a type selector.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[ExtendObjectType(typeof(ObjectType))] // <-- we are now extending every object type.\\npublic class SessionResolvers\\n{\\n    public string Abc([Parent] Session session) => \\\"abc\\\"; // <-- we are only adding this field to the Session type\\n\\n    public string Def([Parent] Track track) => \\\"def\\\"; // <-- we are only adding this field to the Track type\\n}\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Note, that all of the advanced type extension methods are also possible with code-first.\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#extending-types-with-the-annotation-based-approach","title":"Extending types with the annotation-based approach","items":[{"url":"#replace-a-field","title":"Replace a field"},{"url":"#remove-a-field","title":"Remove a field"},{"url":"#add-a-field","title":"Add a field"},{"url":"#select-types-to-extend","title":"Select types to extend"},{"url":"#select-types-to-extend-with-schema-types","title":"Select types to extend with schema types"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/defining-a-schema/extending-types.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}