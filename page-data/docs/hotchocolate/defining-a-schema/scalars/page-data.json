{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/defining-a-schema/scalars","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/defining-a-schema/scalars/"},"frontmatter":{"title":"Scalars"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Scalars\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A GraphQL schema should be built as expressive as possible.\\nJust from looking at the schema, a developer should know how to use the API.\\nIn GraphQL you are not limited to only describing the structure of a type, you can even describe value types.\\nScalar types represent types that can hold data of a specific kind.\\nScalars are leaf types, meaning you cannot use e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"{ fieldname }\"), \" to further drill down into the type.\"), mdx(\"p\", null, \"A scalar must only know how to serialize and deserialize the value of the field.\\nGraphQL gives you the freedom to define custom scalar types.\\nThis makes them the perfect tool for expressive value types.\\nYou could create a scalar for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreditCardNumber\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NonEmptyString\"), \".\"), mdx(\"p\", null, \"The GraphQL specification defines the following scalars\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Type\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Description\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Int\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Signed 32-bit numeric non-fractional value\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Float\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Double-precision fractional values as specified by IEEE 754\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"String\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"UTF-8 character sequences\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"Boolean\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Boolean type representing true or false\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), mdx(\"inlineCode\", {\n    parentName: \"td\"\n  }, \"ID\")), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Unique identifier\")))), mdx(\"p\", null, \"In addition to the scalars defined by the specification, HotChocolate also supports the following set of scalar types:\\n| Type        | Description                                                 |\\n| ----------- | ----------------------------------------------------------- |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Byte\"), \"      |                                                             |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ByteArray\"), \" | Base64 encoded array of bytes                               |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Short\"), \"     | Signed 16-bit numeric non-fractional value                  |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Long\"), \"      | Signed 64-bit numeric non-fractional value                  |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Decimal\"), \"   | .NET Floating Point Type                                    |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Url\"), \"       | Url                                                         |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \"  | ISO-8601 date time                                          |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Date\"), \"      | ISO-8601 date                                               |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Uuid\"), \"      | GUID                                                        |\\n| \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \"       | This type can be anything, string, int, list or object etc. |\"), mdx(\"h1\", null, \"Using Scalars\"), mdx(\"p\", null, \"HotChocolate will automatically detect which scalars are in use and will only expose those in the introspection. This keeps the schema definition small, simple and clean.\"), mdx(\"p\", null, \"The schema discovers .NET types and binds the matching scalar to the type.\\nHotChocolate, for example, automatically binds the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringType\"), \" on a member of the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.String\"), \".\\nYou can override these mappings by explicitly specifying type bindings on the request executor builder.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .BindRuntimeType<string, StringType>()\\n        .AddQueryType<Query>();\\n}\\n\")), mdx(\"p\", null, \"Furthermore, you can also bind scalars to arrays or type structures:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .BindRuntimeType<byte[], ByteArrayType>()\\n        .AddQueryType<Query>();\\n}\\n\")), mdx(\"h1\", null, \"Any Type\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" scalar is a special type that can be compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" in C#.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" allows us to specify any literal or return any output type.\"), mdx(\"p\", null, \"Consider the following type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Query {\\n  foo(bar: Any): String\\n}\\n\")), mdx(\"p\", null, \"Since our field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" specifies an argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar\"), \" of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" all of the following queries would be valid:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a: foo(bar: 1)\\n  b: foo(bar: [1, 2, 3, 4, 5])\\n  a: foo(bar: \\\"abcdef\\\")\\n  a: foo(bar: true)\\n  a: foo(bar: { a: \\\"foo\\\", b: { c: 1 } })\\n  a: foo(bar: [{ a: \\\"foo\\\", b: { c: 1 } }, { a: \\\"foo\\\", b: { c: 1 } }])\\n}\\n\")), mdx(\"p\", null, \"The same goes for the output side. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Any\"), \" can return a structure of data although it is a scalar type.\"), mdx(\"p\", null, \"If you want to access the data you can either fetch data as an object or you can ask the context to provide it as a specific object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"Foo foo = context.Argument<Foo>(\\\"bar\\\");\\n\")), mdx(\"p\", null, \"We can also ask the context which kind the current argument is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"ValueKind kind = context.ArgumentKind(\\\"bar\\\");\\n\")), mdx(\"p\", null, \"The value kind will tell us by which kind of literal the argument is represented.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"An integer literal can still contain a long value and a float literal could be a decimal but it also could just be a float.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public enum ValueKind\\n{\\n    String,\\n    Integer,\\n    Float,\\n    Boolean,\\n    Enum,\\n    Object,\\n    Null\\n}\\n\")), mdx(\"p\", null, \"If you want to access an object dynamically without serializing it to a strongly typed model you can get it as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyDictionary<string, object>\"), \" or as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectValueNode\"), \".\"), mdx(\"p\", null, \"Lists can be accessed generically by getting them as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IReadOnlyList<object>\"), \" or as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ListValueNode\"), \".\"), mdx(\"h1\", null, \"Custom Converter\"), mdx(\"p\", null, \"HotChocolate converts .Net types to match the types supported by the scalar of the field.\\nBy default, all standard .Net types have converters registered.\\nYou can register converters and reuse the built-in scalar types.\\nIn case you use a non-standard library, e.g. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nodatime.org/\"\n  }), \"NodeTime\"), \", you can register a converter and use the standard \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTimeType\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query \\n{\\n    public OffsetDateTime GetDateTime(OffsetDateTime offsetDateTime)\\n    {\\n        return offsetDateTime;\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Startup\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddGraphQLServer()\\n        .AddQueryType<Query>()\\n        .BindRuntimeType<OffsetDateTime, DateTimeType>()\\n        .AddTypeConverter<OffsetDateTime, DateTimeOffset>(\\n            x => x.ToDateTimeOffset())\\n        .AddTypeConverter<DateTimeOffset, OffsetDateTime>(\\n            x => OffsetDateTime.FromDateTimeOffset(x));\\n}\\n\")), mdx(\"h1\", null, \"Custom Scalars\"), mdx(\"p\", null, \"All scalars in HotChocolate are defined though a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScalarType\"), \"\\nThe easiest way to create a custom scalar is to extend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScalarType<TRuntimeType, TLiteral>\"), \".\\nThis base class already includes basic serialization and parsing logic.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public sealed class CreditCardNumberType\\n    : ScalarType<string, StringValueNode>\\n{\\n    private readonly ICreditCardValidator _validator;\\n\\n    /// Like all type system objects, Scalars have support for dependency injection\\n    public CreditCardNumberType(ICreditCardValidator validator)\\n        : base(\\\"CreditCardNumber\\\")\\n    {\\n        _validator = validator;\\n        Description = \\\"Represents a credit card number in the format of XXXX XXXX XXXX XXXX\\\";\\n    }\\n\\n    /// <summary>\\n    /// Checks if a incoming StringValueNode is valid. In this case the string value is only\\n    /// valid if it passes the credit card validation\\n    /// </summary>\\n    /// <param name=\\\"valueSyntax\\\">The valueSyntax to validate</param>\\n    /// <returns>true if the value syntax holds a valid credit card number</returns>\\n    protected override bool IsInstanceOfType(StringValueNode valueSyntax)\\n    {\\n        return _validator.ValidateCreditCard(valueSyntax.Value);\\n    }\\n\\n    /// <summary>\\n    /// Checks if a incoming string is valid. In this case the string value is only\\n    /// valid if it passes the credit card validation\\n    /// </summary>\\n    /// <param name=\\\"runtimeValue\\\">The valueSyntax to validate</param>\\n    /// <returns>true if the value syntax holds a valid credit card number</returns>\\n    protected override bool IsInstanceOfType(string runtimeValue)\\n    {\\n        return _validator.ValidateCreditCard(runtimeValue);\\n    }\\n\\n    /// <summary>\\n    /// Converts a StringValueNode to a string\\n    /// </summary>\\n    protected override string ParseLiteral(StringValueNode valueSyntax) =>\\n        valueSyntax.Value;\\n\\n    /// <summary>\\n    /// Converts a string to a StringValueNode\\n    /// </summary>\\n    protected override StringValueNode ParseValue(string runtimeValue) =>\\n        new StringValueNode(runtimeValue);\\n\\n    /// <summary>\\n    /// Parses a result value of this into a GraphQL value syntax representation.\\n    /// In this case this is just ParseValue\\n    /// </summary>\\n    public override IValueNode ParseResult(object? resultValue) =>\\n        ParseValue(resultValue);\\n}\\n\")), mdx(\"p\", null, \"By extending \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScalarType\"), \" you have full control over serialization and parsing.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    public sealed class CreditCardNumberType\\n        : ScalarType\\n    {\\n        private readonly ICreditCardValidator _validator;\\n\\n        /// Like all type system objects, Scalars have support for dependency injection\\n        public CreditCardNumberType(ICreditCardValidator validator)\\n            : base(\\\"CreditCardNumber\\\")\\n        {\\n            _validator = validator;\\n            Description = \\\"Represents a credit card number in the format of XXXX XXXX XXXX XXXX\\\";\\n        }\\n\\n        // define which .NET type represents your type\\n        public override Type RuntimeType { get; } = typeof(string);\\n\\n        // define which literals this type can be parsed from.\\n        public override bool IsInstanceOfType(IValueNode valueSyntax)\\n        {\\n            if (valueSyntax == null)\\n            {\\n                throw new ArgumentNullException(nameof(valueSyntax));\\n            }\\n\\n            return valueSyntax is StringValueNode stringValueNode &&\\n                _validator.ValidateCreditCard(stringValueNode.Value);\\n        }\\n\\n        // define how a literal is parsed to the native .NET type.\\n        public override object ParseLiteral(IValueNode valueSyntax, bool withDefaults = true)\\n        {\\n            if (valueSyntax is StringValueNode stringLiteral &&\\n                _validator.ValidateCreditCard(stringLiteral.Value))\\n            {\\n                return stringLiteral.Value;\\n            }\\n\\n            throw new SerializationException(\\n                \\\"The specified value has to be a credit card number in the format \\\" +\\n                \\\"XXXX XXXX XXXX XXXX\\\",\\n                nameof(valueSyntax));\\n        }\\n\\n        // define how a native type is parsed into a literal,\\n        public override IValueNode ParseValue(object? runtimeValue)\\n        {\\n            if (runtimeValue is string s &&\\n                _validator.ValidateCreditCard(s))\\n            {\\n                return new StringValueNode(null, s, false);\\n            }\\n\\n            throw new SerializationException(\\n                \\\"The specified value has to be a credit card number in the format \\\" +\\n                \\\"XXXX XXXX XXXX XXXX\\\");\\n        }\\n\\n        public override IValueNode ParseResult(object? resultValue)\\n        {\\n            if (resultValue is string s &&\\n                _validator.ValidateCreditCard(s))\\n            {\\n                return new StringValueNode(null, s, false);\\n            }\\n\\n            throw new SerializationException(\\n                \\\"The specified value has to be a credit card number in the format \\\" +\\n                \\\"XXXX XXXX XXXX XXXX\\\");\\n        }\\n\\n        public override bool TrySerialize(object? runtimeValue, out object? resultValue)\\n        {\\n            if (runtimeValue is string s &&\\n                _validator.ValidateCreditCard(s))\\n            {\\n                resultValue = s;\\n                return true;\\n            }\\n\\n            resultValue = null;\\n            return false;\\n        }\\n\\n        public override bool TryDeserialize(object? serialized, out object? value)\\n        {\\n            if (serialized is string s &&\\n                _validator.ValidateCreditCard(s))\\n            {\\n                value = s;\\n                return true;\\n            }\\n\\n            value = null;\\n            return false;\\n        }\\n    }\\n\")), mdx(\"h1\", null, \"Additional Scalars\"), mdx(\"p\", null, \"HotChocolate provides additional scalars for more specific usecases. \"), mdx(\"p\", null, \"To use these scalars you have to add the package \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Types.Scalars\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"dotnet add package HotChocolate.Types.Scalars\\n\")), mdx(\"p\", null, \"These scalars cannot be mapped by HotChocolate to a field.\\nYou need to specify them manually.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Annotation Based\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class User \\n{\\n    [GraphQLType(typeof(NonEmptyStringType))]\\n    public string UserName { get; set; }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Code First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class UserType : ObjectType<User> \\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor<User> descriptor)\\n    {\\n        descriptor.Field(x => x.UserName).Type<NonEmptyStringType>();\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Schema First\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"type User {\\n  userName: NonEmptyString\\n}\\n\")), mdx(\"p\", null, \"You will also have to add the Scalar to the schema: \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n  .AddGraphQLServer()\\n  // ....\\n  .AddType<NonEmptyStringType>()\\n\")), mdx(\"h2\", null, \"EmailAddress\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe EmailAddress scalar type represents a email address, represented as UTF-8 character sequences that follows the specification defined in RFC 5322\\n\\\"\\\"\\\"\\nscalar EmailAddress\\n\")), mdx(\"h2\", null, \"HexColor\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe HexColor scalar type represents a valid HEX color code.\\n\\\"\\\"\\\"\\nscalar HexColor\\n\")), mdx(\"h2\", null, \"Hsl\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe `Hsl` scalar type represents a valid a CSS HSL color as defined here https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl_colors.\\n\\\"\\\"\\\"\\nscalar Hsl\\n\")), mdx(\"h2\", null, \"Hsla\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe `Hsla` scalar type represents a valid a CSS HSLA color as defined here https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl_colors.\\n\\\"\\\"\\\"\\nscalar Hsla\\n\")), mdx(\"h2\", null, \"NegativeFloat\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NegativeFloat scalar type represents a double\\u2010precision fractional value less than 0\\n\\\"\\\"\\\"\\nscalar NegativeFloat\\n\")), mdx(\"h2\", null, \"NegativeInt\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NegativeIntType scalar type represents a signed 32-bit numeric non-fractional with a maximum of -1.\\n\\\"\\\"\\\"\\nscalar NegativeInt\\n\")), mdx(\"h2\", null, \"NonEmptyString\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NonNullString scalar type represents non empty textual data, represented as UTF\\u20108 character sequences with at least one character\\n\\\"\\\"\\\"\\nscalar NonEmptyString\\n\")), mdx(\"h2\", null, \"NonNegativeFloat\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NonNegativeFloat scalar type represents a double\\u2010precision fractional value greater than or equal to 0.\\n\\\"\\\"\\\"\\nscalar NonNegativeFloat\\n\")), mdx(\"h2\", null, \"NonNegativeInt\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NonNegativeIntType scalar type represents a unsigned 32-bit numeric non-fractional value greater than or equal to 0.\\n\\\"\\\"\\\"\\nscalar NonNegativeInt\\n\")), mdx(\"h2\", null, \"NonPositiveFloat\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NonPositiveFloat scalar type represents a double\\u2010precision fractional value less than or equal to 0.\\n\\\"\\\"\\\"\\nscalar NonPositiveFloat\\n\")), mdx(\"h2\", null, \"NonPositiveInt\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe NonPositiveInt scalar type represents a signed 32-bit numeric non-fractional value less than or equal to 0.\\n\\\"\\\"\\\"\\nscalar NonPositiveInt\\n\")), mdx(\"h2\", null, \"PhoneNumber\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe PhoneNumber scalar type represents a value that conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164.\\n\\\"\\\"\\\"\\nscalar PhoneNumber\\n\")), mdx(\"h2\", null, \"PositiveInt\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe PositiveInt scalar type represents a signed 32\\u2010bit numeric non\\u2010fractional value of at least the value 1.\\n\\\"\\\"\\\"\\nscalar PositiveInt\\n\")), mdx(\"h2\", null, \"PostalCode\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe PostalCode scalar type represents a valid postal code.\\n\\\"\\\"\\\"\\nscalar PostalCode\\n\")), mdx(\"h2\", null, \"UnsignedInt\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe UnsignedInt scalar type represents a unsigned 32\\u2010bit numeric non\\u2010fractional value greater than or equal to 0.\\n\\\"\\\"\\\"\\nscalar UnsignedInt\\n\")), mdx(\"h2\", null, \"IPv4\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"\\\"\\\"\\\"\\nThe `IPv4` scalar type represents a valid a IPv4 address as defined here https://en.wikipedia.org/wiki/IPv4.\\n\\\"\\\"\\\"\\nscalar IPv4\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#using-scalars","title":"Using Scalars"},{"url":"#any-type","title":"Any Type"},{"url":"#custom-converter","title":"Custom Converter"},{"url":"#custom-scalars","title":"Custom Scalars"},{"url":"#additional-scalars","title":"Additional Scalars","items":[{"url":"#emailaddress","title":"EmailAddress"},{"url":"#hexcolor","title":"HexColor"},{"url":"#hsl","title":"Hsl"},{"url":"#hsla","title":"Hsla"},{"url":"#negativefloat","title":"NegativeFloat"},{"url":"#negativeint","title":"NegativeInt"},{"url":"#nonemptystring","title":"NonEmptyString"},{"url":"#nonnegativefloat","title":"NonNegativeFloat"},{"url":"#nonnegativeint","title":"NonNegativeInt"},{"url":"#nonpositivefloat","title":"NonPositiveFloat"},{"url":"#nonpositiveint","title":"NonPositiveInt"},{"url":"#phonenumber","title":"PhoneNumber"},{"url":"#positiveint","title":"PositiveInt"},{"url":"#postalcode","title":"PostalCode"},{"url":"#unsignedint","title":"UnsignedInt"},{"url":"#ipv4","title":"IPv4"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/defining-a-schema/scalars.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}