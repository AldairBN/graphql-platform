{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/defining-a-schema/unions-and-interfaces","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/defining-a-schema/unions-and-interfaces/"},"frontmatter":{"title":"Unions and Interfaces"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unions and Interfaces\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Similar to most type systems, GraphQL knows abstract types. There are two kinds of abstract types:\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/learn/schema/#interfaces\"\n  }), \"Interfaces\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://graphql.org/learn/schema/#unions\"\n  }), \"Unions\")), mdx(\"h1\", null, \"Interfaces\"), mdx(\"p\", null, \"An interface type can be used for abstract types that share fields.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"interface Message {\\n  sendBy: User!\\n  createdAt: DateTime!\\n}\\n\")), mdx(\"p\", null, \"An object type or interface type that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"implements\"), \" an interface, does have to declare all the fields that are declared on the interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type TextMessage implements Message {\\n  sendBy: User!\\n  createdAt: DateTime!\\n  content: String!\\n}\\n\\ninterface MediaMessage implements Message {\\n  sendBy: User!\\n  createdAt: DateTime!\\n  mediaType: MediaType!\\n}\\n\\ntype VideoMessage implements MediaMessage {\\n  sendBy: User!\\n  createdAt: DateTime!\\n  mediaType: MediaType!\\n  videoUrl: String!\\n}\\n\")), mdx(\"p\", null, \"A type can also implement multiple interfaces.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type VideoMessage implements Message & HasMediaType {\\n  sendBy: User!\\n  createdAt: DateTime!\\n  mediaType: MediaType!\\n  videoUrl: String!\\n}\\n\")), mdx(\"h2\", null, \"Querying Interfaces\"), mdx(\"p\", null, \"All fields declared on the interface type are available to query directly.\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://spec.graphql.org/June2018/#sec-Inline-Fragments\"\n  }), \"Inline Fragments \\uD83D\\uDCC4\"), \" allow to query for fields of a specific implementation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  messages {\\n    __typename\\n    sendBy {\\n      userName\\n    }\\n    createdAt\\n    ... on TextMessage {\\n      content\\n    }\\n    ... on VideoMessage {\\n      videoUrl\\n    }\\n    ... on MediaMessage {\\n      mediaType\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"messages\\\": [\\n    {\\n      \\\"__typename\\\": \\\"TextMessage\\\",\\n      \\\"sendBy\\\": {\\n        \\\"userName\\\": \\\"CookingMaster86\\\"\\n      },\\n      \\\"createdAt\\\": \\\"2020-01-01T11:43:00Z\\\",\\n      \\\"context\\\": \\\"Hi there, can you show me how you did it?\\\"\\n    }\\n    {\\n      \\\"__typename\\\": \\\"VideoMessage\\\",\\n      \\\"sendBy\\\": {\\n        \\\"userName\\\": \\\"SpicyChicken404\\\"\\n      },\\n      \\\"createdAt\\\": \\\"2020-01-01T12:00:00Z\\\",\\n      \\\"videoUrl\\\": \\\"http://chillicream.com/cooking/recipies\\\",\\n    }\\n  ]\\n}\\n\")), mdx(\"h2\", null, \"Interface Definition\"), mdx(\"p\", null, \"HotChocolate tries to infer interfaces from the .Net types.\\nWhen a resolver returns an interface, you just have to register the implementation on the schema builder.\\nHotChocolate will register the types as implementations of the interface.\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"p\", null, \"In the annotation based approach, you most likely do not need to worry about interfaces at all.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n  public IMessage[] GetMessages([Service]IMessageRepo repo) => repo.GetMessages();\\n}\\n\\n[GraphQLName(\\\"Message\\\")]\\npublic interface IMessage\\n{\\n  User SendBy { get; }\\n\\n  DateTime CreatedAt { get; }\\n}\\n\\npublic class TextMessage : IMessage\\n{\\n  public User SendBy { get; set; }\\n\\n  public DateTime CreatedAt { get; set; }\\n\\n  public string Content { get; set; }\\n}\\n// .....\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Configure Services\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"  public void ConfigureServices(IServiceCollection services)\\n  {\\n      services\\n          .AddRouting()\\n          .AddGraphQLServer()\\n          .AddQueryType<Query>()\\n          // HotChocolate knows that TextMessage implements IMessage and will add it to the list\\n          // of implementations\\n          .AddType<TextMessage>()\\n          .AddType<VideoMessage>()\\n  }\\n\")), mdx(\"p\", null, \"You can also use classes as definitions for interfaces.\\nTo mark a base class as an interface definition you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[InterfaceType]\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[InterfaceType]\\npublic abstract class Message\\n{\\n  public User SendBy { get; set; }\\n\\n  public DateTime CreatedAt { get; set; }\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"p\", null, \"HotChocolate provides a fluent configuration API for interfaces that is very similar to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MediaMessageType : InterfaceType<IMediaMessage>\\n{\\n    protected override void Configure(IInterfaceTypeDescriptor<IMediaMessage> descriptor)\\n    {\\n        // Configure Type Name\\n        descriptor.Name(\\\"MediaMessage\\\");\\n\\n        // By default all fields are bound implicitly. This means, all fields of `IMessage` are\\n        // added to the type and do not have to be added with descriptor.Field(x => x.FieldName)\\n        // This behaviour can be changed from opt out to opt in by calling BindFieldsExplicitly\\n        descriptor.BindFieldsExplicitly();\\n\\n        // Declare  Fields\\n        descriptor.Field(x => x.MediaType);\\n        descriptor.Field(x => x.CreatedAt);\\n        descriptor.Field(x => x.SendBy);\\n\\n        // This interface implements a interface\\n        descriptor.Implements<MessageType>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"In a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \" you can declare what interface this object type implements.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class VideoMessageType : ObjectType<VideoMessage>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<VideoMessage> descriptor)\\n    {\\n        descriptor.Implements<MessageType>();\\n    }\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"In schema first interfaces can be declared directly in SDL:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .AddDocumentFromString(@\\\"\\n        type Query {\\n            messages: Message\\n        }\\n\\n        interface Message {\\n          sendBy: User!\\n          createdAt: DateTime!\\n        }\\n\\n        type TextMessage implements Message {\\n          sendBy: User!\\n          createdAt: DateTime!\\n          content: String!\\n        }\\n\\n        interface MediaMessage implements Message {\\n          sendBy: User!\\n          createdAt: DateTime!\\n          mediaType: MediaType!\\n        }\\n\\n        type VideoMessage implements MediaMessage {\\n          sendBy: User!\\n          createdAt: DateTime!\\n          mediaType: MediaType!\\n          videoUrl: String!\\n        }\\n\\n        type VideoMessage implements Message & HasMediaType {\\n          sendBy: User!\\n          createdAt: DateTime!\\n          mediaType: MediaType!\\n          videoUrl: String!\\n        }\\n        \\\")\\n        .AddResolver(\\n            \\\"Query\\\",\\n            \\\"messages\\\",\\n            (context, token) => context.Service<IMessageRepo>().GetMessages());\\n}\\n\")))), mdx(\"h1\", null, \"Unions\"), mdx(\"p\", null, \"Unions are very similar to interfaces. The difference is that members of an unions do not have fields in common.\\nUnions are useful if you have completely disjunct structured types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Group {\\n  id: ID!\\n  members: [GroupMember]\\n}\\n\\ntype User {\\n  userName: String!\\n}\\n\\nunion GroupMember = User | Group\\n\")), mdx(\"h2\", null, \"Querying Unions\"), mdx(\"p\", null, \"Union types do not have fields in common.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"You have to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://spec.graphql.org/June2018/#sec-Inline-Fragments\"\n  }), \"Inline Fragments \\uD83D\\uDCC4\"), \" to query for fields of a specific implementation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  accessControl {\\n    __typename\\n    ... on Group {\\n      id\\n    }\\n    ... on User {\\n      userName\\n    }\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"accessControl\\\": [\\n    {\\n      \\\"__typename\\\": \\\"Group\\\",\\n      \\\"id\\\": \\\"R3JvdXA6MQ==\\\"\\n    },\\n    {\\n      \\\"__typename\\\": \\\"User\\\",\\n      \\\"userName\\\": \\\"SpicyChicken404\\\"\\n    },\\n    {\\n      \\\"__typename\\\": \\\"User\\\",\\n      \\\"userName\\\": \\\"CookingMaster86\\\"\\n    }\\n  ]\\n}\\n\")), mdx(\"h2\", null, \"Union Definition\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"p\", null, \"In the annotation based approach, HotChocolate tries to infer union types from the .Net types.\\nYou can manage the membership of union types with a marker interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UnionType(\\\"GroupMember\\\")]\\npublic interface IGroupMember\\n{\\n}\\n\\npublic class Group : IGroupMember\\n{\\n  [Id]\\n  public Guid Identifier { get; set; }\\n\\n  public IGroupMember[] Members { get; set; }\\n}\\n\\npublic class User : IGroupMember\\n{\\n  public string UserName { get; set; }\\n}\\n\\npublic class Query\\n{\\n  public IGroupMember[] GetAccessControl([Service]IAccessRepo repo) => repo.GetItems();\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Configure Services\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"  public void ConfigureServices(IServiceCollection services)\\n  {\\n      services\\n          .AddRouting()\\n          .AddGraphQLServer()\\n          // HotChocolate will pick up IGroupMember as a UnionType<IGroupMember>\\n          .AddQueryType<Query>()\\n          // HotChocolate knows that User and Group implement IGroupMember and will add it to the\\n          // list of possible types of the UnionType\\n          .AddType<Group>()\\n          .AddType<User>()\\n  }\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"p\", null, \"HotChocolate provides a fluent configuration API for union types that is very similar to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \" interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"// In case you have a marker interface and want to configure it, you can also just user UnionType<IMarkerInterface>\\npublic class GroupMemberType : UnionType\\n{\\n    protected override void Configure(IUnionTypeDescriptor descriptor)\\n    {\\n        // Configure Type Name\\n        descriptor.Name(\\\"GroupMember\\\");\\n\\n        // Declare Possible Types\\n        descriptor.Type<GroupType>();\\n        descriptor.Type<UserType>();\\n    }\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"p\", null, \"In schema first unions can be declared directly in SDL:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services\\n        .AddRouting()\\n        .AddGraphQLServer()\\n        .AddDocumentFromString(@\\\"\\n        type Query {\\n            accessControl: [GroupMember]\\n        }\\n\\n        type Group {\\n            id: ID!\\n            members: [GroupMember]\\n        }\\n\\n        type User {\\n            userName: String!\\n        }\\n\\n        union GroupMember = User | Group\\n        \\\")\\n        .AddResolver(\\n            \\\"Query\\\",\\n            \\\"accessControl\\\",\\n            (context, token) => context.Service<IAccessRepo>().GetItems());\\n}\\n\")))));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#interfaces","title":"Interfaces","items":[{"url":"#querying-interfaces","title":"Querying Interfaces"},{"url":"#interface-definition","title":"Interface Definition"}]},{"url":"#unions","title":"Unions","items":[{"url":"#querying-unions","title":"Querying Unions"},{"url":"#union-definition","title":"Union Definition"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"http://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/defining-a-schema/unions-and-interfaces.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}