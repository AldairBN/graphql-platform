{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/defining-a-schema/operations","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/defining-a-schema/operations/"},"frontmatter":{"title":"GraphQL Operations"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"GraphQL Operations\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We are still working on the documentation for Hot Chocolate 11.1 so help us by finding typos, missing things or write some additional docs with us.\")), mdx(\"p\", null, \"In GraphQL, there are three root types from which only the Query type has to be defined. Root types provide the entry points that lets us fetch data, mutate data, or subscribe to events. Root types themselves are object types and are commonly referred to as operations.\"), mdx(\"h1\", null, \"Query\"), mdx(\"p\", null, \"The query type is how we can read data. It is described as a way to access read-only data in a side-effect free way. This means that the GraphQL engine is allowed to parallelize data fetching.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"query {\\n  book(id: 1) {\\n    title\\n    author\\n  }\\n}\\n\")), mdx(\"h2\", null, \"Defining a query\"), mdx(\"p\", null, \"A query type can be represented like the following:\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public Book GetBook() => new Book { Title  = \\\"C# in depth\\\", Author = \\\"Jon Skeet\\\" };\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            .AddQueryType<Query>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public Book GetBook() => new Book { Title  = \\\"C# in depth\\\", Author = \\\"Jon Skeet\\\" };\\n}\\n\\npublic class QueryType : ObjectType<Query>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor\\n            .Field(f => f.GetBook())\\n            .Type<BookType>();\\n    }\\n}\\n\\npublic class BookType : ObjectType<Book>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Query> descriptor)\\n    {\\n        descriptor\\n            .Field(f => f.Title)\\n            .Type<StringType>();\\n\\n        descriptor\\n            .Field(f => f.Author)\\n            .Type<StringType>();\\n    }\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            .AddQueryType<QueryType>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    public Book GetBook() => new Book { Title  = \\\"C# in depth\\\", Author = \\\"Jon Skeet\\\" };\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            .AddDocumentFromString(@\\\"\\n                type Query {\\n                  book: Book\\n                }\\n\\n                type Book {\\n                  title: String\\n                  author: String\\n                }\\n            \\\")\\n            .BindComplexType<Query>()\\n            .BindComplexType<Book>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\")))), mdx(\"h1\", null, \"Mutation\"), mdx(\"p\", null, \"The mutation type in GraphQL is used to mutate/change data. This means that when we are doing mutations, we are causing side-effects to the system.\"), mdx(\"p\", null, \"GraphQL defines mutations as top-level fields on the mutation type. Meaning only the fields on the mutation root type itself are mutations. Everything that is returned from a mutation field represents the changed state of the server.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  mutation {\\n    # changeBookTitle is a mutation and is allowed to cause side-effects.\\n    changeBookTitle(input: { id: 1, title: \\\"C# in depth\\\" }) {\\n      # everything in this selection set and below is a query.\\n      # We essentially allow the user to query the effect that the mutation had\\n      # on our system.\\n      # In this case we are querying the changed book.\\n      book {\\n        title\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"In one GraphQL request we can execute multiple mutations. Each of these mutations are executed serially one by one whereas their child selection sets are executed possibly in parallel since only the top-level mutations fields are allowed to have side-effects in GraphQL.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  mutation {\\n    addBook(input: { title: \\\"C# in depth\\\", author: \\\"Jon Skeet\\\" }) {\\n      book {\\n        title\\n      }\\n    }\\n    publishBook(input: { id: 1 }) {\\n      book {\\n        isPublished\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"h2\", null, \"Defining a Mutation\"), mdx(\"p\", null, \"A mutation type can be represented like the following:\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Mutation\\n{\\n    public async Task<Book> AddBook(Book book)\\n    {\\n        // Omitted code for brevity\\n    }\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            // ...\\n            .AddMutationType<Mutation>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Mutation\\n{\\n    public async Task<Book> AddBook(Book book)\\n    {\\n        // Omitted code for brevity\\n    }\\n}\\n\\npublic class MutationType : ObjectType<Mutation>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Mutation> descriptor)\\n    {\\n        descriptor.Field(f => f.AddBook(default));\\n    }\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            // ...\\n            .AddMutationType<MutationType>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Mutation\\n{\\n    public async Task<Book> AddBook(Book book)\\n    {\\n        // Omitted code for brevity\\n    }\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            .AddDocumentFromString(@\\\"\\n                # ...\\n\\n                type Mutation {\\n                  addBook(input: BookInput): Book\\n                }\\n\\n                type BookInput {\\n                  title: String\\n                  author: String\\n                }\\n\\n                type Book {\\n                  title: String\\n                  author: String\\n                }\\n            \\\")\\n            // ...\\n            .BindComplexType<Mutation>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\")))), mdx(\"h2\", null, \"Mutation Transactions\"), mdx(\"p\", null, \"With multiple mutations executed serially in one request it sometimes would be great to put these into a transactions scope that we can control.\"), mdx(\"p\", null, \"Hot Chocolate provides for this the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITransactionScopeHandler\"), \" which is used by the operation execution middleware to create transaction scopes for mutation requests.\"), mdx(\"p\", null, \"Hot Chocolate provides a default implementation based on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"System.Transactions.TransactionScope\"), \" which works with Microsoft ADO.NET data provider and hence can be used in combination with Entity Framework.\"), mdx(\"p\", null, \"The default transaction scope handler can be added like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    // ...\\n    .AddDefaultTransactionScopeHandler();\\n\")), mdx(\"p\", null, \"This is how the default implementation looks like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"/// <summary>\\n/// Represents the default mutation transaction scope handler implementation.\\n/// </summary>\\npublic class DefaultTransactionScopeHandler : ITransactionScopeHandler\\n{\\n    /// <summary>\\n    /// Creates a new transaction scope for the current\\n    /// request represented by the <see cref=\\\"IRequestContext\\\"/>.\\n    /// </summary>\\n    /// <param name=\\\"context\\\">\\n    /// The GraphQL request context.\\n    /// </param>\\n    /// <returns>\\n    /// Returns a new <see cref=\\\"ITransactionScope\\\"/>.\\n    /// </returns>\\n    public virtual ITransactionScope Create(IRequestContext context)\\n    {\\n        return new DefaultTransactionScope(\\n            context,\\n            new TransactionScope(\\n                TransactionScopeOption.Required,\\n                new TransactionOptions\\n                {\\n                    IsolationLevel = IsolationLevel.ReadCommitted\\n                }));\\n    }\\n}\\n\")), mdx(\"p\", null, \"If we implement a custom transaction scope handler or if we choose to extend upon the default transaction scope handler, we can add it like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    // ...\\n    .AddTransactionScopeHandler<CustomTransactionScopeHandler>();\\n\")), mdx(\"h1\", null, \"Subscription\"), mdx(\"p\", null, \"The subscription type in GraphQL is used to add real-time capabilities to our applications. Clients can subscribe to events and receive the event data in real-time, as soon as the server publishes it.\"), mdx(\"p\", null, \"Subscribing to an event is like writing a standard query. The only difference is the operation keyword and that we are only allowed to have one root field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"subscription {\\n  onBookAdded(author: \\\"Jon Skeet\\\") {\\n    title\\n  }\\n}\\n\")), mdx(\"p\", null, \"HotChocolate implements Subscriptions via WebSockets and uses the pub/sub approach of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.apollographql.com/docs/apollo-server/data/subscriptions/#the-pubsub-class\"\n  }), \"Apollo\"), \" for triggering subscriptions.\"), mdx(\"h2\", null, \"Defining a Subscription\"), mdx(\"p\", null, \"A subscription type can be represented like the following:\"), mdx(ExampleTabs, {\n    mdxType: \"ExampleTabs\"\n  }, mdx(ExampleTabs.Annotation, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [Subscribe]\\n    public Book OnBookAdded([EventMessage] Book book) => book;\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            // ...\\n            .AddSubscriptionType<Subscription>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Code, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class SubscriptionType : ObjectType\\n{\\n    protected override void Configure(IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor\\n            .Field(\\\"onBookAdded\\\")\\n            .Type<BookType>()\\n            .Resolve(context => context.GetEventMessage<Book>())\\n            .Subscribe(async context =>\\n            {\\n                var receiver = context.Service<ITopicEventReceiver>();\\n\\n                ISourceStream stream =\\n                    await receiver.SubscribeAsync<string, Book>(\\\"OnBookAdded\\\");\\n\\n                return stream;\\n            });\\n    }\\n}\\n\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            // ...\\n            .AddSubscriptionType<SubscriptionType>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\"))), mdx(ExampleTabs.Schema, null, mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [Subscribe]\\n    public Book OnBookAdded([EventMessage] Book book) => book;\\n}\\n\\npublic class Startup\\n{\\n    public void ConfigureServices(IServiceCollection services)\\n    {\\n        services\\n            .AddGraphQLServer()\\n            .AddDocumentFromString(@\\\"\\n                # ...\\n\\n                type Subscription {\\n                  onBookAdded: Book\\n                }\\n\\n                type Book {\\n                  title: String\\n                  author: String\\n                }\\n            \\\")\\n            // ...\\n            .BindComplexType<Subscription>();\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\")))), mdx(\"h2\", null, \"Transport\"), mdx(\"p\", null, \"After defining the subscription type, we need to add the WebSockets middleware to our request pipeline.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Startup\\n{\\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\\n    {\\n        app.UseRouting();\\n\\n        app.UseWebSockets();\\n\\n        app.UseEndpoints(endpoints =>\\n        {\\n            endpoints.MapGraphQL();\\n        });\\n    }\\n\\n    // Omitted code for brevity\\n}\\n\")), mdx(\"p\", null, \"To make pub/sub work, we also have to register a subscription provider. A subscription provider represents a pub/sub implementation used to handle events. Out of the box we support two subscription providers.\"), mdx(\"h3\", null, \"In-Memory Provider\"), mdx(\"p\", null, \"The In-Memory subscription provider does not need any configuration and is easily setup:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddInMemorySubscriptions();\\n\")), mdx(\"h3\", null, \"Redis Provider\"), mdx(\"p\", null, \"The Redis subscription provider enables us to run multiple instances of our HotChocolate GraphQL server and handle subscription events reliably.\"), mdx(\"p\", null, \"In order to use the Redis provider add the following package: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Subscriptions.Redis\")), mdx(\"p\", null, \"After we have added the package we can setup the Redis subscription provider:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddRedisSubscriptions((sp) =>\\n    ConnectionMultiplexer.Connect(\\\"host:port\\\"));\\n\")), mdx(\"p\", null, \"Our Redis subscription provider uses the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/StackExchange/StackExchange.Redis\"\n  }), \"StackExchange.Redis\"), \" Redis client underneath.\"), mdx(\"h2\", null, \"Publishing Events\"), mdx(\"p\", null, \"To publish events and trigger subscriptions, we can use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventSender\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventSender\"), \" is an abstraction for the registered event publishing provider. Using this abstraction allows us to seamlessly switch between subscription providers, when necessary.\"), mdx(\"p\", null, \"Most of the time we will be publishing events for successful mutations. Therefor we can simply inject the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventSender\"), \" into our mutations like we would with every other \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Service\"), \". Of course we can not only publish events from mutations, but everywhere we have access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventSender\"), \" through the DI Container.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Mutation\\n{\\n    public async Book AddBook(Book book, [Service] ITopicEventSender sender)\\n    {\\n        await sender.SendAsync(\\\"OnBookAdded\\\", book);\\n\\n        // Omitted code for brevity\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the example the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"OnBookAdded\\\"\"), \" is the topic we want to publish to, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"book\"), \" is our payload. Even though we have used a string as the topic, we do not have to. Any other type works just fine.\"), mdx(\"p\", null, \"But where is the connection between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"OnBookAdded\\\"\"), \" as a topic and the subscription type? Per default HotChocolate will try to map the topic to a field of the subscription type. If we want to make this binding less error-prone, we could do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"await sender.SendAsync(nameof(Subscription.OnBookAdded), book);\\n\")), mdx(\"p\", null, \"If we do not want to use the method name, we could use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Topic\"), \" attribute.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [Subscribe]\\n    [Topic(\\\"ExampleTopic\\\")]\\n    public Book OnBookAdded([EventMessage] Book book) => book;\\n}\\n\\npublic async Book AddBook(Book book, [Service] ITopicEventSender sender)\\n{\\n    await sender.SendAsync(\\\"ExampleTopic\\\", book);\\n\\n    // Omitted code for brevity\\n}\\n\")), mdx(\"p\", null, \"We can even use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Topic\"), \" attribute on dynamic arguments of the subscription field.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [Subscribe]\\n    public Book OnBookAdded([Topic] string author, [EventMessage] Book book)\\n        => book;\\n}\\n\\npublic async Book AddBook(Book book, [Service] ITopicEventSender sender)\\n{\\n    await sender.SendAsync(book.Author, book);\\n\\n    // Omitted code for brevity\\n}\\n\")), mdx(\"p\", null, \"We can also use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITopicEventReceiver\"), \" to work with more complex topics.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    [SubscribeAndResolve]\\n    public ValueTask<ISourceStream<Book>> OnBookAdded(string author,\\n        [Service] ITopicEventReceiver receiver)\\n    {\\n        string topic = $\\\"{author}_AddedBook\\\";\\n        Book book = receiver.SubscribeAsync<string, Book>(topic);\\n\\n        return book;\\n    }\\n}\\n\\npublic async Book AddBook(Book book, [Service] ITopicEventSender sender)\\n{\\n    await sender.SendAsync($\\\"{book.Author}_AddedBook\\\", book);\\n\\n    // Omitted code for brevity\\n}\\n\")), mdx(\"p\", null, \"If we do not want to mix the subscription logic with our resolver, we can also use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"With\"), \" argument on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Subscribe\"), \" attribute to specify a seperate method that handles the event subscription.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Subscription\\n{\\n    public ValueTask<ISourceStream<Book>> SubscribeToBooks(\\n        [Service] ITopicEventReceiver receiver)\\n        => receiver.SubscribeAsync<string, Book>(\\\"ExampleTopic\\\");\\n\\n    [Subscribe(With = nameof(SubscribeToBooks))]\\n    public ValueTask<ISourceStream<Book>> OnBookAdded([EventMessage] Book book)\\n        => book;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#query","title":"Query","items":[{"url":"#defining-a-query","title":"Defining a query"}]},{"url":"#mutation","title":"Mutation","items":[{"url":"#defining-a-mutation","title":"Defining a Mutation"},{"url":"#mutation-transactions","title":"Mutation Transactions"}]},{"url":"#subscription","title":"Subscription","items":[{"url":"#defining-a-subscription","title":"Defining a Subscription"},{"url":"#transport","title":"Transport"},{"url":"#publishing-events","title":"Publishing Events"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://bit.ly/joinchilli"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11.1 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"descriptions","title":"Schema Documentation"},{"path":"operations","title":"Operations"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"extending-types","title":"Extending types"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"distributed-schema","title":"Distributed Schemas","items":[{"path":"index","title":"Overview"},{"path":"schema-stitching","title":"Schema Stitching"},{"path":"schema-federations","title":"Schema Federations"},{"path":"schema-configuration","title":"Schema Configuration"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"},{"path":"mongodb","title":"MongoDB"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"custom-attributes","title":"Custom Attributes"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"dependency-injection","title":"Dependency Injection"},{"path":"executable","title":"Executable"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"coding-approaches","title":"Coding Approaches"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"strawberryshake","title":"Strawberry Shake","description":"The only GraphQL client you will every need in the .NET ecosystem.","versions":[{"path":"","title":"v11 (preview)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":[{"path":"index","title":"Blazor"},{"path":"xamarin","title":"Xamarin"},{"path":"console","title":"Console"}]},{"path":"subscriptions","title":"Subscriptions","items":null},{"path":"tooling","title":"Tooling / CLI","items":null},{"path":"caching","title":"Caching","items":[{"path":"index","title":"Overview"},{"path":"entities","title":"Entities"},{"path":"invalidation","title":"Invalidation"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"persisted-state","title":"Persisted State"}]},{"path":"networking","title":"Networking","items":[{"path":"index","title":"Protocols"},{"path":"authentication","title":"Authentication"}]},{"path":"scalars","title":"Scalars","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/defining-a-schema/operations.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}