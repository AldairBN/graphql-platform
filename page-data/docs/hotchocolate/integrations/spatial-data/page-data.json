{"componentChunkName":"component---src-templates-doc-page-template-tsx","path":"/docs/hotchocolate/integrations/spatial-data","result":{"data":{"file":{"childMdx":{"fields":{"slug":"/hotchocolate/integrations/spatial-data/"},"frontmatter":{"title":"Spatial Data"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Spatial Data\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Experimental\"), \" With version 11 we release support for spatial data. This feature is not totally finished\\nand polished yet. Spatial types is a community-driven feature. As the core team has little experience\\nwith spatial data, we need you feedback and decided to release what we have. It is important for use\\nto deliver you the best experience, so reach out to us if you run into issues or have ideas to improve it.\\nWe try not to introduce breaking changes, but we save ourself the possibility to make changes to the api\\nin future releases when we find flaws in the current design.\")), mdx(\"p\", null, \"Spatial data describes locations or shapes in form of objects. Many database providers have support\\nfor storing this type of data. APIs often use GeoJSON to send spatial data over the network.\"), mdx(\"p\", null, \"The most common library used for spatial data in .NET is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/NetTopologySuite/NetTopologySuite\"\n  }), \"NetTopologySuite\"), \".\\nEntity Framework supports \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.microsoft.com/en-gb/ef/core/modeling/spatial\"\n  }), \"Spatial Data\"), \" and uses\\nNetToplogySuite as its data representation.\"), mdx(\"p\", null, \"The package \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Spatial\"), \" integrates NetTopologySuite into HotChocolate. With this package your resolvers\\ncan return NetTopologySuite shapes and they will be transformed into GeoJSON.\"), mdx(\"h1\", null, \"Getting Started\"), mdx(\"p\", null, \"You first need to add the package reference to your project. You can do this with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet\"), \" cli:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"  dotnet add package HotChocolate.Spatial\\n\")), mdx(\"p\", null, \"To make the schema recognize the spatial types you need to register them on the schema builder.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services\\n    .AddGraphQLServer()\\n    .AddSpatialTypes();\\n\")), mdx(\"p\", null, \"All NetToplogySuite runtime types are now bound to the corresponding GeoJSON type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Pub\\n{\\n    public int Id { get; set; }\\n\\n    public string Name { get; set; }\\n\\n    public Point Location { get; set; }\\n}\\n\\npublic class Query\\n{\\n    // we use ef in this example\\n    [UseDbContext(typeof(SomeDbContext))]\\n    public IQueryable<Pub> GetPubs([ScopedService] SomeDbContext someDbContext)\\n    {\\n        return someDbContext.Pubs;\\n    }\\n}\\n\\n\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"type Pub {\\n  id: Int!\\n  name: String!\\n  location: GeoJSONPointType!\\n}\\n\\ntype Query {\\n  pubs: [Pub!]!\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  pubs {\\n    id\\n    location {\\n      __typename\\n      bbox\\n      coordinates\\n      crs\\n      type\\n    }\\n    name\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-json\"\n  }), \"{\\n  \\\"data\\\": {\\n    \\\"pubs\\\": [\\n      {\\n        \\\"id\\\": 1,\\n        \\\"location\\\": {\\n          \\\"__typename\\\": \\\"GeoJSONPointType\\\",\\n          \\\"bbox\\\": [12, 12, 12, 12],\\n          \\\"coordinates\\\": [[12, 12]],\\n          \\\"crs\\\": 4326,\\n          \\\"type\\\": \\\"Point\\\"\\n        },\\n        \\\"name\\\": \\\"The Winchester\\\"\\n      },\\n      {\\n        \\\"id\\\": 2,\\n        \\\"location\\\": {\\n          \\\"__typename\\\": \\\"GeoJSONPointType\\\",\\n          \\\"bbox\\\": [43, 534, 43, 534],\\n          \\\"coordinates\\\": [[43, 534]],\\n          \\\"crs\\\": 4326,\\n          \\\"type\\\": \\\"Point\\\"\\n        },\\n        \\\"name\\\": \\\"Fountains Head\\\"\\n      }\\n    ]\\n  }\\n}\\n\")), mdx(\"h1\", null, \"Spatial Types\"), mdx(\"p\", null, \"HotChocolate supports GeoJSON input and output types. There is also a GeoJSON scalar to make generic inputs possible.\"), mdx(\"h2\", null, \"Output Types\"), mdx(\"p\", null, \"The following mappings are available by default:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"NetTopologySuite\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GraphQL\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Point\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONPointType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiPoint\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiPointType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"LineString\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONLineStringType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiLineString\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiLineStringType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Polygon\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONPolygonType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiPolygon\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiPolygonType\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Geometry\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONInterface\")))), mdx(\"p\", null, \"All GeoJSON output types implement the following interface.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"interface GeoJSONInterface {\\n  \\\"The geometry type of the GeoJson object\\\"\\n  type: GeoJSONGeometryType!\\n  \\\"The minimum bounding box around the geometry object\\\"\\n  bbox: [Float]\\n  \\\"The coordinate reference system integer identifier\\\"\\n  crs: Int\\n}\\n\")), mdx(\"p\", null, \"A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NetTopologySuite.Gemeotry\"), \" is mapped to this interface by default.\"), mdx(\"h2\", null, \"Input Types\"), mdx(\"p\", null, \"For each output type there is a corresponding input type\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"NetTopologySuite\"), mdx(\"th\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GraphQL\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Point\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONPointInput\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiPoint\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiPointInput\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"LineString\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONLineStringInput\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiLineString\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiLineStringInput\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"Polygon\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONPolygonInput\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"MultiPolygon\"), mdx(\"td\", _extends({\n    parentName: \"tr\"\n  }, {\n    \"align\": null\n  }), \"GeoJSONMultiPolygonInput\")))), mdx(\"h2\", null, \"Scalar\"), mdx(\"p\", null, \"With interfaces or unions it is possible to have multiple possible return types.\\nInput types do not yet have a way of defining multiple possibilities.\\nAs an addition to output and input types there is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Geometry\"), \" scalar, which closes this gap.\\nWhen a resolver expects any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Geometry\"), \" type as an input, you can use this scalar.\\nThis scalar should be used with caution. Input and output types are much more expressive than a custom scalar.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"scalar Geometry\\n\")), mdx(\"h1\", null, \"Projections\"), mdx(\"p\", null, \"To project spatial types, a special handler is needed. This handler can be registered on the schema with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".AddSpatialProjections()\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .AddProjections()\\n        .AddSpatialTypes()\\n        .AddSpatialProjections()\\n\")), mdx(\"p\", null, \"The projection middleware will use this handler to project the spatial data directly to the database\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UseDbContext(typeof(SomeDbContext))]\\n[UseProjection]\\npublic IQueryable<Pub> GetPubs([ScopedService] SomeDbContext someDbContext)\\n{\\n    return someDbContext.Pubs;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  pubs {\\n    id\\n    location {\\n      __typename\\n      bbox\\n      coordinates\\n      crs\\n      type\\n    }\\n    name\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT p.\\\"Id\\\", p.\\\"Location\\\", p.\\\"Name\\\"\\nFROM \\\"Pubs\\\" AS p\\n\")), mdx(\"h1\", null, \"Filtering\"), mdx(\"p\", null, \"Entity framework supports filtering on NetTopologySuite objects.\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"HotChocolate.Spatial\"), \" provides handlers for filtering spatial types on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable\"), \".\\nThese handlers can be registered on the schema with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \".AddSpatialFiltering()\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"    services\\n        .AddGraphQLServer()\\n        .AddProjections()\\n        .AddSpatialTypes()\\n        .AddSpatialFiltering()\\n\")), mdx(\"p\", null, \"After the registration of the handlers \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UseFiltering()\"), \" will infer the possible filter types\\nfor all \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Geometry\"), \" based types.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"[UseDbContext(typeof(SomeDbContext))]\\n[UseFiltering]\\npublic IQueryable<Pub> GetPubs([ScopedService] SomeDbContext someDbContext)\\n{\\n    return someDbContext.Pubs;\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\",\n    \"metastring\": \"{10}\",\n    \"{10}\": true\n  }), \"type Query {\\n  pubs(where: PubFilterInput): [Pub!]!\\n}\\n\\ninput PubFilterInput {\\n  and: [PubFilterInput!]\\n  or: [PubFilterInput!]\\n  id: ComparableInt32OperationFilterInput\\n  name: StringOperationFilterInput\\n  location: PointFilterInput\\n}\\n\\ninput PointFilterInput {\\n  and: [PointFilterInput!]\\n  or: [PointFilterInput!]\\n  m: ComparableDoubleOperationFilterInput\\n  x: ComparableDoubleOperationFilterInput\\n  y: ComparableDoubleOperationFilterInput\\n  z: ComparableDoubleOperationFilterInput\\n  area: ComparableDoubleOperationFilterInput\\n  boundary: GeometryFilterInput\\n  centroid: PointFilterInput\\n  dimension: DimensionOperationFilterInput\\n  envelope: GeometryFilterInput\\n  geometryType: StringOperationFilterInput\\n  interiorPoint: PointFilterInput\\n  isSimple: BooleanOperationFilterInput\\n  isValid: BooleanOperationFilterInput\\n  length: ComparableDoubleOperationFilterInput\\n  numPoints: ComparableInt32OperationFilterInput\\n  ogcGeometryType: OgcGeometryTypeOperationFilterInput\\n  pointOnSurface: PointFilterInput\\n  srid: ComparableInt32OperationFilterInput\\n  contains: GeometryContainsOperationFilterInput\\n  distance: GeometryDistanceOperationFilterInput\\n  intersects: GeometryIntersectsOperationFilterInput\\n  overlaps: GeometryOverlapsOperationFilterInput\\n  touches: GeometryTouchesOperationFilterInput\\n  within: GeometryWithinOperationFilterInput\\n  ncontains: GeometryContainsOperationFilterInput\\n  ndistance: GeometryDistanceOperationFilterInput\\n  nintersects: GeometryIntersectsOperationFilterInput\\n  noverlaps: GeometryOverlapsOperationFilterInput\\n  ntouches: GeometryTouchesOperationFilterInput\\n  nwithin: GeometryWithinOperationFilterInput\\n}\\n\")), mdx(\"h2\", null, \"Distance\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"distance\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Within_NetTopologySuite_Geometries_Geometry_\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Within\"))), mdx(\"p\", null, \"The filter requires an input geometry. You can optionally buffer this geometry with the input field buffer.\\nThe filter also has all comparable filters.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryDistanceOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n  eq: Float\\n  neq: Float\\n  in: [Float!]\\n  nin: [Float!]\\n  gt: Float\\n  ngt: Float\\n  gte: Float\\n  ngte: Float\\n  lt: Float\\n  nlt: Float\\n  lte: Float\\n  nlte: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  pubs(\\n    where: {\\n      location: {\\n        within: { geometry: { type: Point, coordinates: [1, 1] }, lt: 120 }\\n      }\\n    }\\n  ) {\\n    id\\n    name\\n    location\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE ST_Within(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nwithin\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE NOT ST_Within(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"h2\", null, \"Contains\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contains\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Contains_NetTopologySuite_Geometries_Geometry\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Contains\"))), mdx(\"p\", null, \"The filter requires an input geometry. You can optionally buffer this geometry with the input field buffer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryContainsOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  counties(\\n    where: {\\n      area: { contains: { geometry: { type: Point, coordinates: [1, 1] } } }\\n    }\\n  ) {\\n    id\\n    name\\n    area\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE ST_Contains(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ncontains\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE NOT ST_Contains(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"h2\", null, \"Touches\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"touches\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Touches_NetTopologySuite_Geometries_Geometry_\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Touches\"))), mdx(\"p\", null, \"The filter requires an input geometry. You can optionally buffer this geometry with the input field buffer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryTouchesOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  counties(\\n    where: {\\n      area: {\\n        touches: {\\n          geometry: {\\n            type: Polygon,\\n            coordinates: [[1, 1], ....]\\n          }\\n        }\\n      }\\n    }){\\n      id\\n      name\\n      area\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE ST_Touches(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ntouches\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE NOT ST_Touches(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"h2\", null, \"Intersects\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"intersects\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Intersects_NetTopologySuite_Geometries_Geometry_\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Intersects\"))), mdx(\"p\", null, \"The filter requires an input geometry. You can optionally buffer this geometry with the input field buffer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryIntersectsOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  roads(\\n    where: {\\n      road: {\\n        intersects: {\\n          geometry: {\\n            type: LineString,\\n            coordinates: [[1, 1], ....]\\n          }\\n        }\\n      }\\n    }){\\n      id\\n      name\\n      road\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT r.\\\"Id\\\", r.\\\"Name\\\", r.\\\"Road\\\"\\nFROM \\\"Roads\\\" AS r\\nWHERE ST_Intersects(r.\\\"Road\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nintersects\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT r.\\\"Id\\\", r.\\\"Name\\\", r.\\\"Road\\\"\\nFROM \\\"Roads\\\" AS r\\nWHERE NOT ST_Intersects(r.\\\"Road\\\", @__p_0)\\n\")), mdx(\"h2\", null, \"Overlaps\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"overlaps\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Overlaps_NetTopologySuite_Geometries_Geometry_\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Overlaps\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryOverlapsOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  county(\\n    where: {\\n      area: {\\n        overlaps: {\\n          geometry: {\\n            type: Polygon,\\n            coordinates: [[1, 1], ....]\\n          }\\n        }\\n      }\\n    }){\\n      id\\n      name\\n      area\\n    }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE ST_Overlaps(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"noverlaps\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE NOT ST_Overlaps(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"h2\", null, \"Within\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"within\"), \" filter is an implementation of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://nettopologysuite.github.io/NetTopologySuite/api/NetTopologySuite.Geometries.Geometry.html#NetTopologySuite_Geometries_Geometry_Within_NetTopologySuite_Geometries_Geometry_\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Geometry.Within\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sdl\"\n  }), \"input GeometryWithinOperationFilterInput {\\n  geometry: Geometry!\\n  buffer: Float\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  pubs(\\n    where: {\\n      location: {\\n        within: { geometry: { type: Point, coordinates: [1, 1] }, buffer: 200 }\\n      }\\n    }\\n  ) {\\n    id\\n    name\\n    location\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE ST_Within(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"p\", null, \"The negation of this operation is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nwithin\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sql\"\n  }), \"SELECT c.\\\"Id\\\", c.\\\"Name\\\", c.\\\"Area\\\"\\nFROM \\\"Counties\\\" AS c\\nWHERE NOT ST_Within(c.\\\"Area\\\", @__p_0)\\n\")), mdx(\"h1\", null, \"What's next?\"), mdx(\"p\", null, \"In upcoming releases spatial data will get reprojection features and sorting capabilities.\"), mdx(\"h2\", null, \"Reprojection\"), mdx(\"p\", null, \"At the moment the coordinate reference system (crs) is fixed. The user has to know the crs of the backend\\nto do spatial filtering. The API will furthermore always return the data in the crs it was stored in the database.\"), mdx(\"p\", null, \"We want to improve this. The user should be able to send data to the backend without knowing what the crs. The\\nbackend should reproject the incoming data automatically to the correct crs.\"), mdx(\"p\", null, \"Additionally we want to provide a way for users, to specify in what CRS they want to receive the data.\"), mdx(\"h2\", null, \"Sorting\"), mdx(\"p\", null, \"Currently we only support filtering for spatial data. We also want to provide a way for users to sort results.\\nThis can e.g. be used to find the nearest result for a given point.\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#getting-started","title":"Getting Started"},{"url":"#spatial-types","title":"Spatial Types","items":[{"url":"#output-types","title":"Output Types"},{"url":"#input-types","title":"Input Types"},{"url":"#scalar","title":"Scalar"}]},{"url":"#projections","title":"Projections"},{"url":"#filtering","title":"Filtering","items":[{"url":"#distance","title":"Distance"},{"url":"#contains","title":"Contains"},{"url":"#touches","title":"Touches"},{"url":"#intersects","title":"Intersects"},{"url":"#overlaps","title":"Overlaps"},{"url":"#within","title":"Within"}]},{"url":"#whats-next","title":"What's next?","items":[{"url":"#reprojection","title":"Reprojection"},{"url":"#sorting","title":"Sorting"}]}]}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","repositoryUrl":"https://github.com/ChilliCream/hotchocolate","tools":{"slack":"https://join.slack.com/t/hotchocolategraphql/shared_invite/zt-lqkb8z7b-aFepT0Qrsgv5_yKy0yoyzw"}}},"config":{"products":[{"path":"hotchocolate","title":"Hot Chocolate","description":"Build your own thin GraphQL API layer on top of any resource.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null},{"path":"get-started","title":"Get Started","items":null},{"path":"defining-a-schema","title":"Defining a schema","items":[{"path":"index","title":"Schema basics"},{"path":"versioning","title":"Versioning"},{"path":"unions-and-interfaces","title":"Unions and Interfaces"},{"path":"scalars","title":"Scalars"},{"path":"directives","title":"Directives"}]},{"path":"fetching-data","title":"Fetching data","items":[{"path":"index","title":"Resolver"},{"path":"fetching-from-databases","title":"Fetching from Databases"},{"path":"fetching-from-rest","title":"Fetching from REST"},{"path":"dataloader","title":"DataLoader"},{"path":"pagination","title":"Pagination"},{"path":"filtering","title":"Filtering"},{"path":"sorting","title":"Sorting"},{"path":"projections","title":"Projections"}]},{"path":"integrations","title":"Integrations","items":[{"path":"index","title":"Overview"},{"path":"entity-framework","title":"Entity Framework"},{"path":"spatial-data","title":"Spatial Data"}]},{"path":"performance","title":"Performance","items":[{"path":"index","title":"Overview"},{"path":"persisted-queries","title":"Persisted queries"},{"path":"automatic-persisted-queries","title":"Automatic persisted queries"}]},{"path":"api-reference","title":"API Reference","items":[{"path":"index","title":"Overview"},{"path":"object-type","title":"Object Type"},{"path":"language","title":"Language"},{"path":"extending-filtering","title":"Extending Filtering"},{"path":"visitors","title":"Visitors"},{"path":"aspnetcore","title":"ASP.NET Core"},{"path":"executable","title":"Executable"},{"path":"migrate-from-10-to-11","title":"Migrate from 10.5 to 11.0"}]}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"code-first","title":"Code-First","items":null},{"path":"schema-first","title":"Schema-First","items":null},{"path":"schema","title":"Schema","items":[{"path":"index","title":"Schema"},{"path":"object-type","title":"Object Type"},{"path":"interface-type","title":"Interface Type"},{"path":"union-type","title":"Union Type"},{"path":"input-object-type","title":"Input Object Type"},{"path":"enum-type","title":"Enum Type"},{"path":"descriptions","title":"Schema Descriptions"},{"path":"custom-scalar-types","title":"Scalar Type Support"},{"path":"descriptor-attributes","title":"Descriptor Attributes"},{"path":"extending-types","title":"Custom Base Classes"},{"path":"directives","title":"Directives"},{"path":"resolvers","title":"Resolvers"},{"path":"relay","title":"Relay"},{"path":"conventions","title":"Conventions"},{"path":"options","title":"Schema Options"}]},{"path":"data-fetching","title":"Data Fetching","items":[{"path":"index","title":"Data Loaders"},{"path":"pagination","title":"Pagination"},{"path":"filters","title":"Filters"}]},{"path":"security","title":"Security","items":[{"path":"index","title":"Authorization"},{"path":"security","title":"Security"}]},{"path":"execution-engine","title":"Execution Engine","items":[{"path":"index","title":"Middleware"},{"path":"validation-rules","title":"Validation Rules"},{"path":"instrumentation","title":"Instrumentation"},{"path":"apollo-tracing","title":"Apollo Tracing"},{"path":"batching","title":"Batching"},{"path":"persisted-queries","title":"Persisted Queries"},{"path":"custom-context-data","title":"Custom Context Data"},{"path":"subscriptions","title":"Subscriptions"},{"path":"type-conversion","title":"Type Conversion"},{"path":"error-filter","title":"Error Filter"},{"path":"execution-options","title":"Execution Options"}]},{"path":"server","title":"Server","items":[{"path":"index","title":"ASP.Net"},{"path":"dependency-injection","title":"Dependency Injection"}]},{"path":"stitching","title":"Schema Stitching","items":null},{"path":"tooling","title":"Tooling","items":null},{"path":"advanced","title":"Advanced","items":[{"path":"index","title":"Parser"},{"path":"dotnet-cli","title":".Net CLI"}]},{"path":"tutorials","title":"Tutorials","items":[{"path":"index","title":"Entity Framework"}]},{"path":"examples","title":"Examples","items":[{"path":"index","title":"Star Wars"},{"path":"slack-clone","title":"Slack Clone"},{"path":"other-examples","title":"Other Examples"}]}]}]},{"path":"bananacakepop","title":"Banana Cake Pop","description":"Use this GUI to get deep insights from any GraphQL API.","versions":[{"path":"","title":"v1 (preview)","items":[{"path":"index","title":"Introduction","items":null}]}]},{"path":"greendonut","title":"Green Donut","description":"Configure data loaders and caching for GraphQL endpoints.","versions":[{"path":"","title":"v11 (latest)","items":[{"path":"index","title":"Introduction","items":null}]},{"path":"v10","title":"v10 (previous)","items":[{"path":"index","title":"Introduction","items":null},{"path":"installation","title":"Installation","items":null},{"path":"usage","title":"Usage","items":null},{"path":"api","title":"API","items":null},{"path":"advanced-concepts","title":"Advanced Concepts","items":[{"path":"index","title":"Custom DataLoader"},{"path":"diagnostics","title":"Diagnostic Events"}]}]}]}]}},"pageContext":{"originPath":"hotchocolate/integrations/spatial-data.md"}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}