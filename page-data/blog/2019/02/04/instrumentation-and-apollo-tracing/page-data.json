{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/02/04/instrumentation-and-apollo-tracing","result":{"data":{"mdx":{"excerpt":"Today we have released Hot Chocolate  0.7.0 , containing one cool new feature,\nwe wanne talk about here, namely  Apollo Tracing  which isâ€¦","frontmatter":{"featuredImage":null,"path":"/blog/2019/02/04/instrumentation-and-apollo-tracing","title":"GraphQL .NET Instrumentation API and Apollo Tracing","tags":["hotchocolate","graphql","dotnet","aspnetcore","tracing"],"author":"Rafael Staib","authorImageUrl":"https://avatars0.githubusercontent.com/u/4325318?s=100&v=4","authorUrl":"https://github.com/rstaib","date":"February 04, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/02/04/instrumentation-and-apollo-tracing\",\n  \"date\": \"2019-02-04\",\n  \"title\": \"GraphQL .NET Instrumentation API and Apollo Tracing\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\", \"tracing\"],\n  \"author\": \"Rafael Staib\",\n  \"authorUrl\": \"https://github.com/rstaib\",\n  \"authorImageUrl\": \"https://avatars0.githubusercontent.com/u/4325318?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today we have released Hot Chocolate \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0.7.0\"), \", containing one cool new feature,\\nwe wanne talk about here, namely \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo Tracing\"), \" which is extremely powerful in\\nidentifing things like performance bottlenecks in our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"APIs\"), \" for\\nexample. As a result, we had to enhance our general instrumentation layer, which\\nwe all benefit from. For instance, now it's way easier to register a\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DiagnosticObserver\"), \" and bring in your own tracing framework, respectively. In\\nthis blog article we will focus on these two topics.\"), mdx(\"h2\", null, \"Apollo Tracing\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo Tracing\"), \" is a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/apollographql/apollo-tracing\"\n  }), \"performance tracing specification\"), \" for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" servers.\\nIt's not part of the actual \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://facebook.github.io/graphql\"\n  }), \"specification\"), \" itself, but there is a\\ncommon agreement in the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" community that this should be supported by\\nall \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \" servers.\"), mdx(\"p\", null, \"So, we decided to introduce built-in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo Tracing\"), \" support with this version.\\nIn order to enable \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Apollo Tracing\"), \" we just need to provide our own instance of\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryExecutionOptions\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddGraphQL\"), \" extension method and set the\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TracingPreference\"), \" option to either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TracingPreference.Always\"), \" or\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TracingPreference.OnDemand\"), \". The difference between these two options is\\nwhether tracing should be enabled always which means for each request or on\\ndemand which means per request. But for now, enough words, let's see how this\\nwould look like in code.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(sp => Schema.Create(c =>\\n{\\n    // Here goes the schema definition which is omitted for brevity purpose\\n}),\\nnew QueryExecutionOptions\\n{\\n    TracingPreference = TracingPreference.Always\\n});\\n\")), mdx(\"p\", null, \"There it is. Very simple and straightforward, right? For more information head\\nover \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/apollo-tracing\"\n  }), \"here\"), \". Now, let's jump over to\\nthe next topic.\"), mdx(\"h2\", null, \"Instrumentation API\"), mdx(\"p\", null, \"In this version we did some heavy lifting in form of refactorings regarding the\\nquery execution pipeline. This really helped us enhancing the\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Instrumentation\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"API\"), \" which has been evolved in two ways. First, we increased\\nthe amount of available diagnostic events for more fine-grained tracing\\nscenarios. Second, we simplified the registering of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DiagnosticObservers\"), \" by\\nusing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Dependancy Injection\"), \" infrastructure. In the next example we can see how\\nto register a custom \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DiagnosticObservers\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddGraphQL(sp => Schema.Create(c =>\\n{\\n    // Here goes the schema definition which is omitted for brevity purpose\\n}),\\nbuilder =>\\n{\\n    return builder\\n        .UseDefaultPipeline()\\n        .AddDiagnosticObserver<CustomDiagnosticObserver>();\\n});\\n\")), mdx(\"p\", null, \"So far so good. Writing a custom \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DiagnosticObservers\"), \" is not difficult. Let's\\nsee how we could achieve this.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"using HotChocolate.Execution;\\nusing Microsoft.Extensions.DiagnosticAdapter;\\n\\nnamespace CustomNamespace\\n{\\n    internal class CustomDiagnosticObserver\\n        : IDiagnosticObserver\\n    {\\n        [DiagnosticName(\\\"HotChocolate.Execution.Query\\\")]\\n        public void QueryExecute()\\n        {\\n            // This method is required to enable recording \\\"Query.Start\\\" and\\n            // \\\"Query.Stop\\\" diagnostic events. Do not write code in here.\\n        }\\n\\n        [DiagnosticName(\\\"HotChocolate.Execution.Query.Start\\\")]\\n        public void BeginQueryExecute(IQueryContext context)\\n        {\\n            // Here goes your code to trace begin query execution events.\\n        }\\n\\n        [DiagnosticName(\\\"HotChocolate.Execution.Query.Stop\\\")]\\n        public void EndQueryExecute(\\n            IQueryContext context,\\n            IExecutionResult result)\\n        {\\n            // Here goes your code to trace end query execution events.\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the above example we showed you just a few diagnostic events. Head over\\n\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/instrumentation\"\n  }), \"here\"), \" for a complete list of\\ndiagnostic events.\"), mdx(\"p\", null, \"We hope you enjoyed reading and be welcome to let us know what you think about\\nit in the comments section. Thank you!\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"3 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}