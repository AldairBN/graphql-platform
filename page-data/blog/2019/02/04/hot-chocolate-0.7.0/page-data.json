{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/02/04/hot-chocolate-0.7.0","result":{"data":{"mdx":{"excerpt":"Today we have released Hot Chocolate version 0.7.0 which brings a lot of new features, improvements and bug fixes. With this post I walk youâ€¦","frontmatter":{"featuredImage":null,"path":"/blog/2019/02/04/hot-chocolate-0.7.0","title":"GraphQL - Hot Chocolate 0.7.0","tags":["hotchocolate","graphql","dotnet","aspnetcore"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"February 04, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/02/04/hot-chocolate-0.7.0\",\n  \"date\": \"2019-02-04\",\n  \"title\": \"GraphQL - Hot Chocolate 0.7.0\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today we have released Hot Chocolate version 0.7.0 which brings a lot of new features, improvements and bug fixes. With this post I walk you through the major changes.\"), mdx(\"p\", null, \"The main focus of this release was to make the execution engine more extendable.\"), mdx(\"p\", null, \"The execution engine in version 0.6.0 was closed and as a user of Hot Chocolate you didn't really have any chance to change it's behavior.\"), mdx(\"p\", null, \"The only way to write field middleware components was through directives. With our new release this will fundamentally change.\"), mdx(\"h2\", null, \"QueryExecutionBuilder\"), mdx(\"p\", null, \"With version 0.7.0 we opened up the field middleware pipeline to be extended.\"), mdx(\"p\", null, \"Moreover, we broke the query execution pipeline into query middleware components that can be swapped out or extended by writing a query middleware.\"), mdx(\"p\", null, \"This all can be done with the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"QueryExecutionBuilder\"), \" that provides a simple to use API to customize how the query executor works.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"  IQueryExecutor executor = QueryExecutionBuilder.New()\\n    .Use(next => context =>\\n    {\\n      // ...\\n    })\\n    .UseDefaultPipeline()\\n    .Build(schema);\\n\")), mdx(\"p\", null, \"Instead of using the default pipeline we can also add the included middleware components one by one and swap out the ones that we do want to replace.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"  IQueryExecutor executor = QueryExecutionBuilder.New()\\n    .AddOptions(options)\\n    .AddErrorHandler()\\n    .AddQueryValidation()\\n    .AddDefaultValidationRules()\\n    .AddQueryCache(options.QueryCacheSize)\\n    .AddExecutionStrategyResolver()\\n    .AddDefaultParser()\\n    .Use(next => context =>\\n    {\\n      // ...\\n    })\\n    .UseInstrumentation(options.TracingPreference)\\n    .UseRequestTimeout()\\n    .UseExceptionHandling()\\n    .UseQueryParser()\\n    .UseValidation()\\n    .UseOperationResolver()\\n    .UseMaxComplexity()\\n    .UseOperationExecutor();\\n    .Build(schema);\\n\")), mdx(\"p\", null, \"On top of the new execution pipeline we build features like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Apollo Tracing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Schema Stitching\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pagination Support\")), mdx(\"p\", null, \"More about this can be read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/middleware\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Syntax Rewriter\"), mdx(\"p\", null, \"We also invested in our parser and added a lot of visitor and rewriter base classes that make working with the syntax tree less effort.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"What are visitors and rewriter good for?\")), mdx(\"p\", null, \"We started really thinking about this feature when we conceived the new schema stitching. We wanted to branch of parts of the query and rewrite them to become a query for another schema that is located somewhere else.\"), mdx(\"p\", null, \"Rewriters are basically visitors that walk the graph and as they do that create a new query. Basically you pass in a syntax node and the rewriter returns a new syntax node that represents the rewritten node.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"FieldNode newField = rewriter.Rewrite(originalField);\\n\")), mdx(\"p\", null, \"This can be very useful if we want to map a graph to a database or create something like a schema stitching layer etc.\"), mdx(\"p\", null, \"More about this can be read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/parser\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"GraphQL Spec State\"), mdx(\"p\", null, \"With version 0.7.0 we have added support for repeatable directives. This feature is slated for the next GraphQL spec version and allows to pipeline directives like the following:\"), mdx(\"p\", null, \"{\\na @fetch @replace('a' 'b') @replace('b' 'c')\\n}\"), mdx(\"p\", null, \"This behavior feels really awesome when you use executable directives, since with this you can build the field resolver pipeline by stacking directives together.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Directives are per default non-repeatable.\")), mdx(\"h2\", null, \"Error Filter\"), mdx(\"p\", null, \"One of the regular questions users had was about how to handle custom exceptions with Hot Chocolate.\"), mdx(\"p\", null, \"With exception filters we now provide you with a simple way to do just this.\"), mdx(\"p\", null, \"The execution engine will transform any exception thrown into a generic GraphQL error.\"), mdx(\"p\", null, \"With exception filters you can then rewrite those errors for certain exceptions in order to provide more useful information.\"), mdx(\"p\", null, \"More about this can be read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/errors\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Schema Stitching\"), mdx(\"p\", null, \"On top of the execution improvements we built our new schema stitching capabilities. With those you are able to easily fuse service endpoints together.\"), mdx(\"p\", null, \"More about this can be read \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"2019-01-24-schema-stitching.md\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Apollo Tracing\"), mdx(\"p\", null, \"With version 0.7.0 we have introduced diagnostic sources that can be used to add custom tracing and diagnostic solutions.\"), mdx(\"p\", null, \"Furthermore, we now support \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/apollographql/apollo-tracing\"\n  }), \"Apollo Tracing\"), \". Apollo Tracing can be opted in by setting the tracing preference on the execution options. We recommend to switch it to on-demand, which allows you to send a header when ever you want to get performance performance information about a call.\"), mdx(\"h2\", null, \"Relay and Paging\"), mdx(\"p\", null, \"We made creating relay compliant schemas a lot easier with this release. We introduced the paging structures as well as the node interface.\"), mdx(\"p\", null, \"Relay compliant paging can be done with one line of code if your data is provided by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IQueryable<T>\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n  .Field(t => t.GetCustomers)\\n  .UsePaging<CustomerType>();\\n\")), mdx(\"p\", null, \"Moreover, we have introduced a middleware that makes your IDs schema unique like required by the relay server specs without you having to implement any of that.\"), mdx(\"p\", null, \"We will follow up this post with a post on how to best build schemas for relay.\"), mdx(\"p\", null, \"More about paging can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/pagination\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Type Conversion\"), mdx(\"p\", null, \"Until now the type conversion logic of Hot Chocolate was not accessible by the developer. This caused a lot of frustration since we were not able to add custom type conversions in a transparent way. So, basically the user had to add this code into his/her resolver logic. This felt like clutter that should not be there.\"), mdx(\"p\", null, \"We have now introduced a new type conversion API.\"), mdx(\"p\", null, \"Let us say you are working with mongo and you want to add an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectId\"), \" conversion that basically converts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectId\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectId\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"TypeConversion.Default.Register<string, ObjectId>(from => ObjectId.Parse(from));\\nTypeConversion.Default.Register<ObjectId, string>(from => from.ToString());\\n\")), mdx(\"p\", null, \"So, that basically settles it. Two lines of code an you are done. You can also implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITypeConverter\"), \" in order to accommodate more complex code or just because you want to have your converters in class form.\"), mdx(\"p\", null, \"Furthermore, we can create a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeConversion\"), \" instance that only contains our specified conversion logic and none of our default converters in order to have tight control over them.\"), mdx(\"p\", null, \"In this case we add the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeConversion\"), \" instance to our dependency injection and the execution engine will prefer the one provided via dependency injection over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeConversion.Default\"), \".\"), mdx(\"h2\", null, \"DataLoader\"), mdx(\"p\", null, \"We already provided an API for writing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" but due to feedback from the community we rewrote our implementation to make it easier to use. You can now write \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" with a single line of code by providing us with a delegate that fetches your data.\"), mdx(\"p\", null, \"An example project that shows the new \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples/tree/master/DataLoader\"\n  }), \"here\"), \".\"), mdx(\"p\", null, \"Or head over to our documentation \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/dataloaders\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Scalar Types\"), mdx(\"p\", null, \"We removed our extended scalars from the base setup. This means that you now have to tell your schema to use these.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"Schema.Create(c =>\\n{\\n    c.RegisterExtendedScalarTypes();\\n});\\n\")), mdx(\"p\", null, \"This gives you more control about your type system and allows you to implement your own version of long etc.\"), mdx(\"p\", null, \"More about scalar types can be found \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/docs/custom-scalar-types\"\n  }), \"here\"), \".\"), mdx(\"h2\", null, \"Generic InterfaceType and UnionType\"), mdx(\"p\", null, \"The generic \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InterfaceType\"), \" allows you to assign a .Net interface to a GraphQL interface. All object types that then have a .Net type associated will automatically implement this interface if the .Net type implements the .Net interface. Confused :)\"), mdx(\"p\", null, \"Let`s see some code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType : InterfaceType<IFoo>\\n{\\n\\n}\\n\")), mdx(\"p\", null, \"If we would do nothing else we will infer the fields from the interface.\"), mdx(\"p\", null, \"If we now had the following type:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Bar : IFoo { }\\n\\npublic class BarType : ObjectType<Bar>\\n{\\n\\n}\\n\")), mdx(\"p\", null, \"Then we do not explicitly need to point to the interface anymore since we can infer the usage of the interface.\"), mdx(\"p\", null, \"The same works for generic union types where you now can use marker interfaces to assign types to a set. For our purists that only want to you .Net types the following works now to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"Schema.Create(c =>\\n{\\n    c.RegisterType<IFoo>();\\n    c.RegisterType<Bar>();\\n});\\n\")), mdx(\"h2\", null, \"Source Code Link\"), mdx(\"p\", null, \"We now support NuGet source code link. This means that you can debug into the Hot Chocolate source. This is often a great help when you are struggling with a bug or do want to check whats happening.\"), mdx(\"h2\", null, \"What`s comming next\"), mdx(\"p\", null, \"Version 7 was a big release with a lot of new features that make it very easy to setup a GraphQL schema in .Net. With this release out we now focus on Version 8 which will focus on schema stitching. We will introduce capabilities like auto-stitching and auto-mocking. We already started working on the new schema stitching stories and if you think you would like to contribute ideas or code or documentation just feel free to talk to us. We are quite happy for any help.\"), mdx(\"p\", null, \"After the schema stitching enhancements we will focus on the new schema builder with Version 9. The schema builder will bring in completely new capabilities that let you extend the schema building process. We are basically opening up the schema building process like we did with the execution engine.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"8 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}