{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/11/29/schema-design","result":{"data":{"mdx":{"excerpt":"When you think about how we build our GraphQL schemas with Hot Chocolate we always need to fall back to either the schema types or theâ€¦","frontmatter":{"featuredImage":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACEElEQVQoz2WRzVLTUBiGcxVundGL0BnvQvfegVfg0gUbx5U7XOi40BlHyk5lRgcQ0MqPCJTy00IbIEkh5ZwkbZqmSR6/lDYUPTNPzmnOed7vO6nBxMhGj3zOskwYz/9zdTDjhi8/DcZyOj44ETKx9+9Is5QkTWTOChI5Z1xXpAgr1unN9bWYFu8H8r6fpEQ5g/QqMB/nx4o4GhShaR4g69jvE26ck+/ESSZiMuy8Yu3wdvklYR86/QGB4AvDKysnYH56g+piYxgSyUZPVmHDR3+soUp19JyJF/TwezGnWvHm6ROm7t9lfuELKoZ2GONKupFX3l1q8G16lXKpQtsNsS5cTOUSVBTurIS1Q9zXVVrKw/JTtsvveP/4Dh8e3qP07AE7X59jaR8riDE6ccL6pwNWhfLsLk4rQMvV2/EA90jTkg5bMzXsuSYtHeLIFe3mGvuvbrP04hbm7CM21z7T9EKOVYihRLYvOtiXIU1T43g9Wt0+dhBhRTFnusfpXpsTKdCUvYbqciRdrizOsFCaYqthUu/AvtuhKhi56EiANeLEjzBFbEpQXvFIuqp3Impul4N2l31hzw3Y0ylVX/4c+URbjscfudmm42MUolC/7FITDgtRqkr3lfOAHWFbGIsbtmbdUqxZml+WR/lM8+NUYxSisCvyWNwaib+FddsX0WN1JP4UVkRePlEsCd9NxeKIv8nlNB0L94SVAAAAAElFTkSuQmCC","aspectRatio":1.9047619047619047,"src":"/static/7be2244f6a40210dca5845da740253e6/0514f/hotchocolate-banner.png","srcSet":"/static/7be2244f6a40210dca5845da740253e6/3cf40/hotchocolate-banner.png 200w,\n/static/7be2244f6a40210dca5845da740253e6/bc001/hotchocolate-banner.png 400w,\n/static/7be2244f6a40210dca5845da740253e6/0514f/hotchocolate-banner.png 800w,\n/static/7be2244f6a40210dca5845da740253e6/43fe9/hotchocolate-banner.png 1200w","sizes":"(max-width: 800px) 100vw, 800px"}}},"path":"/blog/2019/11/29/schema-design","title":"Lets supercharge your GraphQL schema :)","tags":["hotchocolate","graphql","dotnet","aspnetcore"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"November 29, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/11/29/schema-design\",\n  \"date\": \"2019-11-29\",\n  \"title\": \"Lets supercharge your GraphQL schema :)\",\n  \"featuredImage\": \"shared/hotchocolate-banner.png\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When you think about how we build our GraphQL schemas with Hot Chocolate we always need to fall back to either the schema types or the GraphQL SDL in order to get the typings right.\"), mdx(\"p\", null, \"This brings with it a lot of boiler plate code that we actually could infer from our C# code. With version 10.3.0 we have decided to integrate some of the version 11 features to make it possible to have these capabilities now instead of next year.\"), mdx(\"h2\", null, \"Nullability\"), mdx(\"p\", null, \"First, let us get the obvious out of the way. C# with version 8.0 has now nullable reference types, or actually they now have non-null reference types.\"), mdx(\"p\", null, \"It does not matter how you look at it, but the result is that we now can differentiate between nullable reference types and reference types that cannot be null.\"), mdx(\"p\", null, \"With version 10.3.0-preview.2 we can infer these, and you finally do not need helpers like attributes and other things to define your schema types with non-null types.\"), mdx(\"p\", null, \"A simple query like ...\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    /// <summary>\\n    /// This field says hello.\\n    /// </summary>\\n    public string SayHello(string? name)\\n    {\\n        return name is null ? \\\"Hello!\\\" : $\\\"Hello {name}!\\\"\\n    }\\n}\\n\")), mdx(\"p\", null, \"... is now correctly inferred to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  \\\"This field says hello.\\\"\\n  sayHello(name: String): String!\\n}\\n\")), mdx(\"p\", null, \"Do not get me wrong here, I still love our schema types and we will not get rid of them since they are the foundation of every schema. We still are using them in the above example, you just do not need to see them anymore. Moreover, we see these improvements more as an additional way to define a GraphQL schemas with pure C# types.\"), mdx(\"p\", null, \"In the beginning we decided that people should be free in their way of how they want to define their schemas. We are still 100% committed to SDL first, code-first with schema types and code-first with pure C# types.\"), mdx(\"h2\", null, \"Interfaces\"), mdx(\"p\", null, \"Since version 10.0.0 Hot Chocolate is able to infer interface types from API usage. This means that we will correctly infer the interfaces that you use and the types that implement those interfaces.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    /// <summary>\\n    /// Get my pet :)\\n    /// </summary>\\n    public IPet? GetPet(int id)\\n    {\\n        // some code\\n    }\\n}\\n\\npublic interface IPet\\n{\\n    // some code\\n}\\n\\npublic class Dog : IPet\\n{\\n    // some code\\n}\\n\\npublic class Cat : IPet\\n{\\n    // some code\\n}\\n\\nSchemaBuilder.New()\\n    .AddQuery<Query>()\\n    .AddType<Dog>()\\n    .AddType<Cat>()\\n    .Create();\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  \\\"Get my pet :)\\\"\\n  pet(id: Int!): IPet\\n}\\n\\ninterface Pet {\\n    // fields\\n}\\n\\ntype Dog implements Pet {\\n    // fields\\n}\\n\\ntype Cat implements Pet {\\n    // fields\\n}\\n\")), mdx(\"p\", null, \"This feels awesome. The schema builder translates our C# types exactly the way we meant them. We do not have to tell the schema builder any more how to do that it will just work.\"), mdx(\"h2\", null, \"Descriptor Attributes\"), mdx(\"p\", null, \"But what about field middleware and other more complex features like type extensions and so on.\"), mdx(\"p\", null, \"This was something we contemplated for a long time. In the end we came up with powerful descriptor attributes. This basically allows you to create attributes for your schema in which you have access to the full descriptor API. Let me give you an example for this.\"), mdx(\"p\", null, \"Let us say we want to create a simple middleware that can be put on properties and methods and that applies a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ToUpper\"), \" on every resulting \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" on the annotated member.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public sealed class ToUpperAttribute : ObjectFieldDescriptorAttribute\\n{\\n    protected override void OnConfigure(IObjectFieldDescriptor descriptor)\\n    {\\n        descriptor.Use(next => async ctx =>\\n        {\\n            await next(ctx);\\n\\n            if(ctx.Result is string s)\\n            {\\n                ctx.Result = s.ToUpperInvariant();\\n            }\\n        })\\n    }\\n}\\n\")), mdx(\"p\", null, \"The neat thing is that we have full access to all the things we have on our fluent API. The attributes very cleanly packages all the logic and makes it very easy applicable. By just applying an attribute to a property or method I can add huge functionality to that member (resolver).\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Query\\n{\\n    /// <summary>\\n    /// This field says hello.\\n    /// </summary>\\n    [ToUpper]\\n    public string SayHello(string? name)\\n    {\\n        return name is null ? \\\"Hello!\\\" : $\\\"Hello {name}!\\\"\\n    }\\n}\\n\")), mdx(\"p\", null, \"This allows us to enable the full power of schema types with pure C# types. The new attributes will arrive with 10.3.0-preview.3 probably on Monday.\"), mdx(\"p\", null, \"We will add attributes for each descriptor type. Moreover, you can apply input and output attributes on the same type, and we will create automatically an output- and an input-version of that type.\"), mdx(\"p\", null, \"We will also provide attributes for all our middleware like paging, filtering, sorting and authorization. So, you will have the full power of Hot Chocolate even when you do not use our schema type directly.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I really love this feature :)\")), mdx(\"h2\", null, \"Type Extensions\"), mdx(\"p\", null, \"Another thing we want to make better with 10.3.0 are the code-first type extensions. You could already do cool things with the type extensions but there are two things that did not feel nice enough.\"), mdx(\"p\", null, \"First, we did not have a generic type extension type. This means that defining fields can sometimes be a pain. We had to either declare fields and provide the declaring type with them or we had to specify the field with a string name.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooExtension : ObjectTypeExtension\\n{\\n    protected override void Configure(ObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Foo\\\");\\n        descriptor.Field<Foo>(t => t.Bar).Use(...);\\n        descriptor.Field(\\\"baz\\\").Use(...);\\n    }\\n}\\n\")), mdx(\"p\", null, \"With the new version we can now basically do the same than we do with standard types by providing a type parameter:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooExtension : ObjectTypeExtension<Foo>\\n{\\n    protected override void Configure(ObjectTypeDescriptor<Foo> descriptor)\\n    {\\n        descriptor.Name(\\\"Foo\\\");\\n        descriptor.Field(t => t.Bar).Use(...);\\n    }\\n}\\n\")), mdx(\"p\", null, \"The second thing that is sometimes good and other times bad is that we have to provide an name. With 10.3.0 we first of all can now infer the type from the mode.\"), mdx(\"p\", null, \"You also can just type in the name like before. Or you provide as with the type that you want to actually extend.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooExtension : ObjectTypeExtension<Foo>\\n{\\n    protected override void Configure(ObjectTypeDescriptor<Foo> descriptor)\\n    {\\n        descriptor.Extend<FooType>()\\n        descriptor.Field(t => t.Bar).Use(...);\\n    }\\n}\\n\")), mdx(\"h2\", null, \"Optional\"), mdx(\"p\", null, \"Another concept we will introduce with 10.3.0 is optionals. This is often a thing we want to use when we are talking about input types. We have introduced this concept already with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Strawberry Shake\"), \" and like it a lot.\"), mdx(\"p\", null, \"So, we are porting it now back to the server. In your resolvers you can now use for every argument the optional wrapper type and this will tell you if the argument was not provided. This will allow you to easily do partial updates. We could do partial updates before but not as elegant as now. With version 11 we will improve on that by having a nice patch type.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public async Task<Foo> GetMyFoo(Optional<string> id)\\n{\\n    // ...\\n}\\n\")), mdx(\"p\", null, \"Also you can use optionals in input objects.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class Foo\\n{\\n    public Optional<string> Bar { get; set; }\\n}\\n\")), mdx(\"p\", null, \"The nice thing with the inputs are that they implicitly convert.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"var foo = new Foo { Bar = \\\"My String\\\" };\\n\")), mdx(\"h2\", null, \"Wrapping it up\"), mdx(\"p\", null, \"Hot Chocolate 10.3.0 will bring a lot new improvements to how we can create GraphQL schemas. All these changes are just additions and there are no breaking changes involved meaning we give you a lot of version 11 productivity improvements now.\"), mdx(\"p\", null, \"So, when can you expect 10.3.0. We will deliver nullable ref types with 10.3.0-preview.2 (tonight) and the attributes will come 10.3.0-preview.3. We think the final version should be ready end of next week. We initially planned end of this week but we still have some bug fixing to do.\"), mdx(\"p\", null, \"I hope you are as exited as I am about this. Happy Thanksgiving :) and get a super awesome Hot Chocolate with marshmallows to get into your GraphQL groove.\"), mdx(\"p\", null, \"If you want to get into contact with us head over to our slack channel and join our community.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"7 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}