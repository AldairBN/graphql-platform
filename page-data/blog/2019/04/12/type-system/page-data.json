{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/04/12/type-system","result":{"data":{"mdx":{"excerpt":"Originally, I wanted to write a little post about what we are currently working on in version 9 and how those things are coming along, butâ€¦","frontmatter":{"featuredImage":null,"path":"/blog/2019/04/12/type-system","title":"GraphQL - Hot Chocolate 9.0.0 - Type System","tags":["hotchocolate","graphql","dotnet","aspnetcore"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"April 12, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/04/12/type-system\",\n  \"date\": \"2019-04-12\",\n  \"title\": \"GraphQL - Hot Chocolate 9.0.0 - Type System\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Originally, I wanted to write a little post about what we are currently working on in version 9 and how those things are coming along, but every time I started writing on this post it got longer and longer and it felt a bit too messy.\"), mdx(\"p\", null, \"Starting with this post we will start talking about version 9 in more detail. We will split this into several blog posts that will cover different parts of the new version. This post will focus on the type system improvements.\"), mdx(\"p\", null, \"We started with version 9.0.0-preview.9 to deliver more and more parts of the new type system. With version 9.0.0-preview.11 we are delivering a ton of bug fixes and many more new features.\"), mdx(\"h2\", null, \"Schema Builder\"), mdx(\"p\", null, \"The most prominent API that we are introducing is the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" provides us with a new way to define schemas. Do not worry the current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ISchemaConfiguration\"), \" API is still supported and will not go away. In fact, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ISchemaConfiguration\"), \" now is just an interface over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" and we will evolve both APIs over time so that you can pick the one that you like more.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"ISchema schema = SchemaBuilder.New()\\n    .AddQueryType<FooType>()\\n    .Create();\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"So, why did we introduce a new API to define a schema?\")), mdx(\"p\", null, \"First, we wanted the builder API to be decoupled from the actual schema, we wanted to be able to start adding schema types and other parts to a schema builder without being forced to create the schema.\"), mdx(\"p\", null, \"With the schema builder we are now more flexible in scenarios like schema stitching.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"ISchema schema = SchemaBuilder.New()\\n    .AddQueryType<FooType>()\\n    .AddDirectiveType<BarType>()\\n    .AddSchemaFromFile(\\\"./Schema.graphql\\\")\\n    .AddContextData(\\\"foo\\\", \\\"bar\\\")\\n    .ModifyOptions(options => {  })\\n    .AddServices(services_a)\\n    .AddServices(services_b)\\n    .Create();\\n\")), mdx(\"h2\", null, \"Conventions\"), mdx(\"p\", null, \"With our new schema builder, we did a lot of work underneath and introduced the ability to use services during type construction.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"For what is that useful?\")), mdx(\"p\", null, \"For one you can now register our new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INamingConverions\"), \" with the dependency injection and then the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" will use your naming conventions instead of the built-in naming conventions.\"), mdx(\"p\", null, \"Also, you can register our new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITypeInspector\"), \" and override how we infer schema types from POCOs. This will allow you for instance to add support for custom attributes, so no need to pollute your API with our attributes anymore.\"), mdx(\"p\", null, \"But fear not, you do not have to implement the whole \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"INamingConverions\"), \" interface for instance since you can override each part of our default implementation.\"), mdx(\"p\", null, \"Since, in many cases we just want to tune existing naming conventions we can inherit from the default implementation \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DefaultNamingConventions\"), \" and overwrite just what we want to change.\"), mdx(\"p\", null, \"So, if we wanted to add to all the input type names the prefix \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"super\"), \" we could do this like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class MyNamingConventions\\n{\\n    public override NameString GetTypeName(Type type, TypeKind kind)\\n    {\\n        if (type == null)\\n        {\\n            throw new ArgumentNullException(nameof(type));\\n        }\\n\\n        if (kind == TypeKind.InputObject)\\n        {\\n            if (!name.EndsWith(\\\"Super\\\", StringComparison.Ordinal))\\n            {\\n                name = name + \\\"Super\\\";\\n            }\\n        }\\n\\n        return base.GetTypeName(type, kind);\\n    }\\n}\\n\")), mdx(\"p\", null, \"Like with the naming conventions we provide a default implementation to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ITypeInspector\"), \" where we can replace or extend parts that we want to modify.\"), mdx(\"p\", null, \"In order to register our conventions with the schema builder we can do the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services.AddSingleton<INamingConverions, MyNamingConventions>();\\n    services.AddGraphQL(sp => Schema.Create(c =>\\n    {\\n        c.RegisterServiceProvider(sp);\\n        c.RegisterQuerType<Foo>();\\n    }));\\n\\n}\\n\")), mdx(\"p\", null, \"Or we could do it like the following with the new schema builder:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public void ConfigureServices(IServiceCollection services)\\n{\\n    services.AddSingleton<INamingConverions, MyNamingConventions>();\\n    services.AddGraphQL(sp => SchemaBuilder.New()\\n        .AddQueryType<Foo>()\\n        .AddServices(sp));\\n}\\n\")), mdx(\"h2\", null, \"Extending Types\"), mdx(\"p\", null, \"One other major reason to rethink our type system was that many of you wanted to extend on types. One common thing that people wanted to do is to introduce generic types. We did something like this with our relay types. GraphQL does not really have generic types but the idea here is that you could have a type like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class EdgeType<TSchemaType>\\n    : ObjectType<IEdge>\\n    where TSchemaType : IOutputType\\n{\\n}\\n\")), mdx(\"p\", null, \"If we for instance put in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringType\"), \" as TSchemaType then the edge type would become \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringEdge\"), \" in the schema. While this is not so difficult if our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringType\"), \" has a fixed name, it becomes more difficult if \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StringType\"), \" would create its name also depending on another type.\"), mdx(\"p\", null, \"With version 9 we redesigned the schema initialization process so, that you can register dependencies for a type with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \". This way the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \" knows which type has to be initialized in which order.\"), mdx(\"p\", null, \"So, let us have a look at how we would create our edge type with version 9:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class EdgeType<TSchemaType>\\n    : ObjectType<IEdge>\\n    where T : IOutputType\\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor<IEdge> descriptor)\\n    {\\n        descriptor.Name(dependency => dependency.Name + \\\"Edge\\\")\\n            .DependsOn<TSchemaType>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"With the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Name\"), \" extension on the type descriptors we are now able to define a delegate that represents the naming algorithm for that type. Moreover, we can now express on which type this algorithm depends.\"), mdx(\"p\", null, \"This new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Name\"), \" descriptor extension is built upon our new descriptor extension API that provides a new way to extend our descriptors without needing to create a new base class.\"), mdx(\"h3\", null, \"Extending Descriptors\"), mdx(\"p\", null, \"Each descriptor now provides a new method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \". \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" returns an extension descriptor that allows us to integrate some logic with the type initialization pipeline.\"), mdx(\"p\", null, \"Types are created in three phases:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Create Instance\\nThe initializer creates the type instance and the type definition.\\nThe type definition contains all information to create and initialize a type.\\nAfter this step the type instance exists and is associated with a native .net type.\\nThe native .net type can be object but can also be something more specific.\\nIn this phase the type will also report all of its dependencies to the schema builder.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Complete Name\\nAfter all types are created the names of the types will be completed.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Complete Type\\nIn the last step the types will be completed, this means that for instance the fields are assigned, or the directives are retrieved and associated with a type etc.\\nAfter this the type is completed and becomes immutable.\"))), mdx(\"p\", null, \"The extension descriptor provides extension points to these three phases:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"OnBeforeCreate\\nOnBeforeCreate will allow you to customize the type definition.\\nIt is important to know that this step is not allowed to be dependent on another type object. Also, at this point you will not have access to the type completion context.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"OnBeforeNaming\\nOnBeforeNaming allows to provide logic to generate the name of a type.\\nYou can declare two kinds of dependencies in this step, either the dependency has to be named first or the dependency is allowed to be in any state.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"OnBeforeCompletion\\nOnBeforeCompletion allows to provide further logic that modifies the type definition. For instance, we could be dependent on another type in order to generate fields based on the fields of that other type.\\nYou can declare two kinds of dependencies in this step, either the dependency has to be completed first or the dependency is allowed to be in any state.\"))), mdx(\"p\", null, \"Let us have a look at how we implemented our own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Name\"), \" extension method in order to understand what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" is useful for:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n  .Extend()\\n  .OnBeforeNaming((ctx, definition) =>\\n  {\\n      INamedType type = ctx.GetType<INamedType>(\\n          ClrTypeReference.FromSchemaType(typeInfo.ClrType));\\n      definition.Name = createName(type);\\n  })\\n  .DependsOn(dependency, mustBeNamed:true);\\n\")), mdx(\"p\", null, \"Let us pic that example apart in order to understand what we did here. First, we called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" returns the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IDescriptorExtension<T>\"), \" which allows us to register some code with the descriptor events that I have described earlier.\"), mdx(\"p\", null, \"Each event will provide us with the type definition and the completion context. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ICompletionContext\"), \" is the API to request information from the schema builder. In the case of our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Name\"), \" extension we are requesting the type instance for our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TSchemaType\"), \". After that we call the naming algorithm with the resolved schema type.\"), mdx(\"p\", null, \"Also, we added a dependency with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependsOn\"), \". The Boolean argument on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DependsOn\"), \" declares that the type has to be named before our delegate can be executed. We can declare as many dependencies as we want, so we are not bound to have just one.\"), mdx(\"p\", null, \"Let me sum that up. The new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" method on the descriptors allow us to extend the type descriptors without the need to create a new type base class. This is nice because you can now create extension methods that work across multiple solutions without forcing the user of that extension to opt into a new type base class. This makes it easy to consume those extensions. It is important to know here that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" is available on all descriptors, so it is available on field descriptors, argument descriptors, or type descriptors.\"), mdx(\"h3\", null, \"Replacing Descriptors\"), mdx(\"p\", null, \"Though \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" is very capable, in some cases we might want to limit what is available through our descriptor. This basically means we want to remove functionality or replace the descriptor entirely. Let us assume we want to introduce an input type that describes the filter capabilities that can be applied to an output type. Basically, we want to introduce a filter input type like Prisma does.\"), mdx(\"p\", null, \"So, if we had a type like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Foo {\\n  bar: String!\\n}\\n\")), mdx(\"p\", null, \"We would want to be able to describe the filter capabilities that are available to the user of our API. This could look something like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooFilterType\\n    : FilterType<Foo>\\n{\\n    public void Configure(IFilterDescriptor descriptor)\\n    {\\n        descriptor.Filter(t => t.Bar).AllowSmallerThan();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterType<Foo>\"), \" inherits from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InputObjectType\"), \" and can with version 9 add its own descriptor. In order to replace the descriptor on our input type we would have to replace the configure method and introduce our new filter descriptor:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FilterType<T>\\n    : InputObjectType\\n{\\n    private readonly Action<IFilterTypeDescriptor<T>> _configure;\\n\\n    public FilterType()\\n    {\\n        _configure = Configure;\\n    }\\n\\n    public FilterType(Action<IFilterTypeDescriptor<T>> configure)\\n    {\\n        _configure = configure\\n            ?? throw new ArgumentNullException(nameof(configure));\\n    }\\n\\n    #region Configuration\\n\\n    protected override InputObjectTypeDefinition CreateDefinition(\\n        IInitializationContext context)\\n    {\\n        var descriptor =\\n            FilterTypeDescriptor.New<T>(\\n                DescriptorContext.Create(context.Services));\\n        _configure(descriptor);\\n        return descriptor.CreateDefinition();\\n    }\\n\\n    protected virtual void Configure(\\n        IFilterTypeDescriptor<T> descriptor)\\n    {\\n    }\\n\\n    protected sealed override void Configure(\\n        IInputObjectTypeDescriptor descriptor)\\n    {\\n        throw new NotSupportedException();\\n    }\\n\\n    #endregion\\n}\\n\")), mdx(\"p\", null, \"Like the descriptor extend logic we basically can override those three type initialization events.\"), mdx(\"p\", null, \"In order to replace the old descriptor, we sealed of the old \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method. Also, we introduced our new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configure\"), \" method with the new descriptor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"protected virtual void Configure(\\n    IFilterTypeDescriptor<T> descriptor)\\n{\\n}\\n\\nprotected sealed override void Configure(\\n    IInputObjectTypeDescriptor descriptor)\\n{\\n    throw new NotSupportedException();\\n}\\n\")), mdx(\"p\", null, \"In order to initialize our new descriptor, we overrode the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CreateDefinition\"), \" method. Our descriptor has to produce a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InputObjectTypeDefinition\"), \" in order to abide to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"InputType\"), \" interface. If you want your descriptor extendable like our descriptors, all you have to do is inherit from our descriptor base. With version 9 all descriptor and type definition classes are now public, and we strongly recommend basing your descriptors on our base classes.\"), mdx(\"h2\", null, \"Context Data Support on Types\"), mdx(\"p\", null, \"Also, with the new version we added the context data dictionary to all types, fields and arguments. You can use this to add custom metadata to objects of the type system. Context data can be declared on the type definition and will be copied to the corresponding type object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"descriptor\\n  .Extend()\\n  .OnBeforeCreate(definition =>\\n  {\\n      definition.ContextData[\\\"Foo\\\"] = \\\"Bar\\\";\\n  });\\n\")), mdx(\"p\", null, \"You can access the context data on a type object like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"schema.GetType<ObjectType>(\\\"Query\\\").ContextData.ContainsKey(\\\"Foo\\\");\\n\")), mdx(\"h2\", null, \"Improved Relay Support\"), mdx(\"p\", null, \"With version 9 we are making creating relay compliant schemas a breeze. Lets have a look at the relay server spec parts and see how those translate to Hot Chocolate:\"), mdx(\"p\", null, \"In order to activate relayjs support you can do now the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"SchemaBuilder.New()\\n    .EnableRelaySupport()\\n    .AddQueryType<Foo>()\\n    .Create()\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EnableRelaySupport\"), \" will add the node field to your query type and setup the general logic of how your nodes will be resolved using an id value. Moreover, this activates the id value serialization and deserialization. The schema will now have opaque identifiers, but you will not have to deal with those in your API.\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ObjectType\"), \"s you can now declare a type as node type. That means this type will implement the node interface and can be resolved through the node field:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType\\n    : ObjectType<Foo>\\n{\\n    protected override void Configure(IObjectTypeDescriptor<Foo> descriptor)\\n    {\\n        descriptor.AsNode<Foo,int>((ctx, id) =>\\n            ctx.Service<IMyRepository>().GetById(id));\\n    }\\n}\\n\")), mdx(\"p\", null, \"Ok, this is basically all you have to do to fulfill spec item \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"A mechanism for refetching an object.\"), \".\"), mdx(\"p\", null, \"The other spec items for the relay spec were already quite good with version 8. It felt always odd to expose so much logic about those node resolvers to the developers that we refined our current APIs. We used the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Extend\"), \" mechanism to provide extensions that help you along the way without forcing you to use a special base class.\"), mdx(\"h2\", null, \"Code-First\\xA0Type Extensions\"), mdx(\"p\", null, \"The last thing I want to talk about in this post are code-first type extensions. We already supported the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extend\"), \" keyword in the stitching layer but had no real code-first API for this. Also, we only supported this in the stitching layer. With version 9 you can now extend code-first and schema-first. Moreover, type extensions are not bound to the stitching layer and work also on a standard schema.\"), mdx(\"p\", null, \"Let us say we have the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooType\"), \" that has one field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"description\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooType\\n    : ObjectType<Foo>\\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor<Foo> descriptor)\\n    {\\n        descriptor.Field(t => t.Description);\\n    }\\n}\\n\")), mdx(\"p\", null, \"We can now introduce a type extension for our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FooType\"), \" that adds for instance a new field \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"public class FooTypeExtension\\n    : ObjectTypeExtension\\n{\\n    protected override void Configure(\\n        IObjectTypeDescriptor descriptor)\\n    {\\n        descriptor.Name(\\\"Foo\\\");\\n        descriptor.Field(\\\"test\\\")\\n            .Resolver(() => new List<string>())\\n            .Type<ListType<StringType>>();\\n    }\\n}\\n\")), mdx(\"p\", null, \"The code-first extension types can do much more then, the schema-first variant. For instance, with code-first you can add middleware parts to a field replace or update a field, replace the resolver, add or replace directives on fields, arguments and so on. Also, you have all the extension functionality that you have on normal types. In fact, since the type extension and the type are using the same descriptor you can apply the same extensions to both.\"), mdx(\"p\", null, \"Also, you can define multiple type extensions for a single type.\"), mdx(\"p\", null, \"So, let us have a look of how we add type extensions to our schema:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"ISchema schema = SchemaBuilder.New()\\n  .AddQueryType<FooType>()\\n  .AddType<FooTypeExtension>();\\n  .Create()\\n\")), mdx(\"p\", null, \"The schema builder basically treats them as types, so there is nothing special that you have to do in order to register them.\"), mdx(\"p\", null, \"As we go forward, we will also introduce generic variants of the extension types. This will be quite nice in the stitching layer since you can provide a .Net type that we will use to deserialize the object. This means that you can write your resolvers against strong types instead of the generic types that we use per default in the stitching layer.\"), mdx(\"h2\", null, \"Wrapping it up\"), mdx(\"p\", null, \"This is just the first bunch of features that are included with version 9. The best thing, all of what I have showed you today is already included in version 9.0.0-preview.11 which we have released alongside this blog post.\"), mdx(\"p\", null, \"The next few posts will focus on execution plan support in our query engine. Execution plans can be cached and persisted and will make stitching so much faster. Also, we need the new execution plan feature to introduce support for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@defer\"), \".\"), mdx(\"p\", null, \"Furthermore, we will give a peek at our new high-performance parser.\"), mdx(\"p\", null, \"Also, we will have a look at subscription stitching and our reworked subscription implementation that is now based on the pipeline API of .Net Core.\"), mdx(\"p\", null, \"Last but not least, we hope we are be able to squeeze in our new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"FilterType\"), \" feature with version 9.\"), mdx(\"p\", null, \"As you can see version 9 will bring quite a few improvements, so stay tuned for our next post on V9 and try out our previews. Also, join our slack channel and give us your take on GraphQL, tell us what you would like to see next in Hot Chocolate.\"), mdx(\"p\", null, \"With Hot Chocolate we are building a GraphQL server for the community, so join and help us along.\"), mdx(\"p\", null, \"We value any kind of contribution, whether you give us a star, a feedback, find a bug, a typo, or whether you contribute code. Every bit matters and makes our project better.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"14 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}