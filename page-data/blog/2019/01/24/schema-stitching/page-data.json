{"componentChunkName":"component---src-templates-blog-article-template-tsx","path":"/blog/2019/01/24/schema-stitching","result":{"data":{"mdx":{"excerpt":"What is schema stitching actually? Schema stitching is the capability to merge multiple GraphQL schemas into one schema on which queries canâ€¦","frontmatter":{"featuredImage":null,"path":"/blog/2019/01/24/schema-stitching","title":"GraphQL - Schema Stitching","tags":["hotchocolate","graphql","dotnet","aspnetcore","schema-stitching"],"author":"Michael Staib","authorImageUrl":"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4","authorUrl":"https://github.com/michaelstaib","date":"January 24, 2019"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"path\": \"/blog/2019/01/24/schema-stitching\",\n  \"date\": \"2019-01-24\",\n  \"title\": \"GraphQL - Schema Stitching\",\n  \"tags\": [\"hotchocolate\", \"graphql\", \"dotnet\", \"aspnetcore\", \"schema-stitching\"],\n  \"author\": \"Michael Staib\",\n  \"authorUrl\": \"https://github.com/michaelstaib\",\n  \"authorImageUrl\": \"https://avatars1.githubusercontent.com/u/9714350?s=100&v=4\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"What is schema stitching actually? Schema stitching is the capability to merge multiple GraphQL schemas into one schema on which queries can be queried.\"), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"So, for what is that useful? In our case we have lots of specialized services that serve data for a specific problem domain. Some of these services are GraphQL services, some of them are REST services and yes sadly a little portion of those are still SOAP services.\"), mdx(\"p\", null, \"Also, think about this, you cannot always start fresh and with schema stitching you can now create the schema of your \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"dreams\"), \" and merge all those other services into that new glorified schema.\"), mdx(\"p\", null, \"Apart from that UI teams tend to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"NOT\"), \" want to know about all those domain services and their specifics. They want to be able to fetch the data they need with one call, no under- or over-fetching and most importantly no repeated fetching because you first needed to fetch that special id with which you now can fetch this other thing. No, what we really want here is to have one source of truth and one call to get exactly what we want. That's what GraphQL is all about.\"), mdx(\"p\", null, \"Furthermore, we believe the schemas should be consistent and provide a way that is easily to consume.\"), mdx(\"p\", null, \"With the preview version 0.7.0-preview.35 we are now introducing schema stitching capabilities to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://hotchocolate.io/\"\n  }), \"Hot Chocolate\"), \".\"), mdx(\"p\", null, \"In this post I will walk you through how you can use schema stitching, what will be available with version 0.7.0 and what features come with the next releases.\"), mdx(\"h2\", null, \"Getting Started\"), mdx(\"p\", null, \"Assume we have two schemas one dealing with the customer data, basically the data that would be located in a CRM system of a company, the other representing insurance data about the customer, basically the technical domain specific data that gives you all the insights into the customers insurance contracts.\"), mdx(\"p\", null, \"The stitching layer is not limited to two schemas, you can actually stitch together how many schemas you want. But for our example we use those two mentioned schemas about customers and their contracts.\"), mdx(\"p\", null, \"So, let's say our customer schema looks something like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  customer(id: ID!): Customer\\n  consultant(id: ID!): Consultant\\n}\\n\\ntype Customer {\\n  id: ID!\\n  name: String!\\n  consultant: Consultant\\n}\\n\\ntype Consultant {\\n  id: ID!\\n  name: String!\\n}\\n\")), mdx(\"p\", null, \"In real life this schema would boast a lot more information about our customer but this will surfice for our little demo.\"), mdx(\"p\", null, \"And our second schema dealing with the insurance contracts looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  contract(contractId: ID!): Contract\\n  contracts(customerId: ID!): [Contract!]\\n}\\n\\ninterface Contract {\\n  id: ID!\\n}\\n\\ntype LifeInsuranceContract implements Contract {\\n  id: ID!\\n  premium: Float\\n}\\n\\ntype SomeOtherContract implements Contract {\\n  id: ID!\\n  expiryDate: DateTime\\n}\\n\")), mdx(\"p\", null, \"Imagine we have two servers serving up those schemas. The schema that we actually want for our UI team should look like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  customer(id: ID!): Customer\\n}\\n\\ntype Customer {\\n  id: ID!\\n  name: String!\\n  consultant: Consultant\\n  contracts: [Contract!]\\n}\\n\\ntype Consultant {\\n  id: ID!\\n  name: String!\\n}\\n\\ninterface Contract {\\n  id: ID!\\n}\\n\\ntype LifeInsuranceContract implements Contract {\\n  id: ID!\\n  premium: Float\\n}\\n\\ntype SomeOtherContract implements Contract {\\n  id: ID!\\n  expiryDate: DateTime\\n}\\n\")), mdx(\"p\", null, \"In order to make that happen you do not have to write actual code, we have create some directives that will tell the stitching layer what to do.\"), mdx(\"p\", null, \"Before we start, we have to give our schemas some names, these names will be used to direct remote queries to the right endpoint.\"), mdx(\"p\", null, \"Let's name the customer schema \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"customers\"), \" and the contract schema \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contracts\"), \". With that let's decorate our desired schema.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Query {\\n  customer(id: ID!): Customer @schema(name: \\\"customer\\\") @delegate\\n}\\n\\ntype Customer {\\n  id: ID!\\n  name: String!\\n  consultant: Consultant\\n  contracts: [Contract!]\\n    @schema(name: \\\"contract\\\")\\n    @delegate(path: \\\"contracts(customerId:$fields:id)\\\")\\n}\\n\\ntype Consultant {\\n  id: ID!\\n  name: String!\\n}\\n\\ninterface Contract {\\n  id: ID!\\n}\\n\\ntype LifeInsuranceContract implements Contract {\\n  id: ID!\\n  premium: Float\\n}\\n\\ntype SomeOtherContract implements Contract {\\n  id: ID!\\n  expiryDate: DateTime\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@schema\"), \" basically points to the source schema, so the stitching middleware will redirect calls to a schema with the name that is specified by this directive.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@delegate\"), \" specifies how the data is fetched. If \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@delegate\"), \" does not have any path specified than the middleware expects that the field on the target schema has the same specification.\"), mdx(\"p\", null, \"If we look at the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"customer\"), \" field then the middleware will assume that the source schema has the same customer field as root field as our stitched schema.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contracts\"), \" field on the other hand specifies a delegation path \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"contracts(customerId:$fields:id)\"), \". The delegation path specifies the field that is called and where the arguments get their input from.\"), mdx(\"p\", null, \"Let us assume you have a deeper field from which you want to fetch data like the following.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"foo(id:123) {\\n  bar {\\n    baz(top:1) {\\n      qux\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"Since, we did not want to cram a query like this into one string we allow this to be done with a flat path.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"foo(id:$arguments:arg1).bar.baz(top:1)\\n\")), mdx(\"p\", null, \"The argument assignment in the path can be done with GraphQL literals or with scope variables. The scope variables basically can refer to the fields of the declaring type (in case of our contracts field the declaring type is customer) and to the arguments of the field, in our case contracts has no arguments in the stitched schema.\"), mdx(\"h2\", null, \"Server Configuration\"), mdx(\"p\", null, \"Now that we have configured our schema let's create our server. The fastest way to do that is to use our server template.\"), mdx(\"p\", null, \"Install the server template to your dotnet CLI:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"dotnet new -i HotChocolate.Templates.Server\\n\")), mdx(\"p\", null, \"Now let's create our server:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"mkdir stitching\\ndotnet new graphql-server\\n\")), mdx(\"p\", null, \"Open the server in the editor of your choice and upgrade the packages to 0.7.0-preview.35.\"), mdx(\"p\", null, \"Go to the Startup.cs and add the HTTP clients that shall access the remote schema endpoints like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"services.AddHttpClient(\\\"customer\\\", client =>\\n{\\n    client.BaseAddress = new Uri(\\\"http://127.0.0.1:5050\\\");\\n});\\n\\nservices.AddHttpClient(\\\"contract\\\", client =>\\n{\\n    client.BaseAddress = new Uri(\\\"http://127.0.0.1:5051\\\");\\n});\\n\")), mdx(\"p\", null, \"Note that this is also the place where you would add authentication and header properties in order to access your remote schema endpoint.\"), mdx(\"p\", null, \"The clients must be named clients and have to use the schema name that we used in our schema directive earlier.\"), mdx(\"p\", null, \"Next let's setup our remote schemas. Remote schemas are actually local schemas representing the remote schemas and allowing us to treat the remote schema as if it were a usual schema written with Hot Chocolate.\"), mdx(\"p\", null, \"This also allows us to create middleware components and other things on such a schema althogh the schema does not actually live in our process.\"), mdx(\"p\", null, \"So let us start with the customer schema, the customer schema does only use scalars defined in the spec. This means we do not have to declare any extra scalars to our stitching layer.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"serviceCollection.AddRemoteQueryExecutor(b => b\\n    .SetSchemaName(\\\"customer\\\")\\n    .SetSchema(File.ReadAllText(\\\"Customer.graphql\\\")));\\n\")), mdx(\"p\", null, \"Again we use our schema name that we used earlier and we are loading a schema file describing the remote schema into the remote executor. We are basically building with that a schema the way you would with the schema-first approach.\"), mdx(\"p\", null, \"Next, let's setup our contracts schema. The contracts schema uses a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"DateTime\"), \" scalar, this one is not specified in the spec so we have to tell our schema to use this one. Since Hot Chocolate specified a bunch of extended scalars we can import one of those. If we do not have a scalar matching the one of the remote schema we would need to implement this one by extending the class \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ScalarType\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"serviceCollection.AddRemoteQueryExecutor(b => b\\n    .SetSchemaName(\\\"contract\\\")\\n    .SetSchema(FileResource.Open(\\\"Contract.graphql\\\"))\\n    .AddScalarType<DateTimeType>());\\n\")), mdx(\"p\", null, \"Now that we have setup our remote schema let's stitch everything together by providing our prepared stitched schema file:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-csharp\"\n  }), \"serviceCollection.AddStitchedSchema(\\n    FileResource.Open(\\\"Stitching.graphql\\\"),\\n    c => c.RegisterType<DateTimeType>());\\n\")), mdx(\"p\", null, \"Again like before we have to provide the extended scalar type that we used for the contracts schema.\"), mdx(\"p\", null, \"Now, we are basically done and can fire up our server.\"), mdx(\"h2\", null, \"Further Thoughts\"), mdx(\"p\", null, \"Since, remote schemas have a local schema representation in our process and the stitching layer is working on those local schemas we can also use native Hot Chocolate schemas to further extend a stitched schema.\"), mdx(\"p\", null, \"So, all what I have described so far is included in the current preview release. We are still not done and are heavy at work getting our schema stitching even better.\"), mdx(\"p\", null, \"With the next view preview builds we will introduce a batching layer to the schema stitching.\"), mdx(\"p\", null, \"Think \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \". We will basically batch all request to a schema in one go. Imagine we had two delegated query for one remote schema:\"), mdx(\"p\", null, \"Query A:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  a {\\n    b\\n  }\\n}\\n\")), mdx(\"p\", null, \"Query B:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  c {\\n    d\\n  }\\n}\\n\")), mdx(\"p\", null, \"The batching layer will rewrite those queries into one and send just one request to your remote endpoint:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  __1: a {\\n    b\\n  }\\n\\n  __2: c {\\n    d\\n  }\\n}\\n\")), mdx(\"p\", null, \"This way we have just one call and your remote endpoint can better optimize the data fetching with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"DataLoader\"), \" and so on.\"), mdx(\"h2\", null, \"Comming with 0.8.0\"), mdx(\"p\", null, \"Furthermore, we will introduce the ability to rename types. This is useful when you either want to make names more clear or if you have naming collisions. So, with the next releases we will introduce '@name' as a way to rename types and fields.\"), mdx(\"p\", null, \"Also, the ability to auto-stitch schemas and auto-fetch the a remote schema via introspection is on our todo list.\"), mdx(\"p\", null, \"In the beginning of this post I talked about stitching SOAP and REST, we are currently working on a feature that is called HTTP directives.\"), mdx(\"p\", null, \"HTTP directives let you decorate a schema SDL and thus let you map REST services onto a GraphQL schema. This schema can also be included into a stitched schema. We will tell you more about that once we have a stable version ready to go.\"), mdx(\"p\", null, \"Moreover, we will introduce a cast feature to our delegation path. This will basically allow you to use fragments without having to write the code.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-text\"\n  }), \"foo.bar<baz>(a:1).qux(b:1)\\n\")), mdx(\"p\", null, \"This transalates basically to:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  foo {\\n    bar(a: 1) {\\n      ... on baz {\\n        qux(b: 1)\\n      }\\n    }\\n  }\\n}\\n\")), mdx(\"h2\", null, \"Wrapping things up\"), mdx(\"p\", null, \"We have uploaded the above example to the following GitHub repo so you can see a working example of the schema stitching.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/ChilliCream/hotchocolate-examples\"\n  }), \"Stitching Example\")), mdx(\"p\", null, \"If you are using the example start the two remote schemas by switching to their respective directory and call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \".\"), mdx(\"p\", null, \"After both schemas are running start the stitching layer. The stitching layer has \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Apollo Tracing\"), \" enabled. Start the stitching layer also with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dotnet run\"), \" since the debugger slows the performance significantly down.\"), mdx(\"p\", null, \"The first call on the stitched schema takes a little longer (maybe 300 ~ 500 ms) since we are compiling the resolvers into a in-memory assembly. All further calls are fast (4 ~ 8 ms) in our example. The real life performance depends on how fast your connection to the stitched remote schemas is and how many data you are fetching. With the new batching layer that is coming soon the performance of the schema stitching should further improve.\"), mdx(\"p\", null, \"Open playground on http://localhost:5000/playground in order to fire up some requests agains our stitched schema and checkout the tracing tab for performance insights.\"), mdx(\"p\", null, \"The following query might be a good starting point since it will expose the ids of our objects.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"{\\n  customers {\\n    id\\n    contracts {\\n      id\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"If you have further questions or need help you join our \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://join.slack.com/t/hotchocolategraphql/shared_invite/enQtNTA4NjA0ODYwOTQ0LTViMzA2MTM4OWYwYjIxYzViYmM0YmZhYjdiNzBjOTg2ZmU1YmMwNDZiYjUyZWZlMzNiMTk1OWUxNWZhMzQwY2Q\"\n  }), \"slack channel\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"readingTime":{"text":"10 min read"}}},"site":{"siteMetadata":{"siteUrl":"https://chillicream.com","author":"Chilli_Cream"}}},"pageContext":{}},"staticQueryHashes":["1014893094","2890364758","4218812017"]}